<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial for the debug preview of lowRISC on lowRISC</title>
    <link>https://www.lowrisc.org/docs/debug-v0.3/</link>
    <description>Recent content in Tutorial for the debug preview of lowRISC on lowRISC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 May 2016 12:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.lowrisc.org/docs/debug-v0.3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Working with Zedboard</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/zedboard/</link>
      <pubDate>Sun, 12 Mar 2017 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/zedboard/</guid>
      <description>lowRISC was ported to Zedboard in KU Leuven - COSIC to design and verify trusted computing hardware extensions
Porting lowRISC to Zedboard Zedboard is versatile development board utilising Zynq SoC. It has been used in several implementations of RISC-V; hosting it as a neighbour to the Zynqâ€™s hard-coded ARM cores. However, in Zedboard the ARM cores of the Zynq are dominant: almost all peripherals or ports connect to the ARM Processing System (PS), and they are not directly reachable from Programmable Logic (PL).</description>
    </item>
    
    <item>
      <title>How to add a new peripherial</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/add_device/</link>
      <pubDate>Fri, 08 Jul 2016 11:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/add_device/</guid>
      <description>This document details the steps needed to add a second BRAM on the IO NASTI bus.
A secondary BRAM Below is the top-level connection of the BRAM to be added.
module nasti_bram ( input clk, rstn, nasti_channel.slave nasti );  Modify the global address map Assuming the BRAM is 128KB and is readable, writable but not executable, we add a new entry named &amp;ldquo;extra_bram&amp;rdquo; into the address map at $TOP/src/main/scala/Configs.</description>
    </item>
    
    <item>
      <title>Soc structure updates</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/soc_struct/</link>
      <pubDate>Fri, 08 Jul 2016 11:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/soc_struct/</guid>
      <description>Thanks to the continuous development from the RISC-V group at UC Berkeley, there are a lot of structure changes and extra features incorporated in this release.
  Shared TileLink MEM network for both cached (memory) accesses and uncached (IO) accesses. In the previous untethered release, cached memory accesses and uncached IO accesses are separated early in the L1 D$, which has the benefit of small on-chip interconnects and less interference to the memory interconnect from IO transactions.</description>
    </item>
    
    <item>
      <title>A debug session</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/debugsession/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/debugsession/</guid>
      <description>Once you have an Open SoC Debug daemon running and it connected to a target system, you can initiate a debug session. In the following you will learn the different basic features to interact with the system.
Before you begin, you should build the example programs:
make -C $TOP/fpga/bare_metal/examples hello.riscv trace.riscv  Resetting the system In the first step we will start the command line interface and reset the system.</description>
    </item>
    
    <item>
      <title>Connecting to RTL simulation and enumeration</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/simulation/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/simulation/</guid>
      <description>Build the RTL simulation The RTL simulation is a compiled simulation of the entire system with cycle accuracy. You can generate the sources and build the simulation using:
CONFIG=DebugConfig make -C $TOP/vsim sim  The build will take a few minutes.
Start the RTL simulation Next you can launch the RTL simulation and wait for the debug tool to connect:
$TOP/vsim/DebugConfig-sim +waitdebug  You will see the following output:</description>
    </item>
    
    <item>
      <title>Debug interface</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/interface/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/interface/</guid>
      <description>As mentioned in the overview the debug infrastructure abstracts from the physical transport interface with the generic interface logic project (glip). The following sketch shows the basic interface provided by glip and how it is used by the Open SoC Debug (osd) infrastructure.
 The basic interface abstraction of glip is a simple FIFO with 16-bit data and ready/valid flow control. The underlying glip backend implementation maps this interface to a protocol for different physical interfaces.</description>
    </item>
    
    <item>
      <title>Debug modules</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/debugmodules/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/debugmodules/</guid>
      <description>In the following we will give you a brief overview of the debug modules employed in this release. They are all at a relatively early stage of implementation, but contain the basic functionality we will extend over the next months. Please find more details about the modules at Open SoC Debug.
Basic Module Interface Each module has to provide a control and status interface via addresses that are accessed with register access packets.</description>
    </item>
    
    <item>
      <title>Debug software and methodology</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/softwaremethodology/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/softwaremethodology/</guid>
      <description>The debug software uses the glip library (glip API) to communicate with the target. On top of the basic access functions the Open SoC Debug library (libopensocdebug) provides the API to abstract from basic I/O functions. It covers low-level packetization, the proper handling of debug packets like register accesses and provides the convenience functions for the different types of modules. The following figure sketches the different API components.
 Debug tools can either use debug by linking to the library or by using the debug daemon, which allows different tools to use the debug system in parallel.</description>
    </item>
    
    <item>
      <title>Debug walkthrough</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/walkthrough/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/walkthrough/</guid>
      <description>In this main part of this tutorial you will learn about the debug features we have added to lowRISC. After introducing the debug enumeration and the general software usage with the RTL simulation, we will introduce the different features in example debug sessions. Finally, a full FPGA example is given based on the Nexys 4 board.</description>
    </item>
    
    <item>
      <title>Generic lowRISC setup</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/lowriscsetup/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/lowriscsetup/</guid>
      <description>This part is identical to the previous tutorial, simply perform those steps:
 Install Xilinx Vivado Install Verilator Compile and install RISC-V cross-compiler  </description>
    </item>
    
    <item>
      <title>Open SoC Debug Software</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/osdsoftware/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/osdsoftware/</guid>
      <description>Building the Open SoC Debug software is currently done manually, but it only involves a few steps.
Build glip software First you need to build and install the glip software to connect to the FPGA or simulation.
cd $TOP/opensocdebug/glip ./autogen.sh mkdir build; cd build ../configure --prefix=$OSD_ROOT --enable-tcp --enable-uart make &amp;amp;&amp;amp; make install  Build Open SoC Debug software Then the actual Open SoC Debug software is installed. You can leave out the python bindings, but you will loose a very convenient way to interact with the debug system.</description>
    </item>
    
    <item>
      <title>Overview of the debug infrastructure</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/overview/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/overview/</guid>
      <description>For this release we have set the goal to create the basic debug infrastructure for lowRISC. Before going into the details, we want to give you an overview about where we are heading with the debug infrastructure. Essentially, there are two methods to debug a processor:
 With run-control debugging the developer controls the processor core by setting breakpoints and stepping through instructions. This is what most people understand as debugging and gdb is probably the dominant tool for it.</description>
    </item>
    
    <item>
      <title>Prepare the environment</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/environment/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/environment/</guid>
      <description>We still recommend you work with a 64-bit Ubuntu (14.04 LTS). Everything except using the FPGA boards should also work out-of-box in a virtual machine.
For more details follow the instructions of the previous tutorial.
Ensure you have all the necessary packages installed:
sudo apt-get install autoconf automake autotools-dev curl \ libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison \ flex texinfo gperf libncurses5-dev libusb-1.0-0 libboost-dev \ swig git libtool libreadline-dev libelf-dev python-dev  Download the code The code is hosted in the lowRISC chip git repository.</description>
    </item>
    
    <item>
      <title>Release notes</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/release/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/release/</guid>
      <description>Release notes  Rocket-core (Chisel)  Add core trace and software trace modules in each Rocket core using Chisel black-boxes. Add Chisel debug network to Rocket-chip to connect the debug modules in cores. Add a trace CSR (swtrace) for software trace triggering. Merge the latest (05-2016) updates from RISC-V. Use the shared TileLink MEM network and reduce code discrepancy with the upstream Rocket to be minimal. Updated Configs.scala and LowRISCChip.</description>
    </item>
    
    <item>
      <title>Running on the FPGA</title>
      <link>https://www.lowrisc.org/docs/debug-v0.3/fpga/</link>
      <pubDate>Mon, 16 May 2016 12:00:00 +0000</pubDate>
      
      <guid>https://www.lowrisc.org/docs/debug-v0.3/fpga/</guid>
      <description>In this final step, we want to test the debug functionality on an FPGA board. The debug system will use the UART connection at 12 MBaud to communicate with the debug system.
Run the pre-built FPGA demo with a trace debugger The files you may need:
 nexys4ddr_fpga_debug.bit: The debug enabled FPGA bitstream boot.bin: Linux, Busybox and bootloader packaged in one image. nexys4ddr_bram_boot.riscv: A 1st stage bootloader to copy a program from SD to DDR RAM.</description>
    </item>
    
  </channel>
</rss>