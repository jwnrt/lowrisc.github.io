<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>Seventh RISC-V Workshop: Day Two &middot; lowRISC</title>
        <link rel="stylesheet" href="http://www.lowrisc.org/css/styles.combined.min.css" />
        <link rel="shortcut icon" href="http://www.lowrisc.org/favicon.ico" />
        <link rel="alternate" href="http://www.lowrisc.org/index.xml" type="application/rss+xml" title="lowRISC" />
        <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Source+Sans+Pro' type='text/css'>
        <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Exo+2' type='text/css'>
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-53520714-1', 'auto');
        ga('send', 'pageview');
      </script>
  </head>

  <body data-page="article">
<div class="header">
  <header data-component="menu">

    <section class="outer-container">
      <div class="image">
        <a href="http://www.lowrisc.org"><img src="http://www.lowrisc.org/img/logo.svg"></a>
      </div>

      <div class="menu">
        <ul>
          
          <li><a href="/"> Home </a></li>
          
          <li><a href="/about/"> About </a></li>
          
          <li><a href="/blog/"> Blog </a></li>
          
          <li><a href="/faq/"> FAQ </a></li>
          
          <li><a href="/docs/"> Docs </a></li>
          
          <li><a href="/community/"> Community </a></li>
          
        </ul>
      </div>
    </section>

  </header>
</div>









    <div class="article">
      <section class="outer-container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                
                    <header class="li-article-header">
                        <h1 class="li-article-title">Seventh RISC-V Workshop: Day Two</h1>
                        <span class="li-article-taxonomies">
                            

                            
                        </span>
                        
                        
                        <time class="li-article-date">Wednesday, November 29, 2017</time>
                        
                    </header>
                    <section>
                        

<p>The <a href="https://riscv.org/2017/10/7th-risc-v-workshop-agenda/">seventh RISC-V
workshop</a> is concluding
today at Western Digital in Milpitas. I&rsquo;ll be keeping a semi-live blog of
talks and announcements throughout the day.</p>

<h2 id="celerity-an-open-source-511-core-risc-v-tiered-accelerator-fabric-michael-taylor:b3d82df2c32815668820ecff5dcd0b9a">Celerity: An Open Source 511-core RISC-V Tiered Accelerator Fabric: Michael Taylor</h2>

<ul>
<li>Built in only 9 months.</li>
<li>Celerity is an accelerator-centric SoC with a tiered accelertor fabric.</li>
<li>Implemented in TSMC 16nm FFC. 25mm2 die area, 385M transistors</li>
<li>Why 511 RISC-V cores? 5 Linux-capable RV64G Rocket cores, 496-core RV32IM
mesh tiled area &ldquo;manycore&rdquo;, 10-core RV32IM mesh tiled array (low voltage).</li>
<li>Used a flip-chip package.</li>
<li>Of the 5 general purpose cores, 4 connect to the manycore array and 1
interfaces with the Binary Neural Network accelerator. Each core executes
independently within its own address space.</li>
<li>The BaseJump manycore architecture implements the RV32IM with a 5-stage
pipeline (full forwarded, in-order, single issue). It has 4KB+4KB instruction
and data scratchpads.</li>
<li>BaseJump Manycore Mesh Network: stores are routed based on the destination.
Simple XY-dimension routing.</li>
<li>Each Rocket core has its own RoCC interface connecting to one of the routers
in the mesh.</li>
<li>Uses a remote store programming model, which enables efficent
producer-consumer programming models. Offer extended instructions such as load
reserved (load value and set the reservation address),
load-on-broken-reservation (stall if the reserved address wasn&rsquo;t written by
other cores), and a consumer instruction to wait on a given address/valud. No
polling or interrupts are required.</li>
<li>Currently working on CUDA support.</li>
<li>Can fit 42 of the &ldquo;manycore&rdquo; cores per mm2 (vs 5 cores per mm2 for Rocket).</li>
<li>80% of the modules in the manycore are from the BaseJump library.</li>
<li>For the backend, hardened each core and replicated across the die.</li>
<li>Over 2/3rds of each manycore tile is memory.</li>
<li>For the BNN: each core in the manycore tier executes a remote-load-store
program to orchestrate sending weights to the specialization tier via a
hardware FIFO.</li>
<li>All code available at <a href="http://opencelerity.org">opencelerity.org</a>.</li>
<li>Want to build the &ldquo;DNA&rdquo; for open source ASICs. i.e. the basic components
needs for building a full system, spanneing RTL, IP cores, hardware emulation,
packaging, PCBs. See <a href="http://bjump.org">bjump.org</a>.</li>
<li>The BaseJump STL contains several hundred modules, all parameterised.</li>
</ul>

<h2 id="the-pulp-cores-a-set-of-open-source-ultra-low-power-risc-v-cores-for-internet-of-things-applications-pasquale-davide-schiavone:b3d82df2c32815668820ecff5dcd0b9a">The PULP Cores. A Set of Open-Source Ultra-Low-Power RISC-V Cores for Internet-of-Things Applications: Pasquale Davide Schiavone</h2>

<ul>
<li>PULP: Parallel Ultra-Low Power.</li>
<li>Designed for energy efficient hardware, e.g. near-sensor computation.</li>
<li>Have a set of 3 32-bit cores currently available, and working on a 64-bit
Linux-capable core.</li>
<li>RISCY core has a 4-stage pipeline. RV32IM[F]C. 40.7-69.3kGE. 3.19
CoreMark/MHz. Also has a number of extensions for packed SIMD, fixed point,
bit manipulation and hardware loops.</li>
<li>Zero-riscy has a 2-stage pipeline. RV32{I,E}[M]C. 11.6-18.9kGE. 2.44
CoreMark/MHz for RV32IMC and 0.91 for RV32EC. Optimized for area.</li>
<li>Arian core for Linux. 6-stage pipeline, RV64IMC, 185kGE, OoE execution and
in-order commit. 2.01 CoreMark/MHz.</li>
<li>Also have a set of software tools for PULP. Virtual platform, timing model.
Have 1MIPS simulation speed with timing accuracy between 20-20% of the target
hardware. Can also profile using kcachegrind.</li>
<li>How to verify these cores? Use constrained pseudo-random test generation in
a perturbated environment (random interrupts, stalls). The program generator
tries to maximise the code coverage, and the instruction simulation and RTL
model are compared.</li>
<li>Large number of companies using PULP/PULPino, e.g. Mentor, GreenWaves, NXP,
Micron, Microsemi, Cadence, ST, Google, Intel.</li>
<li>PULPissimo platform will be released Q12018, including the new microDMA
subsystem, new interrupt controller, new SDK etc. Taping out on GF22 soon.</li>
</ul>

<h2 id="boom-v2-an-open-source-out-of-order-risc-v-core-chris-celio:b3d82df2c32815668820ecff5dcd0b9a">BOOM v2. An open-source out-of-order RISC-V core: Chris Celio</h2>

<ul>
<li>Out of order superscalar implementing RV64g. Open source and written in
Chisel (~16kloc). Built on top of the rocket-chip ecosystem.</li>
<li>Advanced branch prediction. Loads can issue out-of-order with regard to
other loads and stores.</li>
<li>Parameterised, just a few lines to instantiate a 2-wide vs 4-wide BOOM.</li>
<li>BOOM has now been taped out! Taped out with a 2 person team in 4 months.</li>
<li>Total LoC for the SiFive U54 Rocket is 34kloc, vs 50kloc for BOOMv2, vs
1.3mloc (Verilog) for the UltraSPARC T2.</li>
<li>Boomv2 achieves 3.92 CoreMark/MHz (on the taped out BOOM), vs 3.71 for the
Cortex-A9.</li>
<li>BOOMv1 had a short pipeline inspired by R10K, 21264, Cortex-A9 and a unified
issue window.</li>
<li>BOOMv2: broke critical patches in the frontend. Put the BTB into SRAM. Also
moved hashing to its own stage.</li>
<li>The first place+route for register file resulted in huge area. Ended up
splitting the unified issue window, splitting the physical register file,
moving issue and register read into separate stages. Then implemented 2-stage
rename and 3-stage fetch.</li>
<li>Didn&rsquo;t have the resources to support a customised register file. A
synthesised register file resulted in huge congestion when routing the wires
from the flip-flops. Instead, black-boxed the register file and hand-wrote
some Verilog to instantiate specific flip-flops, muxes, and tri-state buffers.
Effectively hand-crafting their own bit block out of standard cells.</li>
<li>Saw about a 25% decrease in clock period, and 20% decrease in CoreMark/MHz
(due to increased load-use delay, fixable in the future). A lot of the work
was about fixing design rule check and geometry errors.</li>
<li>Physical design is a bottleneck for agile hardware development. RTL hacking
can be rapid, but it takes 2-3 hours for synthesis results and 8-24 hours for
P+R results. Additionally, manual intervention is often required and reports
are difficult to reason about.</li>
<li>Future directions for BOOM: further IPC and QoR improvements. Chris is
joining Esperanto Technologies, but is committed to maintain the BOOM
open-source repository.</li>
</ul>

<h2 id="rocket-engines-easy-custom-risc-v-cores-through-reuse-albert-magyar:b3d82df2c32815668820ecff5dcd0b9a">Rocket Engines. Easy, custom RISC-V cores through reuse: Albert Magyar</h2>

<ul>
<li>Why are there so many RISC-V cores (or: why not reuse rocket?). Often a
desire to match interface to be a &ldquo;drop in&rdquo; replacement for an existing core,
or want to tailor microarchitecture for custom extensions. Also, may find
Rocket is over-featured for the desired design point.</li>
<li>Less good reasons: not invented here, fear of Chisel.</li>
<li>There are a number of pitfalls for customized cores. e.g. introducing bugs
that have long since been avoided in Rocket.</li>
<li>Avoid reusing either too little or too much. Can reuse individual components
without using the top-level rocket-chip framework at all. Stitch together
individual components.</li>
<li>The &ldquo;big 3&rdquo; components: CSR file, decoder, RISC-V compressed (RVC) expander.</li>
<li>produced a new RISC-V core IP: &ldquo;BottleRocket&rdquo;. This has a classic
three-stage pipeline with a similar microarchitecture to Z-Scale and V-Scale.
Implements RV32IMC. The generator produces a single, easy to connect tile.</li>
<li>Supports debug, test, platform features: 0.13 debug spec, RVFI trace port,
external interrupt controller.</li>
<li>The open sourcing effort is underway, as is the integration with
riscv-formal.</li>
</ul>

<h2 id="a-perspective-on-the-role-of-open-source-ip-in-government-electronic-systems-linton-salmon:b3d82df2c32815668820ecff5dcd0b9a">A Perspective on the Role of Open-Source IP in Government Electronic Systems: Linton Salmon</h2>

<ul>
<li>The USD Department of Defence (DoD) needs custom SoCs. Custom ICs are
necessary to reach the target GOps/W. Computation requirements keep growing,
and real-time results are often required.</li>
<li>Current DoD architectures often use older technology nodes. Now moving
towards newer technology nodes (28nm and below).</li>
<li>Most of the cost for DoD custom SoCs is in design. Typically low volume (1k
parts). For small volume, find design costs 92%, fab NRE 7%, 1% production
costs.</li>
<li>Design cost are skyrocketing, increasingly dramtically with each technology
node. This is a huge problem for the low volume DoD designs.</li>
<li>Is open source IP the answer? The good news is that it can sharply reduce
resources, time and complexity or a DoD custom SoC design. Open source IP
permits increased use of unique DoD security approaches.</li>
<li>The not so good news: the open source community needs to develop a complete
infrastructure, needs to e more robust than it is today, the community needs a
model to fund infrastructure, and the support model must assure long term
support and continued development of open source IP.</li>
<li>Unique differentiation doesn&rsquo;t require development of the entire platform.
Want to put all the effort into the differentiating &ldquo;secret sauce&rdquo;.</li>
<li>Open source IP can address both the cost and availability of standard IP.
Open source IP macros are a critical first step, but integration IP is also
needed.</li>
<li>Open source IP enables specialisation. It provides the blocks and standard
infrastructure that can then be specialised.</li>
<li>Open source IP enables greater scrutiny by the DoD to ensure trust:
assurance it will only do as specified.</li>
<li>Hardware security requires the ability to modify the SoC, including 3d party
IP. Added security capabilities require a robust base and infrastructure.</li>
<li>RISC-V is an adaptable open standard. RISC-V processors can be built in a
way that can be trusted, and RISC-V can be used to enable increased security
(easy to add security extensions).</li>
<li>Need a full ecosystem infrastructure. Need to cover the entire
infrastructure, be robust, and easy to use.</li>
<li>DoD requires robustness and dependability of the open-source infrastructure.
Need complete verification, clear documentation, robustness validated through
to silicon implementation and test. This is not the role or the strength of
universities.

<ul>
<li>Savings requires the ability to depend on the open source IP.</li>
<li>Savings require the robustness of the IP across extended performance
ranges.</li>
</ul></li>
<li>Need a model to fund long-term infrastructure. This isn&rsquo;t the role of DARPA,
which funds projects rather than infrastructure. Much of the work is
difficult, but not exciting.</li>
<li>Need continual maintenance and improvement. Regular updates in terms of
performance, architecture, and fabrication technology.</li>
<li>DARPA programs driving open source IP: PERFECT, CRAFT, SSITH, POSH, IDEA.</li>
<li>CRAFT&rsquo;s goal is to enable more efficient custom IC design/fabrication to
enable high performance electronic solutions faster and with more flexibility.</li>
<li>SSITH: develop hardware design tools and IP to provide inherent security
against hardware vulnerabilities that are exploited through software in DoD
and commercial electronic systems.</li>
<li>IDEA: no &ldquo;human in the lop&rdquo; 24-hour layout generation for mixed signal ICs,
systems in package, and PCBs. Machine generated layout of electrical circuits
and systems.</li>
<li>POSH: an open source System on Chip design and IP ecosystem.</li>
</ul>

<h2 id="boosting-risc-v-isa-with-open-source-peripherals-an-soc-for-low-power-sensors-elkim-roa:b3d82df2c32815668820ecff5dcd0b9a">Boosting RISC-V ISA with Open Source Peripherals. An SoC for Low Power Sensors: Elkim Roa</h2>

<ul>
<li>Challenges: ready-to-plug IP and expensive licenses.</li>
<li>Been working with SiFive, providing IP blocks for the always-on domain.</li>
<li>The power management unit is a state machine running a microcode program
that triggers events as necessary.</li>
<li>Have implemented a wide range of IP: low-noise bandgap voltage reference,
LDO, biasing control, crystal low-frequency driver (XTAL-RF), RC Oscillator,
brownout detector, power-on reset, multi-resolution DAC and ADC, fully
synthesized true random number generator</li>
<li>Finally, integrated these always-on domain blocks in a TSMC180nm SoC using
Chisel at the top level.</li>
<li>Deliverables: releasing Verilog models, FSM Verilog RTL, documentation etc
through the freechips project. Schematics and layout available through the
SiFive Designshare program.</li>
<li>Taping out at the end of the year with SiFive, also want to include PHYs
like SATA, PCIe, USB next year. Hope to have a qualified range of IP in 2019.</li>
</ul>

<h2 id="picosoc-how-we-created-a-risc-v-based-asic-processor-using-a-full-open-source-foundry-targeted-rtl-to-gds-flow-and-how-you-can-too-tim-edwards:b3d82df2c32815668820ecff5dcd0b9a">PicoSoC: How we created a RISC-V based ASIC processor using a full open source foundry-targeted RTL-to-GDS flow, and how you can, too!: Tim Edwards</h2>

<ul>
<li>Created an ASIC version of a RISC-V core (PicoRV32) using an entirely open
source toolflow.</li>
<li>Targeting a 180nm process.</li>
<li>Open source synthesis toolchain: qflow is built using yosys/ABC, vesta,
graywolf, qrouter, magic, netgin, iverilog, ngspice.</li>
<li>PicoSoC includes a UART, SPI memory controller, scratchpad SRAM, and SPI
flash. Started the SoC targeting the open source Lattice ice40 flow, and add
padframe, power-on-reset, and generated SRAM to target ASIC.</li>
<li>Can perform cosimulation using iverilog and ngspice.</li>
<li>The PicoSoC core is 1mm2, with analog+SRAM+padframe, 2mm x 1.5mm.</li>
<li>Can reproduce this yourself using the efabless IP catalog and the efablass
CloudV-based design environment.</li>
<li>This is brought together in the efabless Open Galaxy Design Environment.</li>
</ul>

<h2 id="tilelink-a-free-and-open-source-high-performance-scalable-cache-coherent-fabric-designed-for-risc-v-wesley-terpstra:b3d82df2c32815668820ecff5dcd0b9a">TileLink. A free and open-source, high-performance scalable cache-coherent fabric designed for RISC-V: Wesley Terpstra</h2>

<ul>
<li>Requirements for a RISC-V bus: Open standard, easy to implemented,
cache-coherent block motion, multiple cache layers, reusable on and off-chip,
and high performance.</li>
<li>What about AMBA CHI/ACE?

<ul>
<li>&ldquo;Open standard? CHI is not open!&rdquo;. Can&rsquo;t get hold of the spec.</li>
<li>Not easy to implement: 10 probe message types, split control/data, narrow
bursts, &hellip;</li>
<li>No support for multiple cache layers.</li>
<li>Don&rsquo;t want to depend on a standard controlled by a RISC-V competitor</li>
</ul></li>
<li>TileLink was a clean slate project out of UC Berkeley. Featured a reduced
message protocol, assumed all connected hardware is trusted (do security
checking at the source, not in the network), and only supports power-of-2
block transfers.</li>
<li>TileLink is a master-slave point-to-point protocol. It&rsquo;s message based with
5 priorities. Out-order design with optional ordering. It&rsquo;s designed for
composability and deadlock freedom.</li>
<li>TileLink is open source and in production. Over 30 public modules including
cores, crossbars and adapters. Has a coherency manager similar to how ACE does
snooping. Also have bridges to AXI/AHB/APB</li>
<li>SiFive chips use a banked directory-based wormhole MESI L2$.</li>
<li>There are a few simplifying assumptions that make the protocol easier to
work with.

<ul>
<li>Require there are no agent loops, i.e. the bus participants (agents) form
a directed acyclic graph.</li>
<li>There are strict priorities. Messages have one of five priorities, and
lower priority messages never block higher priority messages. Responses have
a higher priority than requests.</li>
</ul></li>
<li>The on-chip TileLink wire protocol uses an independent channel for each
message priority. Messages are transmitted using multi-beat bursts. Use
ready-valid.</li>
</ul>

<h2 id="the-risc-v-vector-isa-roger-espasa:b3d82df2c32815668820ecff5dcd0b9a">The RISC-V Vector ISA: Roger Espasa</h2>

<ul>
<li>Why a vector extension? Reduce instruction bandwidth, reduce memory
bandwidth, lower energy, exposes DLP, masked execution, gather/scatter.
Scalable from small to large vector processing unit.</li>
<li>The vector ISA in a nutshell

<ul>
<li>32 vector registers. Eachcan hold either a scalar, vector, or a matrix
(shape). Each has an associated type (polymorphic encoding). There are a
variable number of registers (dynamically changeable).</li>
<li>Vector instruction semantics: all instructions are controlled by the
Vector Length (VL) register and can be executed under mask. Precise
exceptions are supported.</li>
</ul></li>
<li>Suppose you&rsquo;re adding two vector registers: <code>vadd v1, v2 -&gt; v0</code>. If the
vector length is less than maximum vector length, the remaining values must be
zeroed.</li>
<li>You could implement this how you like. Might choose to have a 2-lane
implementation (two FP adders), or 4-lane, or even 8-lane (SIMD, doing all in
one cycle). The number of lanes is transparent to the programmer and the same
code runs independent of the number of lanes.</li>
<li>Data inside a VREG could be a single scalar value, a vector, or a matrix
(optionally). The current shape is held in the per-vreg type field.

<ul>
<li>e.g. <code>vadd v1, v2.s -&gt; v0</code>. This adds the scalar value in v2 to every
value in vector v1.</li>
</ul></li>
<li>Masks are stored in regular vector registers (i.e. there will not be
separate mask registers). Masks are computed with compare operations, and
instructions use 2 bits of encoding to select masked execution.

<ul>
<li>e.g. <code>vadd v3, v4, v1.t -&gt; v5</code>.</li>
<li>v1 is the only register used as mask source.</li>
</ul></li>
<li>Vector load (unit stride). <code>vld 80(x3) -&gt; v5</code> will Vector Length elements.</li>
<li>Stride vector load. <code>vlds 80(x3, x9) -&gt; v5</code> performs a strided load.</li>
<li>Gather (indexed vector load). <code>vldx 80(x3, v2) -&gt; v5</code>. This uses a vector to
hold offsets. Repeated addresses are legal.</li>
<li>Vector store: <code>vst v5 -&gt; 80(x3)</code>. Note that zeroes won&rsquo;t be written when MVL
is larger than the vector length.</li>
<li>Scatter (indexed vector store). <code>vstx v5 -&gt; 80(x3, v2)</code>. Will probably have
two version of scatter, where one has guarantees about the ordering or stores
to repeated addresses.</li>
<li>Ordering:

<ul>
<li>From the point of view of a given hart, vector loads and stores happen in
order. You don&rsquo;t need any fences to see your own stores.</li>
<li>From the point of view of other harts, see the vector memory accesses as
if done by a scalar loop. This means they can be seen out-of-order by other
harts.</li>
</ul></li>
<li>Typed vector registers:

<ul>
<li>Each vector register has an associated type, which can be different for
different registers.</li>
<li>Types can be mixed in an instruction under certain rules.</li>
<li>Register types enable a &ldquo;polymorphic&rdquo; encoding an is also more scalable
for the future.</li>
</ul></li>
<li>vcvt is used for type and data conversions.</li>
<li>In some cases, types can be mixed in an instruction. e.g. adding <code>v1_i8, 
v2_i64 -&gt; v0_i64</code>. When any source is smaller than the destination, the source
is promoted to the destination size.</li>
<li>The size of the vector register file is not set by the ISA. It is configured
by writing to the vdcfg CSR. When doing this, the hardware computes the
maximum vector length. This configuration can be done in user mode.

<ul>
<li>One implementation choice is to always return the same MVL, regardless of
config. Alternatively, split storage across logical registers, perhaps
losing some space.</li>
</ul></li>
<li>E.g the hardware has 32 registers, 4 elements per vector, each 4 bytes = 512
bytes. If the user asks for 32 F32 registers, <code>MVL = 512B / (32 * 4) = 4</code>. If
the user asked for only 2 F32 registers, <code>MVL = 512B / (4+4) = 64</code>. But it
would be legal for the implementation to return something smaller, e.g. 4 as
in the previous example.</li>
<li>If the user asks for 2 F16 regs and 2 F32 registers, <code>MVL = 512B / (12B + 
4B) = 32</code>.</li>
<li>MVL is transparent to software, meaning code can be portable across
different number of lanes and different values of MVL.</li>
<li>Not covered today: exceptions, kernel save + restore, custom types, or
matrix shapes.</li>
<li>Goal is to be the best vector ISA ever! Expect LLVM and GCC to support it.</li>
<li>Current spec on GitHub is out-of-date.</li>
</ul>

<h2 id="security-task-group-update-and-risc-v-security-extension-richard-newell:b3d82df2c32815668820ecff5dcd0b9a">Security task group update and RISC-V security extension: Richard Newell</h2>

<ul>
<li>The security working group works in two main areas. Trusted execution /
isolation and cryptographic extensions. Recently had changes in direction for
trusted execution / isolation.</li>
<li>This talk will focus on the cryptographic extensions status. Hope to have a
written spec for the next workshop.</li>
<li>Want to rely heavily on the vector extensions for crypto.</li>
<li>Use vector functional units to perform modular and Galois Field arithmetic
needed for existing popular and promising post-quantum asymmetric cryptography
schemes. Also accelerate symmetric block ciphers and digest algorithms taking
advantage of the wide vector registers, using specialized VFUs (e.g. AES,
SHA-2).</li>
<li>Asymmetric crypto acceleration: use hardware support for modular arithmetic,
but software for group operations and point multiplication.</li>
<li>Propose vector element widths up to 4096, as well as an escape mechanism to
allow larger widths or non-power-of-two widths.</li>
<li>Intend to use just one major opcode for the cryptographic extension.</li>
<li>Richard presented a handy slide summarising the algorithms used in crypto
suites / libraries. Be sure to check it out once the slides become available!</li>
</ul>

<p><em>Alex Bradbury</em></p>

                    </section>
                </article>

        </div>
      </section>
    </div>
    


                

            <div id="disqus_thread"></div>
            <script type="text/javascript">
                 
                var disqus_shortname = 'lowrisc'; 
                var disqus_identifier = "/" + "blog/2017/11/seventh-risc-v-workshop-day-two";
                var disqus_title = "Seventh RISC-V Workshop: Day Two";
                var disqus_url = "http://www.lowrisc.org" + "blog/2017/11/seventh-risc-v-workshop-day-two";

                 
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </div>
            

        <footer>

          <section class="outer-container">

            <div>
              <div class="link-container">
              </div>
            </div>

            <p>
              Unless otherwise noted, content on this site is licensed under a Creative Commons Attribution ShareAlike 4.0 International License
            </p>

          </section>

        </footer>
    </body>
</html>


    </body>
</html>

