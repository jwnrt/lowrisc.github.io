<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on lowRISC</title>
    <link>http://www.lowrisc.org/blog/</link>
    <description>Recent content in Blogs on lowRISC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Nov 2017 15:16:45 +0000</lastBuildDate>
    <atom:link href="http://www.lowrisc.org/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Seventh RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-one</link>
      <pubDate>Tue, 28 Nov 2017 15:16:45 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2017/10/7th-risc-v-workshop-agenda/&#34;&gt;seventh RISC-V
workshop&lt;/a&gt; is going
on today and tomorrow at Western Digital in Milpitas. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-conor:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Introduction: Rick O&amp;rsquo;Conor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Workshop is sold out, 498 attendees registered representing 138 companies
and 35 universities.&lt;/li&gt;
&lt;li&gt;There will be 47 sessions squeezed into 12 and 24 minute increments, plus 26
poster / demo sessions.&lt;/li&gt;
&lt;li&gt;The 8th RISC-V workshop will be held on May 7th-10th at the Barcelona
Supercomputing Center and Universitat Politecnica de Catalunya.&lt;/li&gt;
&lt;li&gt;Rick gives a refresher on the structure of the RISC-V Foundation.&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation now has only 100 members (including individual
members).&lt;/li&gt;
&lt;li&gt;We&amp;rsquo;re on a &lt;em&gt;tight&lt;/em&gt; schedule today. No applause and no questions!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-state-of-the-union-krste-asanovic:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;RISC-V state of the union: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Krste gives a rapid overview of the RISC-V ISA.&lt;/li&gt;
&lt;li&gt;RISC-V aims to be simple, clean-slate, modulary, and stable.&lt;/li&gt;
&lt;li&gt;RISC-V started in May 2010. v1.0 of the ISA came in 2011, first Rocket
tapeout in 2012, first Linux port in 2013, v2.0 (frozen) IMAFD spec in 2014.
First commercial softcores and first commercial SoC in 2017.&lt;/li&gt;
&lt;li&gt;Large companies are adopting RISC-V for deeply embedded controllers in their
SoCs (&amp;ldquo;minion cores&amp;rdquo;), replacing home-grown and commercial cores.

&lt;ul&gt;
&lt;li&gt;[Editor&amp;rsquo;s note: pleasing to see the &amp;ldquo;minion core&amp;rdquo; name take off around the
wider RISC-V community!].&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Small and proprietary-ISA soft-core IP companies are switching to the RISC-V
standard to access a larger market. &amp;ldquo;If you&amp;rsquo;re a softcore IP provider, you
should have a RISC-V product in development&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;RISC-V has seen government adoption, e.g. India adopted it as a national
ISA. A recent security-focused DARPA project standardised on RISC-V. Israel
Innovation Authority are creating the GenPro platform around RISC-V.&lt;/li&gt;
&lt;li&gt;Many startups are choosing RISC-V for new products. &amp;ldquo;We haven&amp;rsquo;t had to tell
startups about RISC-V; they find out about it very quickly when shopping for
processor IP&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Commercial ecosystem providers: starting to see mainstream commercial
support. &amp;ldquo;Demand is driving supply in the commercial ecosystem&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;RISC-V in academic research: becoming the standard ISA for academic
research. There will be talks at the workshop about the Celerity 500 RISC-V
core SoC in 16nm FinFET, and FireSim which models 1024 quad-core RISC-V
servers in the cloud.

&lt;ul&gt;
&lt;li&gt;The CARRV RISC-V workshop at MICRO was even better attended than the
machine learning workshop.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Expect in a few years time that the vast majority of undergraduates will be
taught RISC-V at University.&lt;/li&gt;
&lt;li&gt;Racepoint Global have been hired for Foundation marketing.&lt;/li&gt;
&lt;li&gt;RISC-V Technical Roadmap for 2017:

&lt;ul&gt;
&lt;li&gt;Primary goal was to formally standardise the base ISA, resolve issues with
the memory model, debug, and stabilize the privileged architecture.&lt;/li&gt;
&lt;li&gt;Good progress has been made, but the spec hasn&amp;rsquo;t yet been ratified. One of
the issues is differentiating the base spec versus clarifications for
different &amp;ldquo;profiles&amp;rdquo;. There is no plan to change any instruction
specification versus 2.0.&lt;/li&gt;
&lt;li&gt;The Unix platform is stable as of the privileged 1.10 spec (i.e. no
backwards incompatible changes from now on).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ISA specifications and profiles

&lt;ul&gt;
&lt;li&gt;The original ISA specs mixed instruction specifications with platform
mandates. Now work is ongoing to separate instruction set specifications
from platform profiles.&lt;/li&gt;
&lt;li&gt;Instruction set specifications should be maximally reusable, while the
profiles should be as constrained as possible to simplify software
compatibility.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Single-letter names will run out some day, so a proposal has been made to
allow finer-grained naming of instruction sets to describe profiles. Use Zxxxx
to name standard instruction extensions (while Xyyyyy is used for non-standard
instruction extensions). See the isa-dev list for more information.&lt;/li&gt;
&lt;li&gt;Profiles for software compatibility. A software ABI/SBI defines a profile.
A software ABI/SBI defines a profile. Also need profiles M-mode-only
microcontrollers, and MU-mode microcontrollers, and for booting MSU platforms.
Aim for have first ready in Q12018.&lt;/li&gt;
&lt;li&gt;Memory model: the original was too weak for C11 and underspecified, but a
team of experts have come together over the past year to resolve the issues.
RVWMO is the base memory model and is weak, while RVTSO is an optional
extension providing a strong TSO memory model.&lt;/li&gt;
&lt;li&gt;Calling convention and ABI has been stabilized and documented.&lt;/li&gt;
&lt;li&gt;GCC and binutils have been upstreamed and released in GCC. LLVM upstream is
in progress.&lt;/li&gt;
&lt;li&gt;A number of other compilers and languages are now available. e.g. CompCert,
Go, Rust, OCaml, Jikes JVM, OpenJDK, &amp;hellip;&lt;/li&gt;
&lt;li&gt;The Linux port has been accepted upstream for the 4.15 release.&lt;br /&gt;
Additionally, the hypervisor spec has been released (designed to support
recursive virtualisation using an enhanced S mode).&lt;/li&gt;
&lt;li&gt;Run-halt debug going well, is being targeted by commercial vendors.&lt;/li&gt;
&lt;li&gt;2017 summary: All planned major technical decisions settled, some more work
on the ratification process is needed.&lt;/li&gt;
&lt;li&gt;Technical roadmap goals for 2018:

&lt;ul&gt;
&lt;li&gt;Complete ratification of base ISA and first profiles&lt;/li&gt;
&lt;li&gt;Base vector extensions proposed and ratified&lt;/li&gt;
&lt;li&gt;Hypervisor implemented, spec ratified&lt;/li&gt;
&lt;li&gt;Formal spec completed and released&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector: see the talk from Roger. Aim to be the Best Vector ISA Ever &amp;trade;.&lt;/li&gt;
&lt;li&gt;Security: really two separable efforts in the foundation: trusted execution
environments and cryptographic instruction extensions. Also a huge amount of
other work in the academic community.&lt;/li&gt;
&lt;li&gt;Interrupts: currently have fast local interrupts and global platform-level
interrupts. Also have requests for high end systems who want per-hart
message-signal interrupts (MSI) and from low-end embedded that want
pre-emptive vectored prioritized interrupts.&lt;/li&gt;
&lt;li&gt;Improving embedded compression: the C extension was designed for general
purpose computing with Unix binaries. People are seeing non-competitive RISC-V
code size on pure embedded workloads, like due to lack of byte/halfword memory
access? Considering an alternative C extension for RV32E systems.&lt;/li&gt;
&lt;li&gt;A new task group has been up for the &amp;lsquo;J&amp;rsquo; extension, exploring support for
dynamically translated languages. Looking at issues like integer overflow,
garbage collection, and instruction cache management.&lt;/li&gt;
&lt;li&gt;Summary

&lt;ul&gt;
&lt;li&gt;Very rapid development and adoption &amp;ldquo;by the time you decide to do a
project, support will be there&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Question: does the foundation have any formal ways of addressing IP
challenges? Answer: have been documenting prior art for the base ISA
instructions. Would be good to continue to expand this to cover reference
hardware implementations.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-hyupervisor-extension-andrew-waterman:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;RISC-V Hyupervisor Extension: Andrew Waterman&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Presenting work with extensive contributions from Paolo Bonzini and John
Hauser&lt;/li&gt;
&lt;li&gt;Goal is to virtualize S-mode to support running guest OSes under Type-1,
Type-2 and hybrid hypervisors. Also want to be high performance and to support
recursive virtualisation.&lt;/li&gt;
&lt;li&gt;The hypervisor extension adds new privileged modes. S-mode becomes HS-mode,
and we also add the Virtualised Supervisor (VS) and Virtualized User (VU)
modes.&lt;/li&gt;
&lt;li&gt;What needs to be virtualized? Supervisor architecture state (CSRs), memory,
I/O and interrupts.&lt;/li&gt;
&lt;li&gt;Additional copies of most supervisor CSrs are provisioned as background
supervisor CSRs, e.g. bsscratch, bsepc. In HS-mode, foreground CSRs contain
S-mode state and background CSRs contain inactive VS-mode state. These are
swapped in VS-mode.&lt;/li&gt;
&lt;li&gt;Use two-level address translation to virtualize memory. Original virtual
addresses are translated to guest physical addresses by the VS-level page
table, and then guest physical addresses are translated to machine physical
addresses by the HS-level page table.

&lt;ul&gt;
&lt;li&gt;Page table entry formats and page table layouts are the same as S-mode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Software and timer interrupts are easy to virtualise, as they&amp;rsquo;re already
exposed via the SBI. The two-level paging scheme can be used to trap MMIO
accesses.

&lt;ul&gt;
&lt;li&gt;Could avoid extra traps into the hypervisor with a virtualisation-aware
PLIC. This is considered a platform issues, outside of the scope of the
hypervisor ISA.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need an I/O MMU to initiated DMAs without trap into the hypervisor - also a
platform issue.&lt;/li&gt;
&lt;li&gt;The hypervisor extension is designed to be efficiently emulatable on M/S/U
systems with traps into M-mode.&lt;/li&gt;
&lt;li&gt;Specification v.01 is &lt;a href=&#34;https://github.com/riscv/riscv-isa-manual&#34;&gt;available on
GitHub&lt;/a&gt;. Hoping to implement in
Spike in Q1 2018.&lt;/li&gt;
&lt;li&gt;Want to see a silicon implementation prior to ratification.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-memory-consistency-model-status-update-dan-lustig:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;RISC-V memory consistency model status update: Dan Lustig&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The goal was to define the RISC-V memory consistency model (&amp;ldquo;specifies the
values that can be returned by loads&amp;rdquo;). Support a wide range of hardware
implementations, as well as Linux, C/C++ and lots of other critical software.&lt;/li&gt;
&lt;li&gt;The fundamental debate was about strong models (such as x86-TSO) vs weak
models (ARM, IBM Power). Strong models have stricter ordering rules, resulting
in something that&amp;rsquo;s simpler for programmers and for architects. Weak models
have more relaxed ordering rules, better performance/power/area and more
microarchitectural freedom.&lt;/li&gt;
&lt;li&gt;In order to find a compromise, defined RVTSO (strong) and RVWMO (weak).

&lt;ul&gt;
&lt;li&gt;Both are multi-copy atomic. This means cores are allowed to peek at stores
they have issues as long as they haven&amp;rsquo;t been observed by anyone else and is
much simpler to reason about than the Power and ARMv7 memory models.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The base RISC-V memory model is RVWMO (software must assume this if it wants
to be portable). It&amp;rsquo;s important to note that a hardware implementation meeting
the RVWMO specification could be more conservative (stronger). Additional have
the Ztso extension for RVTSO, which software might target.&lt;/li&gt;
&lt;li&gt;RVWMO and RVTSO differ in the degree of memory access reordering they permit
at the point of global visibility. In RVTSO, only store-to-load reordering can
be observed. In RVWMO, most memory accesses can be reordered freely unless
synchronized via .sq, .rl and/or fences.&lt;/li&gt;
&lt;li&gt;Dan has some handy diagrams that explain the RVWMO and RVTSO rules in a
nutshell, which you should be able to study once the slides become available.&lt;/li&gt;
&lt;li&gt;Software written for RVWMO will run on all RISC-V hardware (RVWMO and Ztso).
RVTSO-only software can be be written, but will only run on hardware
implementing Ztso. A flag in the ELF header will be used to ensure this.&lt;/li&gt;
&lt;li&gt;If you don&amp;rsquo;t want to think about memory models, just use the standard OSes
and toolchains. If you care about PPA or flexibility, use RVWMO. If you have
lots of legacy x86 code, use hardware implementing Ztso so that any software
will work. If you believe TSO is the future, use hardware with Ztso and emit
code with the TSO-only magic number.&lt;/li&gt;
&lt;li&gt;Fragmentation due to the presence of two memory models is an obvious risk.
Try to discourage software from targeting both, and encourage targeting RVWMO
wherever possible (redundant fences simple become no-ops).&lt;/li&gt;
&lt;li&gt;There have been a number of other ISA changes. ld.rl and sd.aq are
deprecated. ld.aqrl and sd.aqrl mean RCsc. Also clarified other subtleties.&lt;br /&gt;
May have future extensions to the fence instruction, and .aq/.rl variants for
byte and halfware-size loads/stores.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-enabling-a-new-era-of-open-data-centric-computing-architectures-martin-fink:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;RISC-V - Enabling a new era of open data-centric computing architectures: Martin Fink&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Most people think of Western Digital as a storage company, but actually
they&amp;rsquo;re a &lt;em&gt;data&lt;/em&gt; company.&lt;/li&gt;
&lt;li&gt;Big data is well known, but increasingly there are applications that require
&amp;ldquo;fast data&amp;rdquo; (immediate access to information).&lt;/li&gt;
&lt;li&gt;Big data applications have historically focused on general purpose compute.&lt;br /&gt;
But we need to be able to move beyond general purpose compute to meet new
application requirements.&lt;/li&gt;
&lt;li&gt;In a general purpose compute architecture, everything is centered around the
CPU rather than the data.&lt;/li&gt;
&lt;li&gt;Workload diversity demands diverse technologies and architectures, both for
&amp;ldquo;big data&amp;rdquo; and &amp;ldquo;fast data&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;There are a wide range of data-centric applications at the edge.&lt;/li&gt;
&lt;li&gt;RISC-V meets the needs of big data (move compute to data) and fast data
(memory centric compute). It enables purpose-built environments for big data
and fast data applications.&lt;/li&gt;
&lt;li&gt;Western Digital ships in excess of 1 billion cores per year, and expect to
double that. They are making a commitment to transition all of those 1 billion
cores towards RISC-V, across their whole product portfolio.&lt;/li&gt;
&lt;li&gt;Want to process the data where it lives, which RISC-V will help to enable.&lt;/li&gt;
&lt;li&gt;Represents a new style of development. In some cases, WD may develop their
own cores, in others may buy them, in others may partner with another company
to co-develop them.&lt;/li&gt;
&lt;li&gt;Western Digital will work to accelerate the RISC-V ecosystem:

&lt;ul&gt;
&lt;li&gt;Support the development of open source IP building blocks for the
community&lt;/li&gt;
&lt;li&gt;Actively partner and invest in the ecosystem&lt;/li&gt;
&lt;li&gt;Accelerate development of purpose-built processors for a broad range of
Big Data and Fast Data environments&lt;/li&gt;
&lt;li&gt;Multi-year transition of Western Digital devices, platforms and systems to
RISC-V purpose built architectures&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;First device from WD with a RISC-V core is likely to not ship until late
2019 to early 2020.&lt;/li&gt;
&lt;li&gt;Summary

&lt;ul&gt;
&lt;li&gt;Big Data and Fast Data need purpose-built environments&lt;/li&gt;
&lt;li&gt;Openness and ecosystem enable best-in-class innovation. The motivation is
enabling innovation, &lt;em&gt;not&lt;/em&gt; reducing cost.&lt;/li&gt;
&lt;li&gt;Western Digital brings the momentum of other 1B cores per year&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;industrial-strength-high-performan-risc-v-processors-for-energy-efficient-computing-dave-ditzel:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Industrial-strength high-performan RISC-V processors for energy-efficient computing: Dave Ditzel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coming out of &amp;ldquo;stealth mode&amp;rdquo; in this talk.&lt;/li&gt;
&lt;li&gt;Chris Celio is joining Esperanto, but will continue to maintain and support
BOOM. Esperanto will also be implementing even higher performance out-of-order
processors.&lt;/li&gt;
&lt;li&gt;Esperanto have been pursuing an implementing of the draft Vector ISA in
order to understand design trade-offs.&lt;/li&gt;
&lt;li&gt;RISC-V is off to a great start, but many in industry view RISC-V as a
curiosity or toy, only for low end. Repeatedly see questions about high-end
designs (in Verilog!), graphics, machine learning, or HPC applications.&lt;/li&gt;
&lt;li&gt;See Esperanto as complementing existing core vendors, &amp;ldquo;expanding RISC-V&amp;rsquo;s
piece of the pie&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Experanto is designing a high-performance RISC-V core comparable to the best
IP alternatives. It is designing an energy-efficient RISC-V core for high
TeraFLOP computing needs. The goal is to make RISC-V more compelling than the
other high-end alternatives.&lt;/li&gt;
&lt;li&gt;Will produce IP with human readable, synthesizable Verilog.&lt;/li&gt;
&lt;li&gt;Esperanto is building the highest TeraFLOPS per Watt machine learning
computing system, and it will be based on the RISC-V ISA&lt;/li&gt;
&lt;li&gt;ET-Maxion will be the highest single thread performance 64-bit RISC-V
processor. Starting from BOOM v2, but expect substantial changes. Optimized
for 7nm CMOS. This will be used in Esperanto&amp;rsquo;s products and made available as
a licensable core.&lt;/li&gt;
&lt;li&gt;Second core is the ET-Minion. This is intended to do all the heavy floating
point work, with very high floating point throughput and energy efficiency.
This will be a 64-bit RISC-V core with vector extensions, an in-order
pipeline, and extra instruction extensions for machine learning. Also have
multiple hardware threads of execution. Like the ET-Maxion, this will be used
in Esperanto products and available as a licensable core.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GSoC 2017 student report: core lockstep for minion cores</title>
      <link>http://www.lowrisc.org/blog/2017/10/gsoc-2017-student-report-core-lockstep-for-minion-cores</link>
      <pubDate>Thu, 05 Oct 2017 19:45:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/10/gsoc-2017-student-report-core-lockstep-for-minion-cores</guid>
      <description>&lt;p&gt;This year, as part of &lt;a href=&#34;https://developers.google.com/open-source/gsoc/&#34;&gt;Google Summer of
Code&lt;/a&gt; we had the pleasure of
working with Nikitas Chronas. Alongside his degree studies, Nikitas had become
involved with the &lt;a href=&#34;https://libre.space/&#34;&gt;Libre Space Foundation&lt;/a&gt; and developed
a strong interest in the possibility of open source hardware in
&lt;a href=&#34;https://en.wikipedia.org/wiki/CubeSat&#34;&gt;CubeSats&lt;/a&gt;. Fault tolerance of some
sort is important for harsh environments, and Nikitas worked to add fault
tolerance through the implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Lockstep_(computing)&#34;&gt;core
lockstep&lt;/a&gt; for the
PULPino-based minion
core subsystem. This was a really successful project which ended up
making contributions in areas beyond the core lockstep focus:
documentation, code quality, support for the Arty FPGA development board, and
even prototyping a code generation mechanism. See the &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2017/core-lockstep/&#34;&gt;detailed write-up&lt;/a&gt;
for all the details, and below for the all-important blinky lights demo.&lt;/p&gt;

&lt;iframe src=&#34;https://giphy.com/embed/26vIg6cZFMWvi6AbS&#34; width=&#34;480&#34; height=&#34;401&#34; frameBorder=&#34;0&#34; class=&#34;giphy-embed&#34; allowFullScreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Moving RISC-V LLVM forwards</title>
      <link>http://www.lowrisc.org/blog/2017/09/moving-risc-v-llvm-forwards</link>
      <pubDate>Wed, 27 Sep 2017 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/moving-risc-v-llvm-forwards</guid>
      <description>

&lt;p&gt;A high quality, upstream RISC-V backend for LLVM is perhaps the most
frequently requested missing piece of the RISC-V software ecosystem. This
blog post provides an update on the rapid progress we&amp;rsquo;ve been making towards
that goal, outlines next steps and upcoming events, and tries to better
explain the approach that we&amp;rsquo;re taking.
As always, you
can track status &lt;a href=&#34;http://www.lowrisc.org/llvm/status/&#34;&gt;here&lt;/a&gt; and find the code
&lt;a href=&#34;https://github.com/lowRISC/riscv-llvm&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;status:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Status&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been able to make substantial progress since the &lt;a href=&#34;http://lists.llvm.org/pipermail/llvm-dev/2017-August/116709.html&#34;&gt;last
update&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;rv32:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;RV32&lt;/h3&gt;

&lt;p&gt;100% of the GCC torture suite passes for RV32I at -O0, -O1, -O2, -O3, and -Os
(after masking gcc-only tests). MC-layer (assembler) support for RV32IMAFD has
now been implemented, as well as code generation for RV32IM.&lt;/p&gt;

&lt;h3 id=&#34;rv64:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;RV64&lt;/h3&gt;

&lt;p&gt;This is the biggest change versus my last update. LLVM recently gained support
for parameterising backends by register size, which allows code duplication to
be massively reduced for architectures like RISC-V. As planned, I&amp;rsquo;ve gone
ahead and implemented RV64I MC-layer and code generation support making use of
this feature. I&amp;rsquo;m happy to report that 100% of the GCC torture suite passes
for RV64I at O1, O2, O3 and Os (and there&amp;rsquo;s a single compilation failure at
O0). I&amp;rsquo;m very grateful for Krzysztof Parzyszek&amp;rsquo;s (QUIC) work on variable-sized
register classes, which has made it possible to parameterise the backend on
XLEN in this way. That LLVM feature was actually motivated by requirements of
the Hexagon architecture - I think this is a great example of how we can all
benefit by contributing upstream to projects, even across different ISAs.&lt;/p&gt;

&lt;h3 id=&#34;other-activities:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Other activities&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Community members Luís Marques and David Craven have been experimenting with
D and Rust support respectively.&lt;/li&gt;
&lt;li&gt;Andes Technology have started working to contribute to this effort, and are
putting together patches for compressed instruction set support. This is a
really positive move and I hope others will follow their lead.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-stats:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Development stats&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &amp;lsquo;reference&amp;rsquo; &lt;a href=&#34;https://github.com/lowRISC/riscv-llvm&#34;&gt;patch queue&lt;/a&gt; consists
of 48 patches, modifying 128 files and inserting over 11500 lines to the LLVM
and Clang codebases. Close to 50% of these lines are new tests.&lt;/li&gt;
&lt;li&gt;Other activities:

&lt;ul&gt;
&lt;li&gt;8 committed patches to LLVM in areas other than lib/Target/RISCV
(cleanups, support code, documentation improvements, bug fixes) with 5 more
making their way through the review process.&lt;/li&gt;
&lt;li&gt;2 GCC/binutils bugs reported&lt;/li&gt;
&lt;li&gt;RISC-V &lt;a href=&#34;https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md&#34;&gt;psABI
doc&lt;/a&gt;:
Authored 7 merged commits, 13 issues filed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;d like to thank &lt;a href=&#34;https://github.com/lowRISC/riscv-llvm#credits&#34;&gt;everyone&lt;/a&gt;
who has contributed code review, feedback, or suggestions so far, as well as
our industrial sponsor.&lt;/p&gt;

&lt;h2 id=&#34;approach-and-philosophy:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Approach and philosophy&lt;/h2&gt;

&lt;p&gt;As enthusiastic supporters of RISC-V, I think we all want to see a huge range
of RISC-V core implementations, making different trade-offs or targeting
different classes of applications. But we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want to see that variety in
the RISC-V ecosystem result in dozens of different vendor-specific compiler
toolchains and a fractured software ecosystem. Unfortunately most work on LLVM
for RISC-V has been invested in private/proprietary code bases or short-term
prototypes. The work described in this post has been performed out in the open
from the start, with a strong focus on code quality, testing, and on moving
development upstream as quickly as possible - i.e. a solution for the long term.&lt;/p&gt;

&lt;p&gt;My implementation approach has been to first work towards a cleanly designed
and well tested RV32I baseline compiler. Once the fundamentals are solid, it
is &lt;em&gt;significantly&lt;/em&gt; easier to add in new features, optimisations, or indeed
customisations for different RISC-V variants. This careful approach has
enabled the rapid progress of the past few weeks. I would summarise this
approach as:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ensuring (to the extent possible) that correct code is always generated for
a simple RV32I baseline&lt;/li&gt;
&lt;li&gt;Expand that baseline to support more RISC-V ISA variants (RV{32,64}IMA and
later FD)&lt;/li&gt;
&lt;li&gt;Push forwards on optimisations (generated code quality) and compiler
feature support. Part of this work is moving to larger scale test programs and
benchmarks in order to maintain confidence about the correctness of generated
code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This project is currently in the process of moving from point 2) to point 3)
on the list above. As it stands, you will benefit from LLVM&amp;rsquo;s many middle-end
optimisations, but the final code generation stage has seen little work
focused on the performance of generated code. With a high quality base now in
place, adding these optimisations can be done relatively easily.&lt;/p&gt;

&lt;p&gt;If you want to see first-class support for RISC-V in LLVM, now is the time to
get involved and help make it happen.&lt;/p&gt;

&lt;h2 id=&#34;roadmap-and-upcoming-events:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Roadmap and upcoming events&lt;/h2&gt;

&lt;p&gt;My aim is to have Clang and LLVM developed to serve as a competitive
alternative to GCC on RISC-V by the end of the calendar year. If the RISC-V
community works together, this is an achievable goal.&lt;/p&gt;

&lt;p&gt;My near-term goals are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Expand testing for RV64. There are rather few RV64 unit tests right now
because parameterising the backend by XLEN mostly &amp;ldquo;just worked&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Go through the implementation again (particularly recently added code) to
look for further cleanup or refactoring opportunities, then propose to merge
it upstream.&lt;/li&gt;
&lt;li&gt;Once I&amp;rsquo;m happy with the implementation approach for the most recently added
features, move the 5.0-based
&lt;a href=&#34;http://github.com/lowrisc/riscv-llvm-integration&#34;&gt;riscv-llvm-integration&lt;/a&gt;
tree forwards.&lt;/li&gt;
&lt;li&gt;Review patches from contributors such as Andes and help to support language
port efforts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Focus areas after that include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clang toolchain driver, MAFD codegen and ABI support&lt;/li&gt;
&lt;li&gt;Benchmarking vs RISC-V GCC and generated code quality improvements&lt;/li&gt;
&lt;li&gt;Documentation, expanded test cases, and improved compiler testing tooling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve mapped out a number of TODO items
&lt;a href=&#34;https://github.com/lowRISC/riscv-llvm/issues&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m pleased to report that my proposal for a RISC-V &amp;ldquo;birds of a feather&amp;rdquo;
session at the &lt;a href=&#34;http://llvm.org/devmtg/2017-10/#bof4&#34;&gt;upcoming LLVM Dev
Meeting&lt;/a&gt; (Oct 18th) was accepted. You
should definitely attend this event if you are an LLVM developer working on an
out-of-tree RISC-V backends or are looking to get involved (representatives
from several companies in that position are already confirmed as attending).
We&amp;rsquo;re also looking to run a longer working/hacking session the day before, at
a San Jose location. More details on both events will be circulated shortly.&lt;/p&gt;

&lt;h2 id=&#34;faq:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;do-you-care-about-performance-of-generated-code-and-code-size:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Do you care about performance of generated code and code size?&lt;/h3&gt;

&lt;p&gt;Like any compiler developer, of course. Starting with a solid and well tested
base is the best way of achieving those aims. We&amp;rsquo;re now in a position where we
can push forwards on these fronts, which will will soon become a primary focus
of this development effort.&lt;/p&gt;

&lt;h3 id=&#34;i-have-a-risc-v-llvm-fork-which-works-for-me-why-should-i-care-about-an-upstream-backend:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;I have a RISC-V LLVM fork which works for me, why should I care about an upstream backend?&lt;/h3&gt;

&lt;p&gt;This is ultimately a question about long-term maintenance and sharing the
support burden with others in the RISC-V ecosystem. By working together and
pooling our development efforts, we can unlock the benefits of the open source
approach. Contributing to this effort is almost definitely the right long-term
choice for your project. If you want to discuss how to contribute, please drop
me an email or come along to the upcoming birds of a feather session.&lt;/p&gt;

&lt;h3 id=&#34;what-is-the-difference-between-this-and-other-risc-v-llvm-efforts:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;What is the difference between this and other RISC-V LLVM efforts?&lt;/h3&gt;

&lt;p&gt;This effort is focused on high code quality, long term maintainability, and in
getting development merged in to upstream LLVM. Andes have recently released a
private development tree to the public. That tree was was based on an early
version of the lowRISC patchset, but diverged significantly in terms of
implementation approach. Andes are now working to submit patches to this
effort.&lt;/p&gt;

&lt;h3 id=&#34;who-are-you:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Who are you?&lt;/h3&gt;

&lt;p&gt;I (Alex Bradbury) am a co-founder and director of lowRISC CIC, where this
development work has been taking place. I have been developing LLVM backends
for the past seven years, and am now upstream code owner for the RISC-V
backend. If you&amp;rsquo;re interested in LLVM, you are hopefully already familiar with
my &lt;a href=&#34;http://llvmweekly.org/&#34;&gt;LLVM Weekly&lt;/a&gt; newsletter.&lt;/p&gt;

&lt;h3 id=&#34;why-is-lowrisc-interested-in-llvm:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Why is lowRISC interested in LLVM?&lt;/h3&gt;

&lt;p&gt;lowRISC is a not-for-profit created to push forward open source hardware by
developing a secure, open, and flexible SoC design. Enabling custom hardware
and derivative designs is about much more than shipping RTL with an open
source license - hardware is of little use without the software infrastructure
in place to support it. A high quality and easy to modify LLVM backend is
important for potential lowRISC adopters, but also benefits our own hardware
development efforts. Specifically, we will be building the software component
of our tagged memory mechanisms on top of LLVM. If our mission sounds
interesting to you, there&amp;rsquo;s good news - &lt;a href=&#34;http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality/&#34;&gt;we&amp;rsquo;re
hiring&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;who-do-i-contact-to-discuss-further-sponsoring-this-effort:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Who do I contact to discuss further sponsoring this effort?&lt;/h3&gt;

&lt;p&gt;If your company would like to see lowRISC&amp;rsquo;s work on RISC-V LLVM be sustained
or expanded through 2018, then contributing development time and/or
sponsorship is the best way to do this. Please contact asb@lowrisc.org to
discuss further.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC tagged memory OS enablement</title>
      <link>http://www.lowrisc.org/blog/2017/09/lowrisc-tagged-memory-os-enablement</link>
      <pubDate>Tue, 19 Sep 2017 14:45:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/lowrisc-tagged-memory-os-enablement</guid>
      <description>&lt;p&gt;This summer, we were fortunate enough to have Katherine Lim join the lowRISC
team at the University of Cambridge Computer Laboratory as an intern.
Katherine&amp;rsquo;s focus was on operating system and software enabled for lowRISC&amp;rsquo;s
tagged memory, building upon our
&lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;most recent milestone release&lt;/a&gt;.
As Katherine&amp;rsquo;s &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-os-enablement-internship-2017/&#34;&gt;detailed write-up&lt;/a&gt; demonstrates,
it&amp;rsquo;s been a very productive summer.&lt;/p&gt;

&lt;p&gt;The goal of this internship was to take the lowRISC hardware release, and
demonstrate kernel support and software support for the hardware tagged memory
primitives. This includes support for context-switch of the &lt;code&gt;tagctrl&lt;/code&gt; register
used to configure tag rules, maintaining tags in pages upon copy-on-write,
delivering tag exceptions to user space, loading tags from ELF binaries, and
more. It culminated in a demonstration that pulls these various pieces of work
together, showing how tagged memory can be used to mark valid branch targets.
Read the &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-os-enablement-internship-2017/&#34;&gt;report&lt;/a&gt; for full
details.&lt;/p&gt;

&lt;p&gt;We believe there is a rich design space in hardware support for tagged memory
and tag-based software policies. This operating system enablement work is an
important part of exploring that space, and in making it easier for other
groups to do the same.&lt;/p&gt;

&lt;p&gt;If working on problems like this sounds interesting to you, there&amp;rsquo;s good news
- &lt;a href=&#34;http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality&#34;&gt;&lt;strong&gt;we&amp;rsquo;re hiring&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury and Katherine Lim&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>We&#39;re hiring! Work on making open source hardware a reality</title>
      <link>http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality</link>
      <pubDate>Mon, 18 Sep 2017 08:15:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality</guid>
      <description>&lt;p&gt;We are looking for a talented hardware engineer to join the lowRISC team and
help make our vision for an open source, secure, and flexible SoC a reality.
&lt;a href=&#34;https://lowrisc.workable.com/j/DBAC61322F&#34;&gt;Apply now&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;lowRISC C.I.C. is a not-for-profit company that aims to demonstrate, promote
and support the use of open-source hardware. The lowRISC project was
established in 2014 with the aim of bringing the benefits of open-source to
the hardware world. It is working to do this by producing a high quality,
secure, open, and flexible System-on-Chip (SoC) platform. lowRISC C.I.C. also
provides hardware and software services to support the growing RISC-V
ecosystem. Our expertise includes the LLVM Compiler, hardware security
extensions and RISC-V tools, hardware and processor design.&lt;/p&gt;

&lt;p&gt;The successful candidate will be interested in computer architecture and
hardware design. The primary focus of the role will be the development of the
lowRISC SoC platform, which will involve work to evaluate and extend our
current design including our general-purpose tagged-memory system. lowRISC is
an ambitious project with a small core team, so you will be heavily involved
in the project&amp;rsquo;s development direction. This role will involve frequent work
with external contributors and collaborators. While much of the work will be
at the hardware level the post will offer experience of the full
hardware/software stack, higher-level simulation tools and architectural
design issues.&lt;/p&gt;

&lt;p&gt;Some practical experience of hardware design with a HDL such as
Verilog/SystemVerilog is essential, as is a good knowledge of the HW/SW stack.
Ideally, candidates will also have experience or demonstrated interest in some
of: SoC design, large-scale open source development, hardware or software
security, technical documentation, board support package development and
driver development. Industrial experience and higher degree levels are valued,
but we would be happy to consider an enthusiastic recent graduate with a
strong academic record.&lt;/p&gt;

&lt;p&gt;Informal enquires should be made to Alex Bradbury &lt;a href=&#34;mailto:asb@lowrisc.org&#34;&gt;asb@lowrisc.org&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building upstream RISC-V GCC&#43;binutils&#43;newlib: the quick and dirty way</title>
      <link>http://www.lowrisc.org/blog/2017/09/building-upstream-risc-v-gccbinutilsnewlib-the-quick-and-dirty-way</link>
      <pubDate>Tue, 05 Sep 2017 14:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/building-upstream-risc-v-gccbinutilsnewlib-the-quick-and-dirty-way</guid>
      <description>&lt;p&gt;There are a number of available options for building a RISC-V GCC toolchain.
You might use the build system from the
&lt;a href=&#34;https://github.com/riscv/riscv-tools&#34;&gt;riscv/riscv-tools repository&lt;/a&gt;, or
investigate toolchain generators such as
&lt;a href=&#34;http://crosstool-ng.github.io/&#34;&gt;crosstool-ng&lt;/a&gt;. However in the case of
riscv-tools, it&amp;rsquo;s not always clear how this corresponds to the code in the
relevant upstream projects. When investigating a potential bug, you often just
want to build the latest upstream code with as little fuss as possible. For
distribution purposes you&amp;rsquo;d probably want to perform a proper multi-stage
build, but for a quick test you might find the following recipe useful:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone --depth=1 git://gcc.gnu.org/git/gcc.git gcc
git clone --depth=1 git://sourceware.org/git/binutils-gdb.git
git clone --depth=1 git://sourceware.org/git/newlib-cygwin.git
mkdir combined
cd combined
ln -s ../newlib-cygwin/* .
ln --force -s ../binutils-gdb/* .
ln --force -s ../gcc/* .
mkdir build
cd build
../configure --target=riscv32-unknown-elf --enable-languages=c \
--disable-shared --disable-threads --disable-multilib --disable-gdb \
--disable-libssp --with-newlib \
--with-arch=rv32ima --with-abi=ilp32 --prefix=$(pwd)/built
make -j
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce a newlib toolchain targeting RV32IMA in the &lt;code&gt;built/&lt;/code&gt;
subdirectory. When files are duplicated in the newlib, binutils and gcc
repositories, the gcc version takes precedence.&lt;/p&gt;

&lt;p&gt;Major credit to everyone who worked on getting these toolchain
ports upstream (Kito Cheng, Palmer Dabbelt, and others).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC 0-4 milestone release</title>
      <link>http://www.lowrisc.org/blog/2017/06/lowrisc-0-4-milestone-release</link>
      <pubDate>Fri, 09 Jun 2017 12:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/06/lowrisc-0-4-milestone-release</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;lowRISC 0.4 milestone release&lt;/a&gt;
is now available. The various changes are best described in our &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;accompanying
documentation&lt;/a&gt;, but in summary this
release:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Moves forward our support for tagged memory by re-integrating the tag cache,
reducing overhead with a &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/tag_cache/&#34;&gt;hierarchical scheme&lt;/a&gt;.
This will significantly reduce caches misses caused by tagged memory accesses
where tags are distributed sparsely.&lt;/li&gt;
&lt;li&gt;Integrates support for specifying and configuring &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/tag_core/&#34;&gt;tag propagation and
exception behaviour&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;http://www.pulp-platform.org/&#34;&gt;PULPino&lt;/a&gt; based &amp;ldquo;minion core&amp;rdquo; has been
integrated, and is used to provide peripherals such as the SD card
interface, keyboard, and VGA tex display (when using the Nexys4 DDR FPGA
development board).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please report any issues &lt;a href=&#34;https://github.com/lowRISC/lowrisc-chip&#34;&gt;on our GitHub
repository&lt;/a&gt;, or discuss on our
&lt;a href=&#34;http://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;mailing list&lt;/a&gt;. As always, thank you to everyone who has contributed in any way - whether it&amp;rsquo;s advice and feedback, bug reports, code, or ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apply now for GSoC 2017</title>
      <link>http://www.lowrisc.org/blog/2017/03/apply-now-for-gsoc-2017</link>
      <pubDate>Mon, 27 Mar 2017 09:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/03/apply-now-for-gsoc-2017</guid>
      <description>&lt;p&gt;We are very grateful for being selected again to take part as a mentoring
organisation in the &lt;a href=&#34;https://summerofcode.withgoogle.com/&#34;&gt;Google Summer of
Code&lt;/a&gt;, now for the third year running.
If you are a student who would like to be paid to work on open source during
the summer, then take a look at &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2017-ideas/&#34;&gt;the lowRISC ideas
list&lt;/a&gt; and
&lt;a href=&#34;https://summerofcode.withgoogle.com/organizations/6271463900315648/&#34;&gt;apply&lt;/a&gt;.
The deadline for applications is 4pm UTC on April 3rd. We&amp;rsquo;re always very interested in
ideas suggested by students, and encourage you to share them &lt;a href=&#34;https://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;on our
discussion
list&lt;/a&gt;
for feedback before making a proposal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2017 NetFPGA Design Challenge</title>
      <link>http://www.lowrisc.org/blog/2017/02/2017-netfpga-design-challenge</link>
      <pubDate>Wed, 01 Feb 2017 14:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/02/2017-netfpga-design-challenge</guid>
      <description>&lt;p&gt;As most of you know, the majority of full-time development on lowRISC takes
place at the University of Cambridge Computer Laboratory. However, we&amp;rsquo;re far
from the only open source hardware activity at the University. Our colleagues
on the NetFPGA project have an open source design challenge that many readers
of this blog might be interested in. See the &lt;a href=&#34;http://www.cl.cam.ac.uk/research/srg/netfpga/challenge2017/&#34;&gt;design challenge
website&lt;/a&gt;, or read
below for more details:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;We are pleased to announce the 2017 NetFPGA Design Challenge!

NetFPGA platforms are used by the networked systems community for close to 
a decade. The platforms enable researchers and instructors to build 
high-speed, hardware-accelerated networking systems. The platforms can be used 
by researchers to prototype advanced services for next-generation networked 
systems. By using Field Programmable Gate Arrays (FPGAs), NetFPGA enables new 
types of packet routing circuits to be implemented and detailed measurements 
of network traffic to be obtained.

The NetFPGA 2017 contest is a design challenge. The design teams are to 
produce a working implementation employing any HW and SW design methodology 
and targeting the NetFPGA SUME platform. The deadline for submissions is April 
13th, 2017. The winners will be announced at the NetFPGA Developers Summit 
(Thursday 20th - Friday, 21st April, 2017 Cambridge, UK).

Challenge: Lowest Latency Switch

Low latency devices are being increasingly used across a large number of 
applications. Low latency solutions are few, and are rarely open source. The 
goal of this challenge is to provide a usable, high performance, open source 
alternative to use by universities and organizations who need the flexibility 
of open source.  The systems will be evaluated using OSNT, an Open Source 
Network Tester. Test benches will be available online, for users to experiment 
and independently evaluate their design. The competition is open to students 
of all levels (undergraduate and postgraduate), as well as to non students. 
There is no need to own a NetFPGA SUME platform to take part in the 
competition although, clearly, development and testing will be made easier if 
you have access to this platform.  

Team Prizes:
First place: £500
Best students project: £500

The winning projects and runner ups will be invited to present their work 
at the NetFPGA Developers Summit 2017.  All challenge participants are keenly 
encouraged to attend the NetFPGA Developers Summit and are entitled to a 
reduced registration rate.

The design challenge prizes are generously 
supported by IMC http://www.imc.nl/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC Q&#43;A</title>
      <link>http://www.lowrisc.org/blog/2016/12/lowrisc-qa</link>
      <pubDate>Fri, 09 Dec 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/12/lowrisc-qa</guid>
      <description>&lt;p&gt;Yesterday, lowRISC triggered a lot of discussion when someone submitted it to
Hacker News. The &lt;a href=&#34;https://news.ycombinator.com/item?id=13129076&#34;&gt;comment
thread&lt;/a&gt; became something of an
impromptu Q+A about our project direction and status. I thought it was worth
linking to it here and highlighting the discussion for a wider audience. If
you have any additional questions, then feel free to comment on this blog post
or else, as always, drop by our &lt;a href=&#34;http://www.lowrisc.org/community/&#34;&gt;mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fifth RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</link>
      <pubDate>Wed, 30 Nov 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;Today is the second day of the &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt;. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;opensoc-system-architect-farzad-fatollahi-fard:529e3037a37627249629f6513082618e&#34;&gt;OpenSoC System Architect: Farzad Fatollahi-Fard&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Current architectures are wasteful. Only a small fraction of chip area goes
to computation.&lt;/li&gt;
&lt;li&gt;For both GoblinCore and OpenHPC, ended up doing a lot of similar work to
achieve only a point design. Why not make a generator to avoid repeating the
same steps?&lt;/li&gt;
&lt;li&gt;OpenSoC System Architect is a combination of multiple tools to form a
well-defined development flow for complex RISC-V SoCs&lt;/li&gt;
&lt;li&gt;Supports standard RISC-V modules and custom extensions&lt;/li&gt;
&lt;li&gt;It outputs pre-verified Chisel for the SoC, synthesisable Verilog, and an
LLVM compiler for the SoC&lt;/li&gt;
&lt;li&gt;OpenSoC Fabric is an open-source, flexible, parameterised NoC generator. It
integrates with a wide variety of existing processors, as well as IO devices.&lt;/li&gt;
&lt;li&gt;Created a &amp;lsquo;CoreGen&amp;rsquo; IR. It allows automatic generation of HDL
representations of the SoC and build LLVM compiler backend implementations of
the SoC and any extensions.&lt;/li&gt;
&lt;li&gt;The IR is stored on disk in well-formed XML&lt;/li&gt;
&lt;li&gt;What&amp;rsquo;s next? Better support for Chisel3, more integration with existing
RISC-V tools and environment, frontend support to import existing
Chisel/Verilog/SystemVerilog. Also want CoreGen as a standalone IR&lt;/li&gt;
&lt;li&gt;See the website at &lt;a href=&#34;http://www.opensoc.community/&#34;&gt;http://www.opensoc.community/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;v-vector-extension-proposal-krste-asanovic:529e3037a37627249629f6513082618e&#34;&gt;V Vector Extension Proposal: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The vector extension intends to scale to all reasonable design points
(low-cost microcontroller or high-performance supercomputer). Support both
implicit auto-vectorisation and explicit SPMD&lt;/li&gt;
&lt;li&gt;Fit into the 32-bit encoding space, but be a base for future vector
extensions (e.g. crypto algorithms)&lt;/li&gt;
&lt;li&gt;The goal is to ratify a proposal 12 months from now, at the 7th workshop&lt;/li&gt;
&lt;li&gt;Cray-style vectors. &amp;ldquo;The right way&amp;rdquo; to exploit SIMD parallelism (as opposed
to the wrong way: GPUs or packed SIMD)&lt;/li&gt;
&lt;li&gt;V has an implementation-dependent vector length, meaning the same code runs
across different hardware without recompiling&lt;/li&gt;
&lt;li&gt;Each vector data register is configured with a width and type, or disabled.
There are also a configurable number of predicate registers. The maximum
vector length is a function of configuration, physical register storage, and
microarchitecture&lt;/li&gt;
&lt;li&gt;There are a number of mandatory supported types. e.g. an RV32IF system must
support X8, X16, X32, F16, F32. This means that scalar and vector half
precision floating point is a requirement if you are supporting floating
point.&lt;/li&gt;
&lt;li&gt;Each vector data register has a 4-bit field in a CSR (or multiple CSRs)
indicating its width, and another for its type.&lt;/li&gt;
&lt;li&gt;A vcfgd CSR alias is defined to allow faster writes of common vector data
configurations.&lt;/li&gt;
&lt;li&gt;Most user code would use the setvl instruction (which is actually setting a
CSR).&lt;/li&gt;
&lt;li&gt;A 16-bit+32-bit vector addition is pleasingly straight forward to specify in
assembly&lt;/li&gt;
&lt;li&gt;The architecture guarantees a minimum vector length of four regardless of
configuration. This means 1KB SRAM is required as a minimum&lt;/li&gt;
&lt;li&gt;A polymorphic instruction encoding is used. A single signed integer ADD
opcode works on different size inputs and outputs, depending on the
configuration of its inputs.&lt;/li&gt;
&lt;li&gt;There is support for vector atomics (e.g. vector fetch-and-add).&lt;/li&gt;
&lt;li&gt;For vector function calls (e.g. in auto-vectorised code) you want to make
vector calls to a function library with separate vector calling convention.
The caller has to allocate registers for the callee to use. It sets the
maximum width, allowing the callee to change the vctype as needed.&lt;/li&gt;
&lt;li&gt;For OpenCL/CUDA/SPMD, the configuration must be set at kernel launch to the
maximum width used anywhere in the call tree. It needs a general vector
function call capability with standard callee/caller save protocol&lt;/li&gt;
&lt;li&gt;Krste argues autovectorisation is much preferable to OpenCL or CUDA.&lt;/li&gt;
&lt;li&gt;Question: are you interested in smaller types (e.g. 4-bit). Answer: yes,
also interested in non-power-of-two types&lt;/li&gt;
&lt;li&gt;Question about the calling convention: the vector configuration state is
assumed to be caller-saved (including the vector register file), meaning the
scalar ABI is unmodified&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;towards-thousand-core-risc-v-shared-memory-systems-quan-nguyen:529e3037a37627249629f6513082618e&#34;&gt;Towards Thousand-Core RISC-V Shared Memory Systems: Quan Nguyen&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tardis is a new cache coherency protocol with greater scalability than
traditional directory coherence protocols.&lt;/li&gt;
&lt;li&gt;Tardis enforces consistency through timestamps, using logical leases&lt;/li&gt;
&lt;li&gt;It only tracks the exclusive owner of any particular cache line, requiring
only O(log N) storage. No broadcast invalidations, and timestamps aren&amp;rsquo;t tied
to the core count. There is no need for synchronised real-time clocks&lt;/li&gt;
&lt;li&gt;They are building a thousand-core prototype. Fit as many cores as possible
on a ZC706 FPGA, the connect in a 3D mesh to demonstrate at scale.&lt;/li&gt;
&lt;li&gt;Want to adapt Tardis for release consistency (rather than sequential
consistency), and Quan introduces how they have started to do this by
introducing new timestamps&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scrx-a-family-of-state-of-the-art-risc-v-synthesizable-cores-alexander-redkin:529e3037a37627249629f6513082618e&#34;&gt;SCRx: a family of state-of-the art RISC-V synthesizable cores: Alexander Redkin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Syntacore develops and licenses energy-efficient programmable cores
implementing the RISC-V ISA&lt;/li&gt;
&lt;li&gt;SCRx is the family of RISC-V implementations, now available for evaluation.
Each core can be extended and customised&lt;/li&gt;
&lt;li&gt;The smallest core, SCR1 is less than 20kgates in a basic untethered
configuration.&lt;/li&gt;
&lt;li&gt;SCR3 is a high-performance MCU core with up to 1.7DMIPS/MHz,
3.16CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;SCR4 is an MCU core with a high-performance FPU.&lt;/li&gt;
&lt;li&gt;SCR5 is an efficient mid-range embedded core. Full MMU with Linux support.
1GHz+ at 28nm, and 1.5+DMIPS/MHz per core.&lt;/li&gt;
&lt;li&gt;In the near term, want to support the latest privileged spec, adding trace
debug&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-hardware-software-co-design-with-risc-v-and-llvm-alex-bradbury:529e3037a37627249629f6513082618e&#34;&gt;Enabling hardware/software co-design with RISC-V and LLVM: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ll try and write something up for the blog later, but for now see my
slides
&lt;a href=&#34;https://speakerdeck.com/asb/software-co-design-with-risc-v-and-llvm&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vm-threads-an-alternative-model-for-virtual-machines-on-risc-vm-ron-minnich:529e3037a37627249629f6513082618e&#34;&gt;VM threads: an alternative model for virtual machines on RISC-VM: Ron Minnich&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Akaros is a research kernel originally from UC Berkeley.&lt;/li&gt;
&lt;li&gt;One core idea is the &amp;lsquo;multi core process&amp;rsquo;. This can be thought of as a set
of cores assigned an entity to a program.&lt;/li&gt;
&lt;li&gt;How do VMs fit into the Akaros model. A VM could be kind of a process.&lt;/li&gt;
&lt;li&gt;Look back at how we start a process. With the introduction of fork(), it
became easy and clean. But its introduction was controversial.&lt;/li&gt;
&lt;li&gt;Virtualisation on Linux/BSD/Unix requires a device (e.g. /dev/kvm). This
typically requires daemons who are used to interact with the device. In
Akaros, they did not want to recreate this.&lt;/li&gt;
&lt;li&gt;Can we just run a virtual machine like we do a thread? Introduce
&lt;code&gt;vthread_create&lt;/code&gt;. In Akaros, they have extended the thread model to include
virtual machine threads.&lt;/li&gt;
&lt;li&gt;Virtual machine threads (vthreads) can run Linux 4.8 (with 12 lines of
patches) and any code that shares the host ring 3 address space.&lt;/li&gt;
&lt;li&gt;Ring 3 and Ring V share and address space. Ring V is limited to 2^46 bytes,
while ring 3 is in a 2^47 byte address space.&lt;/li&gt;
&lt;li&gt;VM threads are integrated tightly into the kernel.&lt;/li&gt;
&lt;li&gt;On x86, Akaros pairs page table roots and page table pages. Page table pages
are 2x4k pages, with the process PTP in the lower 4K and the VM PTP in the
upper 4K. This makes it trivial to convert the two.&lt;/li&gt;
&lt;li&gt;It is significantly easier to write virtual machine managers in Akaros than
with the Linux model&lt;/li&gt;
&lt;li&gt;Akaros VMS are unlike any other VMs - threads can easily switch from being a
VM to being a host thread&lt;/li&gt;
&lt;li&gt;Kernels also look like threads, and spinning up a core looks like CPU
hotplug, accomplished by spinning up a vthread with IP at the 64-bit entry
point.&lt;/li&gt;
&lt;li&gt;There are a variety of implications and questions for RISC-V. How will
RISC-V handle nested paging? Can we avoid massive shadow state. How about
injecting interrupts without a vmexit?&lt;/li&gt;
&lt;li&gt;RISC-V is a chance to enable software innovation. We shouldn&amp;rsquo;t get locked
into &amp;ldquo;but we&amp;rsquo;ve always done it this way&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-low-power-smartphone-like-graphical-uis-for-risc-v-socs-michael-gielda:529e3037a37627249629f6513082618e&#34;&gt;Enabling low-power, smartphone-like graphical UIs for RISC-V SoCs: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Industrial/embedded UIs mostly look bad, but also have terribly user
experience&lt;/li&gt;
&lt;li&gt;For better UIs you mostly have to jump to Android or Linux - there&amp;rsquo;s a lack
of a middle ground&lt;/li&gt;
&lt;li&gt;For a previous project, produced a mobile-like GUI experience targeting an
MCU (STM32F4).&lt;/li&gt;
&lt;li&gt;With the right approach and tools, embedded GUIs can be beautiful too&lt;/li&gt;
&lt;li&gt;Their library was written in C++, with support for layers+formats. It has
its own font engine for kerning, anti-aliasing etc.&lt;/li&gt;
&lt;li&gt;The GUI is specified in XML and has its own minimal CSS&lt;/li&gt;
&lt;li&gt;Initially developed for eCos RTOS, and has an initial port for FreeRTOS. Can
also run on Linux.&lt;/li&gt;
&lt;li&gt;To prototype on a Zynq, implemented &amp;lsquo;micro blender&amp;rsquo; for blending, filling,
scaling etc. This was written in Chisel.&lt;/li&gt;
&lt;li&gt;Software-driven IP (silicon) is possible (and advisable!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-fast-instruction-set-simulator-for-risc-v-maxim-maslov:529e3037a37627249629f6513082618e&#34;&gt;A Fast Instruction Set Simulator for RISC-V: Maxim Maslov&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Esperanto is a stealth mode startup designing chips with RISC-V&lt;/li&gt;
&lt;li&gt;Wanted a fast RISC-V ISA simulator capable of running large applications
with minimal slowdown&lt;/li&gt;
&lt;li&gt;[Sorry folks, I had to duck out for a quick discussion - see the
&lt;a href=&#34;https://riscv.org/wp-content/uploads/2016/11/Wed1330-Fast-ISA-Simulator-for-RISC-V-Maslov-Esperanto.pdf&#34;&gt;slides&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-on-rv64g-benjamin-barenblat-and-michael-pratt:529e3037a37627249629f6513082618e&#34;&gt;Go on RV64G: Benjamin Barenblat and Michael Pratt&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why RISC-V? Better architecture, lower power, faster processing, easier
accelerator development. RISC-V is not going away&lt;/li&gt;
&lt;li&gt;The Go toolchain is complex. It has its own compiler, assembler (and
assembly language), and linker&lt;/li&gt;
&lt;li&gt;Getting close, but the runtime doesn&amp;rsquo;t quite compile. Hope to get it working
in the next few months.&lt;/li&gt;
&lt;li&gt;In the mean time, relatively simple go programs will compile and run&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s been mostly good. One pain-point has been that other Go ports don&amp;rsquo;t
target architectures with good conditional branches so had to emulate a flag
register. Another gripe is that loading 64-bit constants is a pain.&lt;/li&gt;
&lt;li&gt;Within a couple of months you should be able to compile real Go programs and
have them run on RISC-V&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-java-virtual-machine-for-risc-v-porting-the-jikes-rvm-martin-maas:529e3037a37627249629f6513082618e&#34;&gt;A Java Virtual Machine for RISC-V: Porting the Jikes RVM: Martin Maas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why do a JVM port? Both to run interesting applications, and for research
(e.g. hardware support for GCed languages)&lt;/li&gt;
&lt;li&gt;Porting OpenJDK/Hotspot for high performance, and the Jikes research VM for
academic work. This talk will focus on Jikes&lt;/li&gt;
&lt;li&gt;Jikes is itself written in Java&lt;/li&gt;
&lt;li&gt;JVMs have a large number of dependencies, so use the riscv-poky Linux
distribution generator to build a cross-compiled SDK and Linux image.&lt;/li&gt;
&lt;li&gt;While developing, add assertions everywhere to fail as early as possible&lt;/li&gt;
&lt;li&gt;Allowed the JIT to selectively emit instructions that dump trace output&lt;/li&gt;
&lt;li&gt;Booting JikesRVM is no easy task (there a &lt;em&gt;lot&lt;/em&gt; to do in order to get to
hello world)&lt;/li&gt;
&lt;li&gt;The non-optimising JIT compiler is mostly feature-complete. Passes &lt;sup&gt;65&lt;/sup&gt;&amp;frasl;&lt;sub&gt;68&lt;/sub&gt;
core tests. Targets RV64G&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;yopuzzle-an-open-v-development-platform-the-next-generation-elkim-roa:529e3037a37627249629f6513082618e&#34;&gt;YoPuzzle - an Open-V development platform the next generation: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lsquo;Open source&amp;rsquo; hardware. Raspberry Pi have sold 10 million boards, Arduino
sold 4.5 million boards (estimated). Some predictions indicate the market will
be worth over $1B within the next four years. These are based on commercial,
closed-source silicon&lt;/li&gt;
&lt;li&gt;OnChip UIS have developed an open 32-bit RISC-V based microcontroller. To
test the initial silicon, used chip-on-board&lt;/li&gt;
&lt;li&gt;RV32IM with a 3-stage pipeline. On TSMC 130nm GP. Die area 2.1mm x 2.1mm.&lt;/li&gt;
&lt;li&gt;The Microprocessor core is 0.12mm2, max freq 200MHz, core voltage 1.2V, core
dynamic power at 100MHz is 167uW/MHz (all peripheral clocks disabled)&lt;/li&gt;
&lt;li&gt;Arduino is mostly aimed at children in secondary schools. But what about
1-10 year olds?&lt;/li&gt;
&lt;li&gt;The Open-V microcontroller is up on crowdsupply, trying to raise funds to
produce 70k chips. Aim to do the second tapeout in Q1 2017, and produce puzzle
boards in Q2 2018.&lt;/li&gt;
&lt;li&gt;Elkim showed a neat live demo of the OnChip prototype along with a
browser-based programming environment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-risc-v-community-needs-peripheral-cores-elkim-roa:529e3037a37627249629f6513082618e&#34;&gt;The RISC-V community needs peripheral cores: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s good to have an open ISA, but what about the peripherals? e.g. PHYs,
bus IP, clocking circuitry, GPIO&lt;/li&gt;
&lt;li&gt;Open hardware would translate into quality (Linux) drivers&lt;/li&gt;
&lt;li&gt;There is no standard for GPIO. Want to have standard features (e.g.
switching speed, current drive) with a standard interface.&lt;/li&gt;
&lt;li&gt;The OnChip peripherals use AMBA buses&lt;/li&gt;
&lt;li&gt;Have a synthesizable CDR and PLL&lt;/li&gt;
&lt;li&gt;Are working on USB 3.1 gen 2, including the analog frontend.&lt;/li&gt;
&lt;li&gt;Have also been working on &amp;lsquo;chipscope&amp;rsquo; and offset correction&lt;/li&gt;
&lt;li&gt;Also working on LPDDR3. PCS is done, working on UVM IP&lt;/li&gt;
&lt;li&gt;Have a fully synthesised true-random noise generator, and working on NVRAM
on CMOS&lt;/li&gt;
&lt;li&gt;Suggestion: have a common listing of recommended IP (e.g. SPI, I2C, USB PHY
etc).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sub-microsecond-adaptive-voltage-scaling-in-a-28nm-risc-v-socs-ben-keller:529e3037a37627249629f6513082618e&#34;&gt;Sub-microsecond Adaptive Voltage Scaling in a 28nm RISC-V SoCs: Ben Keller&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Energy efficiency is critical in mobile applications&lt;/li&gt;
&lt;li&gt;Faster adaptive voltage scaling (AVS) saves more energy, especially for
bursty workloads&lt;/li&gt;
&lt;li&gt;State of the art SoCs cannot achieve fine-grained AVS because they use
off-chip regulators&lt;/li&gt;
&lt;li&gt;Integrate switch-cap regulators entirely on-die.&lt;/li&gt;
&lt;li&gt;Need adaptive clock generation&lt;/li&gt;
&lt;li&gt;The tape-out (~2 years ago) featured a version of Rocket. 16K I$, 32K D$, no
L2. It also feature a version of Hwacha&lt;/li&gt;
&lt;li&gt;Use a Z-scale core for the power management unit&lt;/li&gt;
&lt;li&gt;Taped out in 28nm FD-SOI. Die area 3.03mm2, with the core area 1.07mm2. 568K
standard cells&lt;/li&gt;
&lt;li&gt;Achieved 41.8 DP GFLOPS/W&lt;/li&gt;
&lt;li&gt;Body bias can be tuned to optimise efficiency for different workloads&lt;/li&gt;
&lt;li&gt;Integrated voltage regulation provided 82-89% system efficiency with
adaptive clocking&lt;/li&gt;
&lt;li&gt;Sub-microsecond adaptive voltage scaling provided up to 40% energy savings
with negligible performance loss&lt;/li&gt;
&lt;li&gt;Will now talk about the Berkeley interpretation of &amp;lsquo;agile&amp;rsquo; hardware
development. See &amp;ldquo;An Agile Approach to Building RISC-V Microprocessors&amp;rdquo;, MICRO
2016.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;Tape-ins&amp;rsquo; before &amp;lsquo;tape-outs&amp;rsquo;. Sprint to an initial design that is
feature-incomplete but functional, put it through the tools etc and shake out
the issues with the VLSI flow. Then iteratively add features.&lt;/li&gt;
&lt;li&gt;There have been 13 Berkeley RISC-V tapeouts in the last 5 years&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reprogrammable-redundancy-for-cache-vmin-reduction-in-a-28nm-risc-v-processor-brian-zimmer:529e3037a37627249629f6513082618e&#34;&gt;Reprogrammable Redundancy for Cache Vmin Reduction in a 28nm RISC-V Processor: Brian Zimmer&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Voltage scaling is effective in reducing energy consumption, and SRAM limits
the minimum operating voltage&lt;/li&gt;
&lt;li&gt;Instead of preventing errors, tolerate errors. A significant reduction in
the minimum voltage is possibly by tolerating 1000s of errors per MB of SRAM&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s been lots of work on the circuit-level for preventing errors, and at
the architectural level for tolerating errors&lt;/li&gt;
&lt;li&gt;Goal for the chip is to prove that SRAM Vmin can be effectively lowered by
tolerating a reasonable number of failing bitcells&lt;/li&gt;
&lt;li&gt;Built on Rocket and modified caches to add reprogrammable redundancy, ECC,
and BIST&lt;/li&gt;
&lt;li&gt;Implemented three techniques: dynamic column redundancy (avoid single-bit
errors in data SRAM), line disable (avoid &lt;code&gt;&amp;gt;=&lt;/code&gt; 2 bit errors in data SRAM), and
bit bypass (avoid all errors in tag SRAM)&lt;/li&gt;
&lt;li&gt;The system architecture involves three voltage domains. One for the uncore,
one for the core, and another for the L2 cache&lt;/li&gt;
&lt;li&gt;Reprogrammable redundancy is fairly straight-forward to add to the L1, but
ECC is more difficult. The ECC decoding is pipelined. If an error is detected,
the operation is recycled&lt;/li&gt;
&lt;li&gt;There is a 2% area overhead for the L2.&lt;/li&gt;
&lt;li&gt;Fabricated prototype is TSMC 28nm HPM.&lt;/li&gt;
&lt;li&gt;The proposed techniques achieve 25% average Vmin reduction (and 49% power
reduction) in the L2 for a 2% area overhead&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fifth RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-one</link>
      <pubDate>Tue, 29 Nov 2016 15:10:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt; is going
on today and tomorrow at the Google&amp;rsquo;s Quad Campus in Mountain View. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor-and-dom-rizzo:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Introduction: Rick O&amp;rsquo;Connor and Dom Rizzo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This workshop is yet again bigger than the last. 350+ attendees, 107 companies, 29 universities.&lt;/li&gt;
&lt;li&gt;The next workshop will be May 9th-10 in Shanghai, China.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-at-uc-san-diego-michael-taylor:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V at UC San Diego: Michael Taylor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Startup software stacks today look a light like an iceberg. A small amount
of &amp;lsquo;value-add&amp;rsquo; at the top, and a huge stack of open source underneath.&lt;/li&gt;
&lt;li&gt;How do we build the equivalent for hardware, the fully open source ASIC
stack?&lt;/li&gt;
&lt;li&gt;Need core IP, IO pads, standard cells, PLLs, high speed I/O, tools, BGA
packages, PCB design, firmware etc&lt;/li&gt;
&lt;li&gt;basejump aims to provide a &amp;lsquo;base class&amp;rsquo; for cheap hardware development. It
includes a standard library of components, an open source package design, and
an open source motherboard&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bsg_ip_cores&lt;/code&gt; aims to be like C++ STL, but for SystemVerilog&lt;/li&gt;
&lt;li&gt;BSG Ten is a recent design featuring 10 RISC-V cores that will be taping out
before the end of the year on a TSMC shuttle run.&lt;/li&gt;
&lt;li&gt;Aim for 100% of the design will be open, including design files for the
chip, PCB, BGA package, firmware.&lt;/li&gt;
&lt;li&gt;BSG Ten has its own 5-stage RV32IM pipeline&lt;/li&gt;
&lt;li&gt;Also working on &amp;lsquo;Certus&amp;rsquo;, a 16nm TSMC design featuring Rocket cores, a
neural network accelerator, and the BSG I/O infrastructure.&lt;/li&gt;
&lt;li&gt;Suggestion: RoCC interface should be wired to the toplevel of the Rocket
hierarchy&lt;/li&gt;
&lt;li&gt;Suggestion: The RISC-V community should have at least yearly stable
end-to-end releases of full RISC-V stacks (Linux to Verilog)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;updates-on-pulpino-florian-zaruba:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Updates on PULPino: Florian Zaruba&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Imperio is the first ASIC implementation of PULPino, done in UMC 65nm.&lt;br /&gt;
Speed: 500MHz.&lt;/li&gt;
&lt;li&gt;Area is 700kGE for the SoC and 40kGE for the core (1kGE = 1.44um2).&lt;/li&gt;
&lt;li&gt;What is PULP? Parallel Ultra Low Power (platform).&lt;/li&gt;
&lt;li&gt;PULPino is a much simplified version of PULP, featuring just 1 core, reduced
interconnect and simplified cache design.&lt;/li&gt;
&lt;li&gt;Have hardware loops, post-incrementing loads and stores and SIMD instruction
extensions.&lt;/li&gt;
&lt;li&gt;Over 20 companies and research institutes are using PULPino&lt;/li&gt;
&lt;li&gt;PULPinov2 is targeted for Q12017. This features support for Verilator
simulation, IP-XACT description, new peripherals (uDMA), new streamlined event
unit, SDK, updated compiler, and improved documentation and tutorials&lt;/li&gt;
&lt;li&gt;In the future, want to work on a secure PULPino capable of running SeL4&lt;/li&gt;
&lt;li&gt;Working on a 10kGE or less RISC-V core. Evaluating 1 and 3-stage pipeline
designs.&lt;/li&gt;
&lt;li&gt;Want to explore heterogeneous configurations, featuring FPU and
accelerators.&lt;/li&gt;
&lt;li&gt;Find out more at the &lt;a href=&#34;http://www.pulp-platform.org&#34;&gt;PULP website&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sifive-fe310-and-low-cost-hifive1-development-board-jack-kang:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;SiFive FE310 and low-cost HiFive1 development board: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SiFive is a fabless semiconductor company. Their business model is to build
custom SoC designs for their customers. Customers give specs and/or IP and
SiFive deliver packaged, tested chips.&lt;/li&gt;
&lt;li&gt;Although a commercial company who may offer commercial licenses, they are
committed to updating the open source rocket-chip implementation.&lt;/li&gt;
&lt;li&gt;RISC-V chips are here: the Freedom E310. This features an RV32IMAC core.&lt;br /&gt;
320MHz+ on TSMC180G. 1.61DMIPS/MHz, 16K L1 I$, 16K data scratchpad, multiple
power domains (supports low power standby). Comes in a 6x6 48-pin QFN&lt;/li&gt;
&lt;li&gt;Claim to be 9x more power efficient than Intel Quark and 2x more power
efficient than the ARM Cortex M0+.&lt;/li&gt;
&lt;li&gt;The HiFive 1 is an Arduino compatible board for this chip. The board design
and SDK is/will be open source. It&amp;rsquo;s now up on
&lt;a href=&#34;https://www.crowdsupply.com/sifive/hifive1&#34;&gt;CrowdSupply&lt;/a&gt;. $59 will get you
one board.&lt;/li&gt;
&lt;li&gt;The RTL for their implementations presented at the last RISC-V workshop are
now open source and &lt;a href=&#34;https://github.com/sifive/freedom&#34;&gt;up at GitHub&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Question: how much (ballpark) might it cost to get 100 prototype chips? For
Freedom Everywhere (microcontroller), looking at less than $100k depending on
the level of customisation needed.&lt;/li&gt;
&lt;li&gt;Question: what is the plan for getting the SiFive chips to be competitive
with the Cortex-M4 and other designs from ARM? Answer: this will come in time
with custom instructions, custom accelerators etc. The ability to customise
will result in better performance/watt than any off the shelf solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rapid-silicon-prototyping-and-production-for-risc-v-socs-neil-hand:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Rapid silicon prototyping and production for RISC-V SoCs: Neil Hand&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Need to support rapid evolution of IoT designs.&lt;/li&gt;
&lt;li&gt;IoT class designs can be achieved in tens of k$.&lt;/li&gt;
&lt;li&gt;All standards based, but not open source&lt;/li&gt;
&lt;li&gt;A standard cell ASIC is typically 52-78 weeks, compared to 10 weeks for a
Baysand Metal configurable standard cell.&lt;/li&gt;
&lt;li&gt;Codasip have 3-stage and 5-stage implementations RISC-V implementations. The
slide compares gate count and frequency vs Rocket and ZScale (watch out for
the slides to be posted, I didn&amp;rsquo;t get a chance to jot down the numbers)&lt;/li&gt;
&lt;li&gt;Have a story for easy extensibility, adding new instructions and having a
new SDK etc generated.&lt;/li&gt;
&lt;li&gt;UltraSoC provides debug&lt;/li&gt;
&lt;li&gt;LLVM is the glue that holds the solution together. They generate an LLVM
compiler based on their processor model and any customer-defined extensions.&lt;/li&gt;
&lt;li&gt;A test chip will be taping out very soon. Also exploring general
availability for a dev-board&lt;/li&gt;
&lt;li&gt;They are developing their own alternative to QEMU for their customers with a
non-copyleft license.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;extending-risc-v-for-application-specific-requirements-steve-cox:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Extending RISC-V for application-specific requirements: Steve Cox&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sometimes a pre-defined ISA is insufficient. May require an
application-optimised ISA. e.g. the Google TPU&lt;/li&gt;
&lt;li&gt;ASIP designer is a tool for automating ASIP design. The process can start
with a pre-existing example model, e..g RISC-V&lt;/li&gt;
&lt;li&gt;ASIP designer has been used in more than 250 unique SoC products&lt;/li&gt;
&lt;li&gt;The speaker gives an example of a header compression accelerator. Start with
a simple 3-stage RV32IM core. This is 24.5k gates on TSMC 28HPM at 500MHz and
32GPRs.&lt;/li&gt;
&lt;li&gt;First, consider instruction level parallelism. e.g. switching to a 2-slot
VLIW. This reduced cycle could by 21% and increased gate count by 31%.&lt;/li&gt;
&lt;li&gt;Next, try adding application-specific instructions. This reduced the code
size by 56%, cycle count by 67%, and added 9% to the gate count (compared to
the original baseline).&lt;/li&gt;
&lt;li&gt;Next, try adding a compare immediate and branch instruction. This reduces
code size by 8% and cycle count by 18% vs the previous result.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-memory-model-for-risc-v-muralidaran-vijayaraghavan:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;A memory model for RISC-V: Muralidaran Vijayaraghavan&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why not SC/TSO? Simple implementations have low performance.&lt;/li&gt;
&lt;li&gt;Why not the POWER/ARM models? Expose too many microarchitectural details and
their axiomatic models are too complex&lt;/li&gt;
&lt;li&gt;Why not RMO? The dependency requirements are too strict&lt;/li&gt;
&lt;li&gt;Want a simple specification with the inclusion of sufficient fences to force
sequential consistency behaviour when necessary&lt;/li&gt;
&lt;li&gt;Which is why they&amp;rsquo;ve introduced WMM: which has a simple operational
specification like SC, TSO.&lt;/li&gt;
&lt;li&gt;WMM introduces the conceptual device of an invalidation buffer. This holds
stale values that may be read by a future load.&lt;/li&gt;
&lt;li&gt;WMM has reconcile fences (clears the invalidation buffer) and commit fences
(flushes the store buffer).&lt;/li&gt;
&lt;li&gt;All instructions are committed in order, so stores cannot overtake loads.
This prevents &amp;lsquo;out of thin air&amp;rsquo; generation of values&lt;/li&gt;
&lt;li&gt;A write -back coherent cache hierarchy is typically global store atomic. SMT
cores with L1 write-through caches aren&amp;rsquo;t, so don&amp;rsquo;t do it.&lt;/li&gt;
&lt;li&gt;Mapping C++11 atomic operations to WMM is straight forward&lt;/li&gt;
&lt;li&gt;Question: what is the difference to the programmer vs TSO? Answer: you would
have to put a reconcile fence whenever you require load/load ordering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-memory-consistency-model-for-risc-v-caroline-trippel:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;A Memory Consistency Model for RISC-V: Caroline Trippel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Princeton have been working on memory consistency model verification. This
resulted in PipeCheck and CCICheck. Then implemented ArMOR, which worked to
more precisely define memory models. COATCheck looks at how e.g. instructions
that are executed as a result of page table walks interact with the memory
model. Finally, TriCheck helps to verify the lowering of e.g. C++11 atomic
constructs to the ISA level, as well as checking the ISA memory model and
hardware memory model.&lt;/li&gt;
&lt;li&gt;Have identified and characterised flaws in the current RISC-V memory model
specification (ASPLOS&amp;rsquo;17).&lt;/li&gt;
&lt;li&gt;Two broad categories of memory model relaxation. Preserved program order
(defines program orderings that hardware must preserve by default) and store
atomicity (defines the order in which stores become visible to cores).&lt;/li&gt;
&lt;li&gt;Propose tighter preserved program order and non-multi-copy store atomicity.&lt;/li&gt;
&lt;li&gt;Why allow non-multiple-copy atomic stores? Commercial ISAs e.g. ARM, Power
allow this, and RISC-V is intended to be integrated with other vendor ISAs on
a shared memory system.&lt;/li&gt;
&lt;li&gt;Want preserved program order to require same address read-read ordering&lt;/li&gt;
&lt;li&gt;Want PPO to maintain order between dependent instructions&lt;/li&gt;
&lt;li&gt;TriCheck compares high level language outcomes to ISA-level outcomes for a
spectrum of legal ISA microarchitectures&lt;/li&gt;
&lt;li&gt;The currently document RISC-V memory model lacks cumulative fences, which
are needed for C/C++ acquire/release synchronisation&lt;/li&gt;
&lt;li&gt;They have formulated an english language diff of the current spec with
proposed changes, but are also working on a formal model.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trust-transparency-and-simplicity-eric-grosse:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Trust, transparency and simplicity: Eric Grosse&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Know your adversary. Many of them might sometimes be your partner as well as
your adversary (e.g. state actors). Notably, seems to be fairly little in the
way of advanced corporate espionage from other companies.&lt;/li&gt;
&lt;li&gt;Fix 1: secure communications. SSL, PGP etc&lt;/li&gt;
&lt;li&gt;Fix 2: authentication. e.g. two-step authentication, hardware security
devices&lt;/li&gt;
&lt;li&gt;Fix 3: stay up to date with patches&lt;/li&gt;
&lt;li&gt;The disclosure process in the hardware community is dramatically different
than software. e.g. rowhammer was known to some hardware vendors well before
the public disclosure.&lt;/li&gt;
&lt;li&gt;Long standing practitioners&amp;rsquo; wisdom: &amp;ldquo;Complexity is the enemy of security&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Modern systems aren&amp;rsquo;t just incredibly complex, they&amp;rsquo;re also largely
undocumented.&lt;/li&gt;
&lt;li&gt;A paranoid&amp;rsquo;s choice of CPU? x86 with Qubes-OS on a NUC kit. Or Coreboot,
u-root on Asus KGPE-D16 motherboard&lt;/li&gt;
&lt;li&gt;For RISC-V, you have the critical advantage of openness - be sure to keep
it. Please resist adding features lightly, or else consider removing others in
compensation. Also consider a CHERI security extension, or tagged memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-foundation-update-rick-o-connor:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Foundation update: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Rick gives another overview of the RISC-V Foundation, and reiterates that
RISC-V is not an open source processor core but an open ISA specification. The
Foundation will encourage both open source and proprietary implementations&lt;/li&gt;
&lt;li&gt;Every year at least two RISC-V Foundation board seats will be up for
election.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s likely the end of year workshop each year will be in Silicon Valley,
and the Spring/Summer workshop will move locations around the year&lt;/li&gt;
&lt;li&gt;The board of directors was formed in Q2 2016, and the technical and
marketing committees were formed in Q3 2016.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-marketing-committee-update-arun-thomas:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Marketing Committee update: Arun Thomas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The marketing committee mission: grow RISC-V mindshare and grow the RISC-V
community&lt;/li&gt;
&lt;li&gt;Activities include organising RISC-V workshops and tutorials, and RISC-V
participation at industry events&lt;/li&gt;
&lt;li&gt;Want to help create RISC-V educational materials for industry practitioners,
researchers, and university students&lt;/li&gt;
&lt;li&gt;The marketing committee has several task groups: RISC-V workshops, outreach,
RISC-V content (creating riscv.org content and educational and marketing
materials), and member content (promoting content from RISC-V Foundation
members)&lt;/li&gt;
&lt;li&gt;David Patterson announces both of his textbooks will have RISC-V editions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-technical-committee-update-yunsup-lee:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Technical Committee update: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Immediate goals:

&lt;ul&gt;
&lt;li&gt;Maintain a roadmap of the RISC-V ISA&lt;/li&gt;
&lt;li&gt;Provide and maintain a golden simulator for the RISC-V ISA&lt;/li&gt;
&lt;li&gt;Provide and maintain a set of verification/validation tests to ensure
conformance&lt;/li&gt;
&lt;li&gt;To upstream software development tools (compiler, debugger etc)&lt;/li&gt;
&lt;li&gt;To maintain and update a list of hardware implementations of the
architecture&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Longer term goals

&lt;ul&gt;
&lt;li&gt;Establish processes to define and standardise future ISA extensions&lt;/li&gt;
&lt;li&gt;Provide guidelines for platform integration&lt;/li&gt;
&lt;li&gt;Set up program committees for future RISC-V workshops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Task groups: opcode space management, privileged ISA specification, formal
specification, debug specification, security, vector extensions, software
toolchain&lt;/li&gt;
&lt;li&gt;By Feb, debug spec will be ratified by the foundation, calling convention
fixed and documented, ELF format fixed and documented, priv-1.10.0&lt;/li&gt;
&lt;li&gt;By November, ratify vector extension&lt;/li&gt;
&lt;li&gt;Formal specification task group: Formal models written in L3, BSV and in Coq&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;free-chips-project-yunsup-lee:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Free Chips Project: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A plan to launch a not-for-profit for hosting open-source RISC-V
implementations, tools, and code&lt;/li&gt;
&lt;li&gt;SiFive loves open source, believes it is essential to their mission.&lt;/li&gt;
&lt;li&gt;The rocket-chip generator has had almost 4000 commits. 40% of all commits so
far come from SiFive&lt;/li&gt;
&lt;li&gt;SiFive contributions to the rocket-chip repository are made under the Apache
v2 license.&lt;/li&gt;
&lt;li&gt;SiFive added RV32I+M/A/F support, compressed support, blocking data cache,
and data SRAM options&lt;/li&gt;
&lt;li&gt;SiFive will publish a TileLink specification&lt;/li&gt;
&lt;li&gt;SiFive recently implemented a library &amp;lsquo;Diplomacy&amp;rsquo; for parameter negotiation.
Also added multi-clock support, clock crossings, and asynchronous reset flops&lt;/li&gt;
&lt;li&gt;The SiFive blocks repository contains low-speed peripherals like SPI, UART,
PWM, GPIO, PMU. These are written in Chisel with TileLink interfaces. It also
includes wrappers for high-speed Xilinx FPGA peripherals&lt;/li&gt;
&lt;li&gt;The SiFive Freedom repository has submodules for rocket-chip and
sifive-blocks and top-level SoC integration glue code&lt;/li&gt;
&lt;li&gt;The Free Chips project has a mission to be a home for open-source codebases
to enable faster, better, cheaper chips. It will sustain and evolve
open-source software tools and HDL code for SoC design. It will ensure free
and open contributions are available to all of the SoC design community. It
will manage publicly accessible, online repositories of source code,
documentation and issues&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;128-bit-addressing-in-risc-v-and-security-steve-wallach:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;128-bit addressing in RISC-V and security: Steve Wallach&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Aim for programming generality. Might have to recompile, but don&amp;rsquo;t want to
have to restructure your software.&lt;/li&gt;
&lt;li&gt;Computer virtual addresses span to local disk only, while other identifiers
such as MACs, URLs, IPv6 are globally unique. What if one unified name
structure could be developed?&lt;/li&gt;
&lt;li&gt;RV128I strawman. 64-bits are used for an object ID, and the other 64 bits
used for a byte offset.&lt;/li&gt;
&lt;li&gt;The object ID is a software or hardware structure considered to be worthy of
a distinct name&lt;/li&gt;
&lt;li&gt;Protection and memory management are independent&lt;/li&gt;
&lt;li&gt;The machine that is simplest to program wins. User cycles are more important
than CPU cycles&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-challenges-of-securing-and-authenticating-embedded-devices-derek-atkins:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;The challenges of securing and authenticating embedded devices: Derek Atkins&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why not just use symmetric encryption e.g. AES to secure your devices? It&amp;rsquo;s
hard to deploy and it doesn&amp;rsquo;t scale (either have one key for many devices or a
database of a huge number of keys)&lt;/li&gt;
&lt;li&gt;Why do people think public key won&amp;rsquo;t work? They think it&amp;rsquo;s too big, too
slow, or too power hungry.&lt;/li&gt;
&lt;li&gt;Many of these beliefs are true, e.g. ECC execution time on Cortex-M ARM
cores is 233-1089ms. Implementations range in 8-30KB of ROM and require
800-3000B of RAM. Hardware implementations are faster, but take a lot of
gates. RSA and Diffie-Hellman are larger and take longer&lt;/li&gt;
&lt;li&gt;Fundamentally these overheads are there because a large number of 4086 bit
numbers are multiplied&lt;/li&gt;
&lt;li&gt;Group theoretic cryptography (GTC) offers a potential answer. Complexity
scales linearly with security instead of quadratically like RSA, ECC etc&lt;/li&gt;
&lt;li&gt;GTC can work with just 6-8 bit math&lt;/li&gt;
&lt;li&gt;The Ironwood Key Agreement Protocol enables two endpoints to generated a
shared secret over an open channel. The Walnut digital signature algorithm
allows one device to generate a document that is verified by another.&lt;/li&gt;
&lt;li&gt;When comparing WalnutDSA on a Rocket core, it compared very favourable to
microECC. 4.9ms run-time vs 2110ms (458ms with multiply/divide).&lt;/li&gt;
&lt;li&gt;WaltnutDSA written in RISC-V assembly achieved a 3.0ms run time&lt;/li&gt;
&lt;li&gt;The C implementation currently runs faster on the ARM Cortex-M3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-with-sanctum-enclaves-ilia-lebedev:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V with Sanctum Enclaves: Ilia Lebedev&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Today privilege implies trust (e.g. a hypervisor is privileged and so must
be trusted). Sanctum decouples hardware protection from trust&lt;/li&gt;
&lt;li&gt;Sanctum uses hardware-assisted isolation, offering strong privacy and
integrity with low overhead&lt;/li&gt;
&lt;li&gt;In remote software attestation, a trusted remote piece of hardware might
measure (hash) and sign the software that is running. The remote user can then
decides where to trust the certificate or not. Claim that prior work included
too much software in their attestation&lt;/li&gt;
&lt;li&gt;Intel recently introduced SGX, which allowed a process to be placed in an
enclave. It aims to protect privacy and integrity of an enclave against a
privileged software adversary. It also protects against some physical attacks,
or instance by encrypting DRAM contents&lt;/li&gt;
&lt;li&gt;There have been a number of side channel attacks demonstrated against SGX.&lt;br /&gt;
e.g. dirty bits on page tables, or cache timing attacks&lt;/li&gt;
&lt;li&gt;Sanctum aims to protect against indirect tacks (such as cache timing
attacks) as well as the direct attacks covered by SGX. It does not protect
against physical access or fault injection&lt;/li&gt;
&lt;li&gt;With Sanctum, the device manufacturer acts as a certificate authority&lt;/li&gt;
&lt;li&gt;Sanctum has a small software TCB, a ~5KLoC machine-mode security monitor&lt;/li&gt;
&lt;li&gt;The reference Sanctum implementation was built on the Rocket RISC-V
implementation&lt;/li&gt;
&lt;li&gt;Enclaves execute on private cores. i.e. it will never share L1 caches,
register, branch target buffer, TLB&lt;/li&gt;
&lt;li&gt;Sanctum also isolates physical memory. DRAM regions are defined, which are
non-overlapping regions of memory assigned to certain enclaves&lt;/li&gt;
&lt;li&gt;To isolate enclaves in the last level cache, allocate exclusively at a
region granularity (see the slides and/or the Sanctum paper for a description
of exactly how this works)&lt;/li&gt;
&lt;li&gt;To provide hardware-assisted isolation, always maintain the invariant that
entries in the TLB are safe and necessary invariants were checked while
performing the page walk&lt;/li&gt;
&lt;li&gt;Very small hardware overhead (50 gates for LLC address rotation, 600 gates
for DMA whitelist). Roughly 2% area increase in total. Roughly 6% performance
overhead in measurements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;joined-up-debugging-and-analysis-in-the-risc-v-world-gajinder-panesar:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Joined up debugging and analysis in the RISC-V world: Gajinder Panesar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Need a vendor-neutral debug infrastructure, enabling access to different
proprietary debug schemes used today by various cores&lt;/li&gt;
&lt;li&gt;Need monitors into interconnects, interfaces, and custom logic which are
run-time configurable with support for cross-triggering&lt;/li&gt;
&lt;li&gt;UltraSoC provides silicon IP and tools for on-chip debug&lt;/li&gt;
&lt;li&gt;As an example, consider a software-defined radio chip. Might want to track
CPU cycles spent on compute vs cache stalls. Or you might track utilised DDR
bandwidth over time.&lt;/li&gt;
&lt;li&gt;UltraSoC monitors are non-intrusive by default&lt;/li&gt;
&lt;li&gt;Has a portfolio of 30 modules. e.g. bus monitors, communications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating a Gantt chart from HJSON input</title>
      <link>http://www.lowrisc.org/blog/2016/10/generating-a-gantt-chart-from-hjson-input</link>
      <pubDate>Sat, 15 Oct 2016 10:00:00 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/10/generating-a-gantt-chart-from-hjson-input</guid>
      <description>&lt;p&gt;This blog post is a slight departure from the normal topics here. Worry not,
we&amp;rsquo;ll return to discussing Verilog, Chisel, and low-level software work soon.
I wrote a quick script to help serve a need (producing a Gantt chart) and
thought perhaps others would find it useful.&lt;/p&gt;

&lt;p&gt;There are a wide range of online services to help produce and maintain Gantt
charts, but none quite offered what I was looking for. I want something open
source, easy to use, and where the underlying data is human readable and can
be version controlled. The
&lt;a href=&#34;http://xael.org/pages/python-gantt-en.html&#34;&gt;python-gantt&lt;/a&gt; library formed an
excellent starting point for generating a Gantt chart in SVG, but I thought it
was worth trying to support a slightly less verbose input format.&lt;/p&gt;

&lt;p&gt;Enter &lt;a href=&#34;http://hjson.org/&#34;&gt;hjson&lt;/a&gt;, which aims to be a superset of json with
much more forgiving syntax. This has its disadvantages, but it does seem to
work well as a concise and easy to edit data format. A quick python script to
parse an hjson input to produce a Gantt chart and we&amp;rsquo;re away. One feature I do
like is the use of &lt;a href=&#34;https://github.com/amjith/fuzzyfinder&#34;&gt;fuzzy matching&lt;/a&gt; for
project references and dependencies. Again, this makes it easy to hack on by
hand. In the example below, I&amp;rsquo;m able to use &amp;ldquo;mftr widgets&amp;rdquo; to refer to the
&amp;ldquo;Manufacture widgets&amp;rdquo; task.&lt;/p&gt;

&lt;p&gt;Example input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        projects: [
            {
                name: Project Alpha
                color: green
            }
        ]

        tasks: [
            {
                name: Design widget
                begin: 2016-10-14
                duration: 7,
                people: Farquaad
                project: alpha
            }
            {
                name: Set up widget production line
                begin: 2016-10-19
                duration: 6
                people: Zack
                project: alpha
            }
            {
                name: Manufacture widgets
                duration: 7
                people: Carrie
                deps: [&amp;quot;design widget&amp;quot;, &amp;quot;widget prod line&amp;quot;]
                project: alpha
            }
        ]

        milestones: [
            {
                name: Widgets start shipping
                start: 2016-10-30
                deps: [&amp;quot;mftr widgets&amp;quot;]
                project: alpha
            }
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example output (&lt;code&gt;./hjson_to_gantt --begin-date 2016-10-10 --end-date 2016-11-13 example.hjson --name example&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/gantt_example_weekly.png&#34; alt=&#34;Example Gantt chart&#34; style=&#34;width: 900px&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lowRISC/hjson_to_gantt&#34;&gt;hjson_to_gantt is available on Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC&#43;IMC internship: second update</title>
      <link>http://www.lowrisc.org/blog/2016/07/lowriscimc-internship-second-update</link>
      <pubDate>Wed, 27 Jul 2016 14:23:34 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/07/lowriscimc-internship-second-update</guid>
      <description>&lt;p&gt;&lt;em&gt;This is the second update from our team of interns, comprised of four
University of Cambridge undergrads. Their work is kindly sponsored by &lt;a href=&#34;http://www.imc.nl/&#34;&gt;IMC
Financial Markets&lt;/a&gt; who are also helping to advise this
summer project.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;At the time of our &lt;a href=&#34;http://www.lowrisc.org/blog/2016/07/lowrisc-/-imc-internship-week-one---vga-output&#34;&gt;last blog post&lt;/a&gt;, we had just finished VGA and
were working on implementing the frame buffer. Over the last 2 weeks, we have
made significant progress, completing the frame buffer and starting video decode.&lt;/p&gt;

&lt;p&gt;The frame buffer was developed iteratively. Initially, it was a small Block RAM
attached to the SoC&amp;rsquo;s AXI-Lite bus. This was useful for creating a prototype,
but its limited size lead to it being replaced with an in-memory frame buffer,
supplemented with a BRAM line buffer. The end result is shown below, the
component is connected to the TileLink bus.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/imc_2ndupd_framebuffer.png&#34; alt=&#34;Framebuffer diagram&#34; style=&#34;width: 300px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;This component builds on the VGA controller, for which documentation will be
added shortly. We have added a data mover (a unidirectional DMA), to move data
from the in memory frame buffer into the local video memory. The video memory
acts as a line buffer, the data mover (DM) moves one line from the in-memory frame
buffer at a time. Meanwhile the VGA controller flushes the new lines to the
screen, displaying the image from memory.  The DM obeys the state machine shown
in the diagram below. The DM Controller is memory mapped, allowing the CPU to
communicate with it. Currently, it can only accept one request at a time,
further requests are ignored until the component moves back to the IDLE step.
Requests consist of source and destination addresses, and a length. A planned
extension is adding a FIFO queue to the controller to allow multiple requests
to be supported.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/imc_2ndupd_dm_states.png&#34; alt=&#34;Data mover state diagram&#34; style=&#34;width: 400px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The decision was made to implement a unidirectional data mover over a more
complex and capable bidirectional DMA component as only unidirectional movement
was needed for now. Later on, we will need bidirectional access as the
video accelerator will need to write back to memory. We hope to enable
bidirectionality by simply duplicating the existing unidirectional design.&lt;/p&gt;

&lt;p&gt;Our next tasks relate to video decoding. We will be adapting a reference
MPEG-2 codec to decode video on the FPGA and adding extra components to the
SoC design to improve the performance of the codec, such as DCT and iDCT
accelerators.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Notes from the fourth RISC-V workshop</title>
      <link>http://www.lowrisc.org/blog/2016/07/notes-from-the-fourth-risc-v-workshop</link>
      <pubDate>Thu, 14 Jul 2016 16:08:07 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/07/notes-from-the-fourth-risc-v-workshop</guid>
      <description>

&lt;p&gt;Many of the lowRISC team (Robert Mullins, Wei Song, and Alex Bradbury) have
been in Boston this week for the fourth RISC-V workshop. By any measure, this
has been a massive success with over 250 attendees representing 63 companies
and 42 Universities. Wei presented our most recent work on integrating trace
debug, which you&amp;rsquo;ll soon be able to read much more about here (it&amp;rsquo;s worth
signing up to our &lt;a href=&#34;http://www.lowrisc.org/about/&#34;&gt;announcement list&lt;/a&gt; if you want to
be informed of each of our releases).&lt;/p&gt;

&lt;h2 id=&#34;risc-v-foundation-update-rick-o-connor:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V Foundation update: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Next RISC-V Workshop will be Nov 29th-30th at Google&amp;rsquo;s Mountain View, CA&lt;/li&gt;
&lt;li&gt;The RISC-V ISA and related standards shall remain open and license-free to
all parties, and the member agreement with RISC-V Foundation will include a
license for the trademark&lt;/li&gt;
&lt;li&gt;Trademark license for commercial use is part of being a silver, gold, or
platinum member&lt;/li&gt;
&lt;li&gt;Founding member status has now finished.&lt;/li&gt;
&lt;li&gt;You don&amp;rsquo;t have to be a member to participate in specifications - each task
group must include at least one round of public consultation.&lt;/li&gt;
&lt;li&gt;Question: any plans for workshops outside of the USA? Answer: yes, we would
like to do that&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-interrupts-krste-asanović:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V interrupts: Krste Asanović&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Want a standard that is useful in high performance Unix-like systems (fast
cores, smart devices), low/mid embedded systems (slow cores, dumb devices),
and high-performance realtime systems (can&amp;rsquo;t waste time on interrupt overhead)&lt;/li&gt;
&lt;li&gt;Design goals: simplicity, support all kinds of platforms, allow tradeoffs
between performance and implementation cost, be flexible to support
specialised needs&lt;/li&gt;
&lt;li&gt;Interrupts are either local or global.

&lt;ul&gt;
&lt;li&gt;Local interrupts are directly connected to one hardware thread (hart) with
no arbitration. On RISC-V, there is currently only two of these: software
and timer.&lt;/li&gt;
&lt;li&gt;For global (external) interrupts, they are routed via the memory-mapped
Platform-Level Interrupt Controller (PLIC)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A new CSR, the Machine Interrupt Pending (mip) register is added. It has
separate interrupts for each supported privilege level.&lt;/li&gt;
&lt;li&gt;User-level interrupt handling is an optional feature. This may be used in
secure embedded systems.&lt;/li&gt;
&lt;li&gt;Software interrupts

&lt;ul&gt;
&lt;li&gt;MSIP (machine software interrupt) can only be written in machine mode via
a memory-mapped control register. This is used for inter-hart interrupts.
Also have HSIP, SSIP, USIP. A hart can only write its own HSIP, SSIP, USIP.&lt;/li&gt;
&lt;li&gt;The App/OS/Hypervisor can only perform inter-hart interrupts via
ABI/SBI/HBI calls&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Timer interrupts: MTIP is a single 64-bit real-time hardware timer and
comparator in M-mode. You want this because due to frequency scaling etc, just
going by cycle count is not useful. HTIP, STIP, UTIP are set up by M-mode
software.&lt;/li&gt;
&lt;li&gt;When running at a given privilege level, all interrupts for lower levels are
disabled.&lt;/li&gt;
&lt;li&gt;All interrupts trap to M-mode by default, and M-mode software can redirect
to the other privilege level as necessary. mideleg can be used to
automatically delegate interrupts to the next privilege level.&lt;/li&gt;
&lt;li&gt;Conceptually, when interrupts come in to the PLIC they are handled by the
gateway. This abstracts away differences between different interrupt sources.
e.g. level-triggered, edge-triggered etc. A new request isn&amp;rsquo;t forwarded to the
PLIC core unless the previous request&amp;rsquo;s handler has signaled completion.&lt;/li&gt;
&lt;li&gt;Each interrupt has an ID and priority. These priorities can be fixed or
variable. The PLIC stores per-target information&lt;/li&gt;
&lt;li&gt;An interrupted hart will try to claim an interrupt from the PLIC with a read
of the memory-mapped register. It could have been claimed by someone else, and
the PLIC core is responsible for ensuring the interrupts it received by only
one hart.&lt;/li&gt;
&lt;li&gt;If you want to add more levels of nested interrupt handling, add more harts
to your system.&lt;/li&gt;
&lt;li&gt;The position of the PLIC in the memory map isn&amp;rsquo;t defined by the
specification because many people will have existing memory maps.&lt;/li&gt;
&lt;li&gt;Question: would you have multiple PLICs on a multi-core system? Answer:
conceptually, there is only one PLIC though it could be implemented in a
distributed fashion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;formal-specification-of-risc-v-uniprocessor-consistency-arvind:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Formal specification of RISC-V uniprocessor consistency: Arvind&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Joint project with Adam Chlipala. The slogan is &amp;ldquo;chips with proofs&amp;rdquo;. These
are multicore chips that satisfy the RISC-V ISA specifications and are capable
of booting Linux.&lt;/li&gt;
&lt;li&gt;Both the design and the proofs must be modular and amenable to modular
refinement.&lt;/li&gt;
&lt;li&gt;Mostly concerned about microarchitecture and memory system correctness.&lt;/li&gt;
&lt;li&gt;Specs and designs are expressed in Bluespec.&lt;/li&gt;
&lt;li&gt;See also &lt;a href=&#34;http://plv.csail.mit.edu/kami/&#34;&gt;Kami&lt;/a&gt;, a framework for Coq for
performing proofs about Bluespec programs.&lt;/li&gt;
&lt;li&gt;A specification should avoid using concepts such as partially executed
instructions or &amp;ldquo;a store was been performed with respect to&amp;hellip;&amp;rdquo;.
Non-determinism is necessary, but unspecified behaviour should be avoided.&lt;/li&gt;
&lt;li&gt;Semantics are defined in terms of &amp;lsquo;I2E&amp;rsquo;, the Instantaneous Instruction
Execution framework. Simply, an instruction executes instantaneously ensuring
the processor state is always up to date. Data moves between processors and
memory asynchronously according to some background rules. Memory
model-specific buffers are placed between the processor state and memory.&lt;/li&gt;
&lt;li&gt;WMM is a possible memory model for RISC-V, where both loads and stores can
be re-ordered. Conceptually, invalidation buffers are added alongside the
store buffer in order to make stale values visible. Whenever a stale value is
removed from the invalidation buffer, any values that are older (more stale)
must also be removed.&lt;/li&gt;
&lt;li&gt;Memory issues arise even within a uniprocessor, due to self-modifying code
and page table access and the TLB. The fundamental issue is with multiple
paths to the same memory.&lt;/li&gt;
&lt;li&gt;Arvind is concerned that when defining formal semantics, a very weak memory
model may become very (too?) complex.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;heterogeneous-multicore-risc-v-processors-in-fd-soi-silicon-thomas-peyret:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Heterogeneous Multicore RISC-V Processors in FD-SOI Silicon: Thomas Peyret&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Want to build a large ecosystem around FD-SOI in Europe, including IP and
chipset libraries.&lt;/li&gt;
&lt;li&gt;PULSAR is a RISC-V big.LITTLE-style heterogeneous multicore. Two small cores
(rocket without FPU, 8KB L1 caches) and two big cores (3-way super-scalar BOOM
and 32KB L1 caches). It features an AMBA interconnect generated by Synopsys
CoreAssembler and has multiple body-bias zones.&lt;/li&gt;
&lt;li&gt;Currently looking to use it in the context of a pedestrian navigation
system.&lt;/li&gt;
&lt;li&gt;128-bit link to DDR5 controller, plus 4+4GTX SERDES to a separate FPGA.&lt;/li&gt;
&lt;li&gt;Also features the AntX processor, which is a very small 32-bit RISC Harvard
design from CEA Tech.&lt;/li&gt;
&lt;li&gt;Used hardware emulation with ZeBu (Synopsys)&lt;/li&gt;
&lt;li&gt;Also used SESAM for virtual prototyping (based on SystemC/TLM 2.0). This is
up to 90% accurate compared to RTL. Have also developed SCale, a new parallel
SystemC kernel.&lt;/li&gt;
&lt;li&gt;Synthesis results show 2.64mm2, 0.6W, 700MHz.&lt;/li&gt;
&lt;li&gt;Question: will the work be open-sourced? Answer: Don&amp;rsquo;t know yet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;nvidia-risc-v-evaluation-story-joe-xie:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;NVidia RISC-V evaluation story: Joe Xie&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Want to reproduce the existing NVIDIA falcon CPU with a new ISA&lt;/li&gt;
&lt;li&gt;Falcon - FAst Logic CONtroller. Introduced over 10 years ago and used in
more than 15 different hardware engines today. Low area, secure, flexible. 6
stage pipeline, variable length instructions (proprietary NVIDIA ISA).&lt;/li&gt;
&lt;li&gt;The next generation for Falcon is needed for higher performance and rich OS
support. Old Falcon is 0.67 DMIPS/MHz, 1.4 Coremark/Mhz&lt;/li&gt;
&lt;li&gt;Options were to buy access to a current architecture (MIPS, ARM, others) or
build (move to RISC-V or improve Falcon). Obviously, they elected to move to
RISC-V. The fact the ISA is extensible is a key advantage. Want an area of
less than 0.1mm2 at 16FF.&lt;/li&gt;
&lt;li&gt;NV-RISCV is 5 stage in-order issue, out-of-order execution. It has a
in-order write buffer. No FPU. Makes use of an MPU with base and bound
protection. It will initially be added to the Falcon as a 2nd core to provide
easy backwards compatibility.&lt;/li&gt;
&lt;li&gt;Area for 16FF: Falcon 0.03mm2 vs Rocket 0.055mm2 vs NV-RISC-V 0.05-0.06mm2.&lt;/li&gt;
&lt;li&gt;Did a lot of cache optimisations to tolerate large latency. Store buffer,
write merging, line-fill buffer, victim buffer, stream buffer.&lt;/li&gt;
&lt;li&gt;Areas of interest include toolchain (for automotive, debug, performance
tuning, flexibility, ilp32/ilp64). Also security (crypto instructions and
extensions), and adding cache manipulation instructions.&lt;/li&gt;
&lt;li&gt;Question: why design your own core rather than use an existing one? Answer:
after evaluating the options, it made the most sense. The motivation to go to
RISC-V was technical as well as influenced by cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;isa-shootout-a-comparison-of-risc-v-arm-and-x86-chris-celio:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;ISA Shootout – a Comparison of RISC-V, ARM, and x86: Chris Celio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recently released a new tech report &lt;a href=&#34;http://arxiv.org/abs/1607.02318&#34;&gt;The renewed case for the Reduced
Instruction Set Computer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The conventional wisdom is that CISC ISAs are more expressive and dense than
RISC ISAs, while RISC ISAs map well to high-performance pipelines. Of course,
a number of designs have CISC instructions translating to RISC-like micro-ops.&lt;/li&gt;
&lt;li&gt;Chris&amp;rsquo; contention is that a well designed RISC ISA can be very competitive
with CISC ISAs. It can be denser and higher performance.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldmiaeq sp!, {r4-r7, PC}&lt;/code&gt; is an ARMv7 instruction (load
multiple-increment-address) which will write to 7 registers and perform 6
loads. This is a common idiom for stack pop and return from a function call.&lt;/li&gt;
&lt;li&gt;Goal is to get a baseline to measure the current code generation quality of
the RISC-V gcc port. Given a fixed ISA, what can the compiler do to improve
performance? What can the programmer do? What can the micro-architect do? A
specific non-goal is to lobby for more instructions (CISC or otherwise).&lt;/li&gt;
&lt;li&gt;Dynamic instruction count can be very misleading due to the possibility it
decodes to many micro-ops. Conversely, macro-op fusion may take multiple
instructions and fuse them on the fly.&lt;/li&gt;
&lt;li&gt;Looking at 6 ISAs, using 12 benchmarks from SpecINT 2006.&lt;/li&gt;
&lt;li&gt;Average 16% more instructions for RISC-V vs x86-64, though roughly even in
terms of micro-ops. With the compressed instruction set extension, RISC-V wins
in terms of instruction bytes fetched on many of the benchmarks. Overall, 28%
fewer instruction bytes than ARMv7 and 8% fewer than x86-64.&lt;/li&gt;
&lt;li&gt;Adding array indices is the most common idiom, so why not add an indexed
load instruction to match x86? But with the compressed ISA, a pair of
compressed instructions can be treated as an indexed load by the decoder.&lt;/li&gt;
&lt;li&gt;Proposed macro-op fusion pairs: load effective address, indexed load, clear
upper word. These idioms provide 5.4% fewer &amp;ldquo;effective&amp;rdquo; instructions for RV64.&lt;/li&gt;
&lt;li&gt;Fusion isn&amp;rsquo;t just for superscalar out-of-order cores. Chris believes it
should be used by all RISC-V cores. For instance, Rocket (single issue) can be
modified to perform this.&lt;/li&gt;
&lt;li&gt;Better code generation is possible if the compiler knows fusion is
available.&lt;/li&gt;
&lt;li&gt;RISC can be denser, faster, and stay simple!&lt;/li&gt;
&lt;li&gt;Question: will compressed become standard? Answer: it may become part of the
de-facto standard or even Linux ABI standard. Still more to be done to fully
understand the complexity for processor implementations.&lt;/li&gt;
&lt;li&gt;Question: how does macro-op fusion interact with things like faults and
precise exceptions? Answer: it does add extra complexity. One solution is if
you get a fault, then re-fetch and execute without fusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trace-debugging-in-lowrisc-wei-song:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Trace debugging in lowRISC: Wei Song&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Watch this blog for much more on our trace debug work very soon.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-i-o-scale-out-architecture-for-distributed-data-analytics-mohammad-akhter:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V I/O Scale Out Architecture for Distributed Data Analytics: Mohammad Akhter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;For analytics, need a deep net with many nodes. This demands balanced
low-latency computing I/O, memory, and storage processing.&lt;/li&gt;
&lt;li&gt;Wireless network evolution is driven by real-time data with better QoS. Very
rapid growth rate in bandwidth and reduction in round-trip time latency for
LTE, LTE-A, 5G, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Built a deep learning micro-cluster. Uses RapidIO, NVidia GPUs. No RISC-V
though. They&amp;rsquo;ve then looked at how this might look with RISC-V cores instead.&lt;/li&gt;
&lt;li&gt;Want to support AXI rand RapidIO.&lt;/li&gt;
&lt;li&gt;Produced a hardware simulation model with TileLink packet generators
producing data that is transferred over a RapidIO transport.&lt;/li&gt;
&lt;li&gt;A RISC-V CPU generator model with port for RapidIO available (where?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;coherent-storage-the-brave-new-world-of-non-volatile-main-memory-dejan-vucinic:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Coherent storage. The brave new world of non-volatile main memory: Dejan Vucinić&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There are two emerging resistive non-volatile memories. ReRAM and PCM. Read
latency is orders of magnitude lower than NAND, somewhere between that of DRAM
and NAND.&lt;/li&gt;
&lt;li&gt;Should non-volatile memories be treated like memory, or like storage?&lt;/li&gt;
&lt;li&gt;For now, it seems to make sense to have the digital logic for the NVM
controller off-chip (including coherence state).&lt;/li&gt;
&lt;li&gt;Wear levelling, data protection at rest further motivate the controller
being placed along with non-volatile media.&lt;/li&gt;
&lt;li&gt;One potential approach is a coherent storage controller in reconfigurable
logic.&lt;/li&gt;
&lt;li&gt;RISC-V shopping list: Hardware coherence, fast+wide ports for peripherals to
join the coherence domain, relinquish the non-volatile memory controller for
now, and get used to high variability in main memory response time.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-as-a-basis-for-asip-design-drake-smith:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V as a basis for ASIP design: Drake Smith&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Every design is different, so why is every embedded processor the same?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Using RISC-V as a basis for ASIP can avoid many concerns. SecureRF produces
quantum-resistant security for low resource devices using group theoretic
cryptography.&lt;/li&gt;
&lt;li&gt;Using the Microsemi Smartfusion2+ board as the test platform.&lt;/li&gt;
&lt;li&gt;With a software-only port, their WalnutDSA was 63x faster than Micro-ECC.&lt;/li&gt;
&lt;li&gt;Adding a custom instruction to accelerate it only added 2% area on the FPGA
and gave another 3x increase in speed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;an-updated-on-building-the-risc-v-software-ecosystem-arun-thomas:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;An updated on building the RISC-V software ecosystem: Arun Thomas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2016 wishlist: Upstream GNU toolchain, Clang//LLVM and QEMU. Also Linux
kernel, Yocto, Gentoo, and BSD. Plus Debian/RISC-V port.&lt;/li&gt;
&lt;li&gt;Now people are getting ready to send patches for review for toolchains and
QEMU.&lt;/li&gt;
&lt;li&gt;FreeBSD 11 will officially support RISC-V. For the Debian/RISC-V port, see
Manuel&amp;rsquo;s talk tomorrow.&lt;/li&gt;
&lt;li&gt;Arun argues the Foundation should fund developers to build core software
infrastructure. Additionally, we should also decide on a process for proposing
ISA enhancements.&lt;/li&gt;
&lt;li&gt;What might funded developers do? Upstreaming and maintainership, porting
software, performance optimisation/analysis, enhancing test suites and
methodologies, continuous integration and release management.&lt;/li&gt;
&lt;li&gt;How should proposals be be handled? Various groups have approaches for this
already. e.g. Rust, Python, IEEE, IETF. Arun has put together a &lt;a href=&#34;https://github.com/arunthomas/riscv-rfcs&#34;&gt;straw-man
proposal on specification
development&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Arun would like to see the next iteration for the privileged spec to go
through a comment period.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;orca-lve-embedded-risc-v-with-lightweight-vector-extensions-guy-lemieux:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;ORCA-LVE, embedded RISC-V with lightweight vector extensions: Guy Lemieux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Using 900LUTs for a speedup of 12x. Proposed and added a standardised vector
engine to their processor.&lt;/li&gt;
&lt;li&gt;Smallest version of the ORCA implementation can fit in 2k LUTS on the
Lattice iCE40 and runs at about 20MHz.&lt;/li&gt;
&lt;li&gt;Their approach for lightweight vector extensions is to add a dedicated
vector data scratchpad and to re-use the RISC-V ALU.&lt;/li&gt;
&lt;li&gt;Vector operands are just RISC-V scalar registers containing pointers into
the vector scratchpad.&lt;/li&gt;
&lt;li&gt;To encode vector operations, they use two 32-bit instruction bundles.&lt;/li&gt;
&lt;li&gt;To allocate vector data, just use an alternative malloc function. Intrinsics
are available to manipulate vectors.&lt;/li&gt;
&lt;li&gt;In the future, want to add 2D and 3D operations as well as subword SIMD.&lt;/li&gt;
&lt;li&gt;Why not using the proposed RISC-V vector extensions? Because the detailed
proposal isn&amp;rsquo;t yet released, and LVE intends to be more lightweight and lower
overhead.&lt;/li&gt;
&lt;li&gt;Question: can these instructions raise exceptions? Answer: that hasn&amp;rsquo;t been
properly defined yet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fpgarduino-a-cross-platform-risc-v-ide-for-the-masses-marko-zec:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;FPGArduino. A cross-platform RISC-V IDE for the masses: Marko Zec&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The main attraction of the Arduino IDE is simplicity and quick results&lt;/li&gt;
&lt;li&gt;Provide pre-compiled toolchains for OSX, Windows, and Linux. For C
libraries, took mainly from FreeBSD.&lt;/li&gt;
&lt;li&gt;boards.txt defines IDE menu entries and options. Also support pre-build FPGA
bitstreams and support for upload from IDE.&lt;/li&gt;
&lt;li&gt;Have produced f32c, a retargetable scalar RISC-V core written (mostly) in
VHDL.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sifive-s-risc-v-computer-jack-kang:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;SiFive&amp;rsquo;s RISC-V computer: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SiFive is a fabless semiconductor company building customisable SoCs&lt;/li&gt;
&lt;li&gt;They produce a free and open platform spec for their platforms&lt;/li&gt;
&lt;li&gt;This week announced &amp;ldquo;Freedom Unleashed&amp;rdquo; (Linux application cores, high speed
peripherals), and &amp;ldquo;Freedom Everywhere&amp;rdquo; (targeted at embedded and IoT).&lt;/li&gt;
&lt;li&gt;The Freedom Unleashed demo will be shown today, running on an FPGA connected
to PCIe.&lt;/li&gt;
&lt;li&gt;Question: why 180nm for the Freedom Everywhere, isn&amp;rsquo;t it rather old now?
Answer: it is low cost and fast time to market so will make sense for some.&lt;/li&gt;
&lt;li&gt;Question: will peripherals etc be open sourced? Answer: things we do
ourselves e.g. SPI will be.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mit-s-riscy-expedition-andy-wright:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;MIT&amp;rsquo;s RISCy expedition: Andy Wright&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Build proofs from small components, build them up to complete, real
processors.&lt;/li&gt;
&lt;li&gt;They are now releasing their work, the Riscy processor library, Riscy BSV
utility library, and reference processor implementations. Currently
multi-cycle and in-order pipelined. Soon, out-of-order execution.&lt;/li&gt;
&lt;li&gt;Have infrastructure for tandem verification.&lt;/li&gt;
&lt;li&gt;How is modular design possible? RTL modules are not modularly refinable
under composition, i.e. implementation details of one module may put
additional constraints on another. But BSV language features do support
composability.&lt;/li&gt;
&lt;li&gt;The processor design flow involves taking the Riscy blocks, forming the
initial connections, performing modular refinement, and then scheduling
optimisation to reduce overheads due to BSV scheduling logic.&lt;/li&gt;
&lt;li&gt;Connectal implements the connections from FPGA to a host computer through
PCIe. This also works on Zynq FPGAs with an AXI transport.&lt;/li&gt;
&lt;li&gt;Tandem verification: run the same program on two RISC-V implementations at
once. Generated verification packets at commit stage, use non-deterministic
information from the implementation under test for synchronisation, and then
compare the results.&lt;/li&gt;
&lt;li&gt;Check out the code &lt;a href=&#34;https://github.com/csail-csg/riscy&#34;&gt;on Github&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Planned work involves formal specifications, proofs for modules, and proof
for processors.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-software-programmable-fpga-iot-platform-andrew-canis:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;A software-programmable FPGA IoT platform: Andrew Canis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lattice&amp;rsquo;s vision for an FPGA IoT platform is that it has high ease of use
(use C/C++ as design entry), and flexibility for a range of sensors,
actuators, communication devices.&lt;/li&gt;
&lt;li&gt;A hybrid computing solution: the RISC-V processor with FPGA hardware. RISC-V
processor plus LegUp-generated hardware acclerators to handle the processing
part of the IoT platform.&lt;/li&gt;
&lt;li&gt;The Lattice RISC-V processor has a 4 stage pipeline, and can be configured
for RV32I, RV32IM, and RV32IC. It compares favourably to the LM32, e.g. RV32IC
takes 1.6K LUTs vs 2K LUTs for the LM32 while also achieving higher DMIPS and
code density.&lt;/li&gt;
&lt;li&gt;LegUp is a high level synthesis tool.&lt;/li&gt;
&lt;li&gt;For a sum of squares of speech samples example, the LegUp synthesized
accelerator gives a 5.4x speedup vs the RISC-V software implementation.&lt;/li&gt;
&lt;li&gt;LegUp has plans to support LegUp-synthesized custom instruction
implementations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;apache-mynewt-james-pace:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Apache mynewt: James Pace&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mynewt.apache.org&#34;&gt;Mynewt&lt;/a&gt; is an open source OS for constrained IOT.
Supports ARM, AVR, Mips (and now RISC-V?).&lt;/li&gt;
&lt;li&gt;Apache Mynewt is &amp;ldquo;Linux&amp;rdquo; for devices that cannot run Linux.&lt;/li&gt;
&lt;li&gt;It is a community effort, run through the Apache Software Foundation.
Currently ~280k lines of code.&lt;/li&gt;
&lt;li&gt;Plans for Bluetooth 5 support in the future, deployments for industrial
wireless sensor networks.&lt;/li&gt;
&lt;li&gt;The Mynewt kernel is a pre-emptive, multi-tasking RTOS with a tickless
kernel.&lt;/li&gt;
&lt;li&gt;Question: does Mynewt support SMP? Answer: not currently.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dsp-isa-extensions-for-an-open-source-risc-v-implementation-pulp-pasquale-davide-schiavone:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;DSP ISA extensions for an open-source RISC-V implementation (PULP): Pasquale Davide Schiavone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RI5CYv2 is an evolution of their RISC-V implementation. It is an RV32IMC
implementation with some PULP-specific ISA extensions to target energy
efficiency.&lt;/li&gt;
&lt;li&gt;Includes support for profiling and core execution trace.&lt;/li&gt;
&lt;li&gt;Coremark/Mhz is competitive with the ARM Cortex M4.&lt;/li&gt;
&lt;li&gt;Hardware loop instructions benefit control-intensive applications&lt;/li&gt;
&lt;li&gt;Add DSP extensions to improve energy efficiency for signal processing
algorithms. Want to execute more quickly so the core can enter a low-power
mode.&lt;/li&gt;
&lt;li&gt;RI5CYv2 adds dot product between vectors, saturation instructions, small
vector instructions, &amp;hellip; GCC support is present for these.&lt;/li&gt;
&lt;li&gt;These additional instructions give a performance increase of up to 9.5x,
6.4x on average for data-intensive kernels.&lt;/li&gt;
&lt;li&gt;The fan-out 4 of the critical path is 31. When laying out at 65nm, area is
67 kilo-gate equivalents.&lt;/li&gt;
&lt;li&gt;Released so far just 10% of what they will release in the future, so there&amp;rsquo;s
much more to come. The full PULP will be released in December, an in the
meantime you can use the PULPino core.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-dover-edge-a-metadata-enhanced-risc-v-architecture-andré-dehon:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;The DOVER Edge: A Metadata-Enhanced RISC-V Architecture: André DeHon&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;How do we handle the &amp;lsquo;edge&amp;rsquo; of a metadata tagged system? e.g. I/O to the
untagged world, legacy devices, DMA.&lt;/li&gt;
&lt;li&gt;PUMP is a metadata processing engine that checks tags upon every instruction
and memory access.&lt;/li&gt;
&lt;li&gt;For slave devices, tags can be associated with memory mapped devices. These
are used to write rules to control access. This allows giving configuration
control to particular drivers, without giving the driver control to all
devices or other privileges.&lt;/li&gt;
&lt;li&gt;DMA I/O policies might target: containment (who&amp;rsquo;s allowed to read/write a
buffer), integrity (mark incoming data as untrusted), secrecy, and
data presence/synchronisation.&lt;/li&gt;
&lt;li&gt;Add new supported opcodes as input to the PUMP representing DMA load and DMA
store. Modify PC tag and Instr tag to represent the state of the DMA and the
DMA source.&lt;/li&gt;
&lt;li&gt;If a DMA is deemed to be misbehaving, it can be totally disabled by the PUMP
or the particular operation could be discarded.&lt;/li&gt;
&lt;li&gt;In this design, there is both an IO pump and a processor PUMP. The IO pump
is pipelined so it will not reduce system throughput.&lt;/li&gt;
&lt;li&gt;The IO pump generates an interrupt on a rule miss. The miss handler uses the
same rule function as for the processor PUMP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;improving-the-performance-per-area-factor-of-risc-v-based-multi-core-systems-tobias-strauch:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Improving the performance-per-area factor of RISC-V based multi-core systems: Tobias Strauch&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The speaker has spent many years working on C-slow retiming&lt;/li&gt;
&lt;li&gt;System hyper pipelining is based on C-slow retiming. It replaces original
registers with memories, and adds thread stalling and bypassing features.&lt;/li&gt;
&lt;li&gt;In &amp;lsquo;deep pipelining&amp;rsquo;, run one thread in &amp;lsquo;beast mode&amp;rsquo;. Switch to another
thread if an instruction dependency is detected.&lt;/li&gt;
&lt;li&gt;Created the microRISC project, working on the V-scale design. With SHP was
able to move from 80MHz to 250MHz.&lt;/li&gt;
&lt;li&gt;miniRISC (based on lowRISC). Want to perform SHP on the Rocket core. The
speaker proposes that instead of having multiple minions you have a
hyper-pipelined core.&lt;/li&gt;
&lt;li&gt;The source code of the projects will be released in PDVL, a new language
&amp;ldquo;way better than Chisel and Bluespec Verilog(!)&amp;rdquo; that produces VHDL and
Verilog.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-towards-a-debian-risc-v-port-manuel-a-fernandez-montecelo:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Working towards a Debian RISC-V port: Manuel A. Fernandez Montecelo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Debian is a community of volunteers who care about free and open-source
software.&lt;/li&gt;
&lt;li&gt;Debian contains more than 22k source packages&lt;/li&gt;
&lt;li&gt;Debian contains a mix of officially supported ports, unofficial releases (on
Debian infrastructure but not part of the stable release process), and others
are outside of Debian infrastructure (e.g. Raspbian).&lt;/li&gt;
&lt;li&gt;Why a Debian port for RISC-V? Interested as Manuel feels affinity with the
goals of the project, previously enjoyed working with the OpenRISC port.&lt;/li&gt;
&lt;li&gt;Goal is to have a complete, fully supported, continuously updated Debian
port. The initial step is to bootstrap a viable, basic OS disk image.&lt;/li&gt;
&lt;li&gt;The chosen RISC-V target is 64-bit little endian. This is the recommended
default and what is planned for the lowRISC board.&lt;/li&gt;
&lt;li&gt;Been working on and off since November 2014. Upstreaming of toolchains etc
would be very helpful. Have now built 300-400 &amp;ldquo;essential&amp;rdquo; packages.&lt;/li&gt;
&lt;li&gt;Packages where mostly cross-compiled, with some compiled &amp;lsquo;natively&amp;rsquo; inside
emulators. Some require building multiple times to e.g. break circular
dependencies.&lt;/li&gt;
&lt;li&gt;ABI changes mean work has to restart from scratch.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kami-a-framework-for-hardware-verification-murali-vijayaraghavan:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Kami. A framework for hardware verification: Murali Vijayaraghavan&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This work is part of the &amp;ldquo;Riscy Expedition&amp;rdquo; by MIT. Want to build chips with
proofs.&lt;/li&gt;
&lt;li&gt;Must to able to verify an optimisation is correct independent of contexts,
to enable modular verification of a full system.&lt;/li&gt;
&lt;li&gt;Kami is a DSL inside the Coq proof assistant for verifying Bluespec-style
hardware.&lt;/li&gt;
&lt;li&gt;Have finished building required theory and proof automation infrastructure.&lt;br /&gt;
Are currently working on proving a cluster of multi-cycle cores connected to a
coherent cache hierarchy implements sequential consistency.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

