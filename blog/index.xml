<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on lowRISC</title>
    <link>http://www.lowrisc.org/blog/</link>
    <description>Recent content in Blogs on lowRISC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 May 2018 07:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.lowrisc.org/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Barcelona RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-one</link>
      <pubDate>Tue, 08 May 2018 07:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2018/04/risc-v-workshop-in-barcelona-agenda/&#34;&gt;eighth RISC-V
workshop&lt;/a&gt; is
going
on today Barcleona. As usual, I&amp;rsquo;ll be keeping a semi-live blog of talks and
announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Introduction: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This workshop has 325 attendees representing 101 companies and 25
universties. Largest outside of Silicon Valley.&lt;/li&gt;
&lt;li&gt;Rick gives the usual overview of the RISC-V Foundation structure.&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation currently has over 150 members, including invidual
members. These members are distributed across 25 countries around the world.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-state-of-the-union-krste-asanovic:7e63e62b65afd74857129fe53555ff5b&#34;&gt;RISC-V state of the union: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Krste gives an overview of the RISC-V ISA for newcomers.&lt;/li&gt;
&lt;li&gt;RISC-V encoding terminology.

&lt;ul&gt;
&lt;li&gt;Standard: defined by the Foundation&lt;/li&gt;
&lt;li&gt;Reserved: Foundation might eventually use this space for future standard
extensions.&lt;/li&gt;
&lt;li&gt;Custom: Space for implemnter-specific extensions, never claimed by
Foundation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The RISC-V big tent philosophy: enable all types of RISC-V implementation,
from 32-bit microcontrollers with 1KiB SRAM up to 64-bit Unix servers with
virtualisation or 128-bit 100k-core supercomputer with PiBs DRAM, open or
proprietary business models, non-conforming extensions, software
implementations (e.g. QEMU), &amp;hellip;

&lt;ul&gt;
&lt;li&gt;Minimize wasted work through maximum reuse. Factor out platform-level
requirements from reusable ISA and software modules&lt;/li&gt;
&lt;li&gt;Use standard platform profiles to reduce ecosystem effort.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC 0-5 milestone release</title>
      <link>http://www.lowrisc.org/blog/2018/01/lowrisc-0-5-milestone-release</link>
      <pubDate>Fri, 12 Jan 2018 14:45:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2018/01/lowrisc-0-5-milestone-release</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;http://www.lowrisc.org/docs/ethernet-v0.5/&#34;&gt;lowRISC 0.5 milestone release&lt;/a&gt;
is now available. The various changes are best described in our &lt;a href=&#34;http://www.lowrisc.org/docs/ethernet-v0.5/&#34;&gt;accompanying
documentation&lt;/a&gt;, but the main focus
is the integration of open-source Ethernet IP. The tutorial demonstrates how
to use Ethernet support to boot with an NFS root, as well as with a rootfs on
SD card.&lt;/p&gt;

&lt;p&gt;Our main development focus currently is migrating to a newer version of the
upstream Rocket chip design and reintegrating our changes on top of that, but
we felt that the integration of Ethernet support merits a release before that
change.&lt;/p&gt;

&lt;p&gt;Please report any issues &lt;a href=&#34;https://github.com/lowRISC/lowrisc-chip&#34;&gt;on our GitHub
repository&lt;/a&gt;, or discuss on our
&lt;a href=&#34;http://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;mailing
list&lt;/a&gt;.
As always, thank you to everyone who has contributed in any way - whether it&amp;rsquo;s
advice and feedback, bug reports, code, or ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Seventh RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-two</link>
      <pubDate>Wed, 29 Nov 2017 15:16:45 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2017/10/7th-risc-v-workshop-agenda/&#34;&gt;seventh RISC-V
workshop&lt;/a&gt; is concluding
today at Western Digital in Milpitas. I&amp;rsquo;ll be keeping a semi-live blog of
talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;celerity-an-open-source-511-core-risc-v-tiered-accelerator-fabric-michael-taylor:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Celerity: An Open Source 511-core RISC-V Tiered Accelerator Fabric: Michael Taylor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Built in only 9 months.&lt;/li&gt;
&lt;li&gt;Celerity is an accelerator-centric SoC with a tiered accelertor fabric.&lt;/li&gt;
&lt;li&gt;Implemented in TSMC 16nm FFC. 25mm2 die area, 385M transistors&lt;/li&gt;
&lt;li&gt;Why 511 RISC-V cores? 5 Linux-capable RV64G Rocket cores, 496-core RV32IM
mesh tiled area &amp;ldquo;manycore&amp;rdquo;, 10-core RV32IM mesh tiled array (low voltage).&lt;/li&gt;
&lt;li&gt;Used a flip-chip package.&lt;/li&gt;
&lt;li&gt;Of the 5 general purpose cores, 4 connect to the manycore array and 1
interfaces with the Binary Neural Network accelerator. Each core executes
independently within its own address space.&lt;/li&gt;
&lt;li&gt;The BaseJump manycore architecture implements the RV32IM with a 5-stage
pipeline (full forwarded, in-order, single issue). It has 4KB+4KB instruction
and data scratchpads.&lt;/li&gt;
&lt;li&gt;BaseJump Manycore Mesh Network: stores are routed based on the destination.
Simple XY-dimension routing.&lt;/li&gt;
&lt;li&gt;Each Rocket core has its own RoCC interface connecting to one of the routers
in the mesh.&lt;/li&gt;
&lt;li&gt;Uses a remote store programming model, which enables efficient
producer-consumer programming models. Offer extended instructions such as load
reserved (load value and set the reservation address),
load-on-broken-reservation (stall if the reserved address wasn&amp;rsquo;t written by
other cores), and a consumer instruction to wait on a given address/valud. No
polling or interrupts are required.&lt;/li&gt;
&lt;li&gt;Currently working on CUDA support.&lt;/li&gt;
&lt;li&gt;Can fit 42 of the &amp;ldquo;manycore&amp;rdquo; cores per mm2 (vs 5 cores per mm2 for Rocket).&lt;/li&gt;
&lt;li&gt;80% of the modules in the manycore are from the BaseJump library.&lt;/li&gt;
&lt;li&gt;For the backend, hardened each core and replicated across the die.&lt;/li&gt;
&lt;li&gt;Over 2/3rds of each manycore tile is memory.&lt;/li&gt;
&lt;li&gt;For the BNN: each core in the manycore tier executes a remote-load-store
program to orchestrate sending weights to the specialization tier via a
hardware FIFO.&lt;/li&gt;
&lt;li&gt;All code available at &lt;a href=&#34;http://opencelerity.org&#34;&gt;opencelerity.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Want to build the &amp;ldquo;DNA&amp;rdquo; for open source ASICs. i.e. the basic components
needs for building a full system, spanning RTL, IP cores, hardware emulation,
packaging, PCBs. See &lt;a href=&#34;http://bjump.org&#34;&gt;bjump.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The BaseJump STL contains several hundred modules, all parameterised.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-pulp-cores-a-set-of-open-source-ultra-low-power-risc-v-cores-for-internet-of-things-applications-pasquale-davide-schiavone:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;The PULP Cores. A Set of Open-Source Ultra-Low-Power RISC-V Cores for Internet-of-Things Applications: Pasquale Davide Schiavone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PULP: Parallel Ultra-Low Power.&lt;/li&gt;
&lt;li&gt;Designed for energy efficient hardware, e.g. near-sensor computation.&lt;/li&gt;
&lt;li&gt;Have a set of 3 32-bit cores currently available, and working on a 64-bit
Linux-capable core.&lt;/li&gt;
&lt;li&gt;RISCY core has a 4-stage pipeline. RV32IM[F]C. 40.7-69.3kGE. 3.19
CoreMark/MHz. Also has a number of extensions for packed SIMD, fixed point,
bit manipulation and hardware loops.&lt;/li&gt;
&lt;li&gt;Zero-riscy has a 2-stage pipeline. RV32{I,E}[M]C. 11.6-18.9kGE. 2.44
CoreMark/MHz for RV32IMC and 0.91 for RV32EC. Optimized for area.&lt;/li&gt;
&lt;li&gt;Arian core for Linux. 6-stage pipeline, RV64IMC, 185kGE, OoE execution and
in-order commit. 2.01 CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;Also have a set of software tools for PULP. Virtual platform, timing model.
Have 1MIPS simulation speed with timing accuracy between 20-20% of the target
hardware. Can also profile using kcachegrind.&lt;/li&gt;
&lt;li&gt;How to verify these cores? Use constrained pseudo-random test generation in
a perturbated environment (random interrupts, stalls). The program generator
tries to maximise the code coverage, and the instruction simulation and RTL
model are compared.&lt;/li&gt;
&lt;li&gt;Large number of companies using PULP/PULPino, e.g. Mentor, GreenWaves, NXP,
Micron, Microsemi, Cadence, ST, Google, Intel.&lt;/li&gt;
&lt;li&gt;PULPissimo platform will be released Q12018, including the new microDMA
subsystem, new interrupt controller, new SDK etc. Taping out on GF22 soon.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;boom-v2-an-open-source-out-of-order-risc-v-core-chris-celio:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;BOOM v2. An open-source out-of-order RISC-V core: Chris Celio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Out of order superscalar implementing RV64g. Open source and written in
Chisel (~16kloc). Built on top of the rocket-chip ecosystem.&lt;/li&gt;
&lt;li&gt;Advanced branch prediction. Loads can issue out-of-order with regard to
other loads and stores.&lt;/li&gt;
&lt;li&gt;Parameterised, just a few lines to instantiate a 2-wide vs 4-wide BOOM.&lt;/li&gt;
&lt;li&gt;BOOM has now been taped out! Taped out with a 2 person team in 4 months.&lt;/li&gt;
&lt;li&gt;Total LoC for the SiFive U54 Rocket is 34kloc, vs 50kloc for BOOMv2, vs
1.3mloc (Verilog) for the UltraSPARC T2.&lt;/li&gt;
&lt;li&gt;Boomv2 achieves 3.92 CoreMark/MHz (on the taped out BOOM), vs 3.71 for the
Cortex-A9.&lt;/li&gt;
&lt;li&gt;BOOMv1 had a short pipeline inspired by R10K, 21264, Cortex-A9 and a unified
issue window.&lt;/li&gt;
&lt;li&gt;BOOMv2: broke critical paths in the frontend. Put the BTB into SRAM. Also
moved hashing to its own stage.&lt;/li&gt;
&lt;li&gt;The first place+route for register file resulted in huge area. Ended up
splitting the unified issue window, splitting the physical register file,
moving issue and register read into separate stages. Then implemented 2-stage
rename and 3-stage fetch.&lt;/li&gt;
&lt;li&gt;Didn&amp;rsquo;t have the resources to support a customised register file. A
synthesised register file resulted in huge congestion when routing the wires
from the flip-flops. Instead, black-boxed the register file and hand-wrote
some Verilog to instantiate specific flip-flops, muxes, and tri-state buffers.
Effectively hand-crafting their own bit block out of standard cells.&lt;/li&gt;
&lt;li&gt;Saw about a 25% decrease in clock period, and 20% decrease in CoreMark/MHz
(due to increased load-use delay, fixable in the future). A lot of the work
was about fixing design rule check and geometry errors.&lt;/li&gt;
&lt;li&gt;Physical design is a bottleneck for agile hardware development. RTL hacking
can be rapid, but it takes 2-3 hours for synthesis results and 8-24 hours for
P+R results. Additionally, manual intervention is often required and reports
are difficult to reason about.&lt;/li&gt;
&lt;li&gt;Future directions for BOOM: further IPC and QoR improvements. Chris is
joining Esperanto Technologies, but is committed to maintain the BOOM
open-source repository.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rocket-engines-easy-custom-risc-v-cores-through-reuse-albert-magyar:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Rocket Engines. Easy, custom RISC-V cores through reuse: Albert Magyar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why are there so many RISC-V cores (or: why not reuse rocket?). Often a
desire to match interface to be a &amp;ldquo;drop in&amp;rdquo; replacement for an existing core,
or want to tailor microarchitecture for custom extensions. Also, may find
Rocket is over-featured for the desired design point.&lt;/li&gt;
&lt;li&gt;Less good reasons: not invented here, fear of Chisel.&lt;/li&gt;
&lt;li&gt;There are a number of pitfalls for customized cores. e.g. introducing bugs
that have long since been avoided in Rocket.&lt;/li&gt;
&lt;li&gt;Avoid reusing either too little or too much. Can reuse individual components
without using the top-level rocket-chip framework at all. Stitch together
individual components.&lt;/li&gt;
&lt;li&gt;The &amp;ldquo;big 3&amp;rdquo; components: CSR file, decoder, RISC-V compressed (RVC) expander.&lt;/li&gt;
&lt;li&gt;produced a new RISC-V core IP: &amp;ldquo;BottleRocket&amp;rdquo;. This has a classic
three-stage pipeline with a similar microarchitecture to Z-Scale and V-Scale.
Implements RV32IMC. The generator produces a single, easy to connect tile.&lt;/li&gt;
&lt;li&gt;Supports debug, test, platform features: 0.13 debug spec, RVFI trace port,
external interrupt controller.&lt;/li&gt;
&lt;li&gt;The open sourcing effort is underway, as is the integration with
riscv-formal.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-perspective-on-the-role-of-open-source-ip-in-government-electronic-systems-linton-salmon:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;A Perspective on the Role of Open-Source IP in Government Electronic Systems: Linton Salmon&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The USD Department of Defence (DoD) needs custom SoCs. Custom ICs are
necessary to reach the target GOps/W. Computation requirements keep growing,
and real-time results are often required.&lt;/li&gt;
&lt;li&gt;Current DoD architectures often use older technology nodes. Now moving
towards newer technology nodes (28nm and below).&lt;/li&gt;
&lt;li&gt;Most of the cost for DoD custom SoCs is in design. Typically low volume (1k
parts). For small volume, find design costs 92%, fab NRE 7%, 1% production
costs.&lt;/li&gt;
&lt;li&gt;Design cost are skyrocketing, increasingly dramatically with each technology
node. This is a huge problem for the low volume DoD designs.&lt;/li&gt;
&lt;li&gt;Is open source IP the answer? The good news is that it can sharply reduce
resources, time and complexity or a DoD custom SoC design. Open source IP
permits increased use of unique DoD security approaches.&lt;/li&gt;
&lt;li&gt;The not so good news: the open source community needs to develop a complete
infrastructure, needs to e more robust than it is today, the community needs a
model to fund infrastructure, and the support model must assure long term
support and continued development of open source IP.&lt;/li&gt;
&lt;li&gt;Unique differentiation doesn&amp;rsquo;t require development of the entire platform.
Want to put all the effort into the differentiating &amp;ldquo;secret sauce&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Open source IP can address both the cost and availability of standard IP.
Open source IP macros are a critical first step, but integration IP is also
needed.&lt;/li&gt;
&lt;li&gt;Open source IP enables specialisation. It provides the blocks and standard
infrastructure that can then be specialised.&lt;/li&gt;
&lt;li&gt;Open source IP enables greater scrutiny by the DoD to ensure trust:
assurance it will only do as specified.&lt;/li&gt;
&lt;li&gt;Hardware security requires the ability to modify the SoC, including 3d party
IP. Added security capabilities require a robust base and infrastructure.&lt;/li&gt;
&lt;li&gt;RISC-V is an adaptable open standard. RISC-V processors can be built in a
way that can be trusted, and RISC-V can be used to enable increased security
(easy to add security extensions).&lt;/li&gt;
&lt;li&gt;Need a full ecosystem infrastructure. Need to cover the entire
infrastructure, be robust, and easy to use.&lt;/li&gt;
&lt;li&gt;DoD requires robustness and dependability of the open-source infrastructure.
Need complete verification, clear documentation, robustness validated through
to silicon implementation and test. This is not the role or the strength of
universities.

&lt;ul&gt;
&lt;li&gt;Savings requires the ability to depend on the open source IP.&lt;/li&gt;
&lt;li&gt;Savings require the robustness of the IP across extended performance
ranges.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need a model to fund long-term infrastructure. This isn&amp;rsquo;t the role of DARPA,
which funds projects rather than infrastructure. Much of the work is
difficult, but not exciting.&lt;/li&gt;
&lt;li&gt;Need continual maintenance and improvement. Regular updates in terms of
performance, architecture, and fabrication technology.&lt;/li&gt;
&lt;li&gt;DARPA programs driving open source IP: PERFECT, CRAFT, SSITH, POSH, IDEA.&lt;/li&gt;
&lt;li&gt;CRAFT&amp;rsquo;s goal is to enable more efficient custom IC design/fabrication to
enable high performance electronic solutions faster and with more flexibility.&lt;/li&gt;
&lt;li&gt;SSITH: develop hardware design tools and IP to provide inherent security
against hardware vulnerabilities that are exploited through software in DoD
and commercial electronic systems.&lt;/li&gt;
&lt;li&gt;IDEA: no &amp;ldquo;human in the lop&amp;rdquo; 24-hour layout generation for mixed signal ICs,
systems in package, and PCBs. Machine generated layout of electrical circuits
and systems.&lt;/li&gt;
&lt;li&gt;POSH: an open source System on Chip design and IP ecosystem.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;boosting-risc-v-isa-with-open-source-peripherals-an-soc-for-low-power-sensors-elkim-roa:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Boosting RISC-V ISA with Open Source Peripherals. An SoC for Low Power Sensors: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Challenges: ready-to-plug IP and expensive licenses.&lt;/li&gt;
&lt;li&gt;Been working with SiFive, providing IP blocks for the always-on domain.&lt;/li&gt;
&lt;li&gt;The power management unit is a state machine running a microcode program
that triggers events as necessary.&lt;/li&gt;
&lt;li&gt;Have implemented a wide range of IP: low-noise bandgap voltage reference,
LDO, biasing control, crystal low-frequency driver (XTAL-RF), RC Oscillator,
brownout detector, power-on reset, multi-resolution DAC and ADC, fully
synthesized true random number generator&lt;/li&gt;
&lt;li&gt;Finally, integrated these always-on domain blocks in a TSMC180nm SoC using
Chisel at the top level.&lt;/li&gt;
&lt;li&gt;Deliverables: releasing Verilog models, FSM Verilog RTL, documentation etc
through the freechips project. Schematics and layout available through the
SiFive Designshare program.&lt;/li&gt;
&lt;li&gt;Taping out at the end of the year with SiFive, also want to include PHYs
like SATA, PCIe, USB next year. Hope to have a qualified range of IP in 2019.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;picosoc-how-we-created-a-risc-v-based-asic-processor-using-a-full-open-source-foundry-targeted-rtl-to-gds-flow-and-how-you-can-too-tim-edwards:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;PicoSoC: How we created a RISC-V based ASIC processor using a full open source foundry-targeted RTL-to-GDS flow, and how you can, too!: Tim Edwards&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Created an ASIC version of a RISC-V core (PicoRV32) using an entirely open
source toolflow.&lt;/li&gt;
&lt;li&gt;Targeting a 180nm process.&lt;/li&gt;
&lt;li&gt;Open source synthesis toolchain: qflow is built using yosys/ABC, vesta,
graywolf, qrouter, magic, netgin, iverilog, ngspice.&lt;/li&gt;
&lt;li&gt;PicoSoC includes a UART, SPI memory controller, scratchpad SRAM, and SPI
flash. Started the SoC targeting the open source Lattice ice40 flow, and add
padframe, power-on-reset, and generated SRAM to target ASIC.&lt;/li&gt;
&lt;li&gt;Can perform cosimulation using iverilog and ngspice.&lt;/li&gt;
&lt;li&gt;The PicoSoC core is 1mm2, with analog+SRAM+padframe, 2mm x 1.5mm.&lt;/li&gt;
&lt;li&gt;Can reproduce this yourself using the efabless IP catalog and the efablass
CloudV-based design environment.&lt;/li&gt;
&lt;li&gt;This is brought together in the efabless Open Galaxy Design Environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tilelink-a-free-and-open-source-high-performance-scalable-cache-coherent-fabric-designed-for-risc-v-wesley-terpstra:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;TileLink. A free and open-source, high-performance scalable cache-coherent fabric designed for RISC-V: Wesley Terpstra&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Requirements for a RISC-V bus: Open standard, easy to implemented,
cache-coherent block motion, multiple cache layers, reusable on and off-chip,
and high performance.&lt;/li&gt;
&lt;li&gt;What about AMBA CHI/ACE?

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Open standard? CHI is not open!&amp;rdquo;. Can&amp;rsquo;t get hold of the spec.&lt;/li&gt;
&lt;li&gt;Not easy to implement: 10 probe message types, split control/data, narrow
bursts, &amp;hellip;&lt;/li&gt;
&lt;li&gt;No support for multiple cache layers.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t want to depend on a standard controlled by a RISC-V competitor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TileLink was a clean slate project out of UC Berkeley. Featured a reduced
message protocol, assumed all connected hardware is trusted (do security
checking at the source, not in the network), and only supports power-of-2
block transfers.&lt;/li&gt;
&lt;li&gt;TileLink is a master-slave point-to-point protocol. It&amp;rsquo;s message based with
5 priorities. Out-order design with optional ordering. It&amp;rsquo;s designed for
composability and deadlock freedom.&lt;/li&gt;
&lt;li&gt;TileLink is open source and in production. Over 30 public modules including
cores, crossbars and adapters. Has a coherency manager similar to how ACE does
snooping. Also have bridges to AXI/AHB/APB&lt;/li&gt;
&lt;li&gt;SiFive chips use a banked directory-based wormhole MESI L2$.&lt;/li&gt;
&lt;li&gt;There are a few simplifying assumptions that make the protocol easier to
work with.

&lt;ul&gt;
&lt;li&gt;Require there are no agent loops, i.e. the bus participants (agents) form
a directed acyclic graph.&lt;/li&gt;
&lt;li&gt;There are strict priorities. Messages have one of five priorities, and
lower priority messages never block higher priority messages. Responses have
a higher priority than requests.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The on-chip TileLink wire protocol uses an independent channel for each
message priority. Messages are transmitted using multi-beat bursts. Use
ready-valid.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-risc-v-vector-isa-roger-espasa:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;The RISC-V Vector ISA: Roger Espasa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why a vector extension? Reduce instruction bandwidth, reduce memory
bandwidth, lower energy, exposes DLP, masked execution, gather/scatter.
Scalable from small to large vector processing unit.&lt;/li&gt;
&lt;li&gt;The vector ISA in a nutshell

&lt;ul&gt;
&lt;li&gt;32 vector registers. Each can hold either a scalar, vector, or a matrix
(shape). Each has an associated type (polymorphic encoding). There are a
variable number of registers (dynamically changeable).&lt;/li&gt;
&lt;li&gt;Vector instruction semantics: all instructions are controlled by the
Vector Length (VL) register and can be executed under mask. Precise
exceptions are supported.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Suppose you&amp;rsquo;re adding two vector registers: &lt;code&gt;vadd v1, v2 -&amp;gt; v0&lt;/code&gt;. If the
vector length is less than maximum vector length, the remaining values must be
zeroed.&lt;/li&gt;
&lt;li&gt;You could implement this how you like. Might choose to have a 2-lane
implementation (two FP adders), or 4-lane, or even 8-lane (SIMD, doing all in
one cycle). The number of lanes is transparent to the programmer and the same
code runs independent of the number of lanes.&lt;/li&gt;
&lt;li&gt;Data inside a VREG could be a single scalar value, a vector, or a matrix
(optionally). The current shape is held in the per-vreg type field.

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;vadd v1, v2.s -&amp;gt; v0&lt;/code&gt;. This adds the scalar value in v2 to every
value in vector v1.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Masks are stored in regular vector registers (i.e. there will not be
separate mask registers). Masks are computed with compare operations, and
instructions use 2 bits of encoding to select masked execution.

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;vadd v3, v4, v1.t -&amp;gt; v5&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;v1 is the only register used as mask source.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector load (unit stride). &lt;code&gt;vld 80(x3) -&amp;gt; v5&lt;/code&gt; will Vector Length elements.&lt;/li&gt;
&lt;li&gt;Stride vector load. &lt;code&gt;vlds 80(x3, x9) -&amp;gt; v5&lt;/code&gt; performs a strided load.&lt;/li&gt;
&lt;li&gt;Gather (indexed vector load). &lt;code&gt;vldx 80(x3, v2) -&amp;gt; v5&lt;/code&gt;. This uses a vector to
hold offsets. Repeated addresses are legal.&lt;/li&gt;
&lt;li&gt;Vector store: &lt;code&gt;vst v5 -&amp;gt; 80(x3)&lt;/code&gt;. Note that zeroes won&amp;rsquo;t be written when MVL
is larger than the vector length.&lt;/li&gt;
&lt;li&gt;Scatter (indexed vector store). &lt;code&gt;vstx v5 -&amp;gt; 80(x3, v2)&lt;/code&gt;. Will probably have
two version of scatter, where one has guarantees about the ordering or stores
to repeated addresses.&lt;/li&gt;
&lt;li&gt;Ordering:

&lt;ul&gt;
&lt;li&gt;From the point of view of a given hart, vector loads and stores happen in
order. You don&amp;rsquo;t need any fences to see your own stores.&lt;/li&gt;
&lt;li&gt;From the point of view of other harts, see the vector memory accesses as
if done by a scalar loop. This means they can be seen out-of-order by other
harts.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Typed vector registers:

&lt;ul&gt;
&lt;li&gt;Each vector register has an associated type, which can be different for
different registers.&lt;/li&gt;
&lt;li&gt;Types can be mixed in an instruction under certain rules.&lt;/li&gt;
&lt;li&gt;Register types enable a &amp;ldquo;polymorphic&amp;rdquo; encoding an is also more scalable
for the future.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vcvt is used for type and data conversions.&lt;/li&gt;
&lt;li&gt;In some cases, types can be mixed in an instruction. e.g. adding &lt;code&gt;v1_i8, 
v2_i64 -&amp;gt; v0_i64&lt;/code&gt;. When any source is smaller than the destination, the source
is promoted to the destination size.&lt;/li&gt;
&lt;li&gt;The size of the vector register file is not set by the ISA. It is configured
by writing to the vdcfg CSR. When doing this, the hardware computes the
maximum vector length. This configuration can be done in user mode.

&lt;ul&gt;
&lt;li&gt;One implementation choice is to always return the same MVL, regardless of
config. Alternatively, split storage across logical registers, perhaps
losing some space.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;E.g the hardware has 32 registers, 4 elements per vector, each 4 bytes = 512
bytes. If the user asks for 32 F32 registers, &lt;code&gt;MVL = 512B / (32 * 4) = 4&lt;/code&gt;. If
the user asked for only 2 F32 registers, &lt;code&gt;MVL = 512B / (4+4) = 64&lt;/code&gt;. But it
would be legal for the implementation to return something smaller, e.g. 4 as
in the previous example.&lt;/li&gt;
&lt;li&gt;If the user asks for 2 F16 regs and 2 F32 registers, &lt;code&gt;MVL = 512B / (12B + 
4B) = 32&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;MVL is transparent to software, meaning code can be portable across
different number of lanes and different values of MVL.&lt;/li&gt;
&lt;li&gt;Not covered today: exceptions, kernel save + restore, custom types, or
matrix shapes.&lt;/li&gt;
&lt;li&gt;Goal is to be the best vector ISA ever! Expect LLVM and GCC to support it.&lt;/li&gt;
&lt;li&gt;Current spec on GitHub is out-of-date.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;security-task-group-update-and-risc-v-security-extension-richard-newell:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Security task group update and RISC-V security extension: Richard Newell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The security working group works in two main areas. Trusted execution /
isolation and cryptographic extensions. Recently had changes in direction for
trusted execution / isolation.&lt;/li&gt;
&lt;li&gt;This talk will focus on the cryptographic extensions status. Hope to have a
written spec for the next workshop.&lt;/li&gt;
&lt;li&gt;Want to rely heavily on the vector extensions for crypto.&lt;/li&gt;
&lt;li&gt;Use vector functional units to perform modular and Galois Field arithmetic
needed for existing popular and promising post-quantum asymmetric cryptography
schemes. Also accelerate symmetric block ciphers and digest algorithms taking
advantage of the wide vector registers, using specialized VFUs (e.g. AES,
SHA-2).&lt;/li&gt;
&lt;li&gt;Asymmetric crypto acceleration: use hardware support for modular arithmetic,
but software for group operations and point multiplication.&lt;/li&gt;
&lt;li&gt;Propose vector element widths up to 4096, as well as an escape mechanism to
allow larger widths or non-power-of-two widths.&lt;/li&gt;
&lt;li&gt;Intend to use just one major opcode for the cryptographic extension.&lt;/li&gt;
&lt;li&gt;Richard presented a handy slide summarising the algorithms used in crypto
suites / libraries. Be sure to check it out once the slides become available!&lt;/li&gt;
&lt;li&gt;Proposing to define profiles that define the required crypto algorithms.
e.g. a profile for &amp;ldquo;internet&amp;rdquo;, &amp;ldquo;finance&amp;rdquo;, and &amp;ldquo;cellular&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-proposed-vector-and-crypto-extensions-for-fast-and-secure-boot-richard-newell:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Using proposed vector and crypto extensions for fast and secure boot: Richard Newell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Richard is giving a great summary of implementing various crypto algorithms
using the proposed crypto extensions, but unfortunately it&amp;rsquo;s difficult to
summarise the information presented in these diagrams.&lt;/li&gt;
&lt;li&gt;Expect a huge speedup vs the ARM Cortex-M3 for an appropriate RV32IVY
implementation (though very dependent on the hardware that is implemented).&lt;/li&gt;
&lt;li&gt;Performed a case study using WalnutDSA signature verification, developed by
SecureRF. Saw a 3x speedup with crypto extensions vs without crypto
extensions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-risc-v-as-a-security-processor-for-darpa-chips-and-commercial-iot-mark-beal:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Using RISC-V as a security processor for DARPA CHIPS and Commercial IoT: Mark Beal&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This talk is about leveraging RISC-V to deliver integrated hw/sw silicon IP.&lt;/li&gt;
&lt;li&gt;The Intrinsix secure execution environment contains a tiny RISC-V core,
crypto engines, secure fabric, as well as software.&lt;/li&gt;
&lt;li&gt;Add a security CPU to provide an isolated execution environment. It&amp;rsquo;s easier
to verify the separation between secure and non-secure actions. Costs less
than 1% of silicon area (20K gates).&lt;/li&gt;
&lt;li&gt;Implement RV32IC with machine and user modes. 2-stage pipeline with a local
ROM And RAM. The IRAM can only hold signed code, is fetch-only, and is locked
after authentication.&lt;/li&gt;
&lt;li&gt;Security RV32 runs signed firmware in user mode, and only executes from
hardwired ROM in machine mode.&lt;/li&gt;
&lt;li&gt;Suppose you have Zephyr running on Rocket, using TinyCrypt as the crypto
API. Replace TinyCrypt on Rocket with a call to an API running on the Secure
RV32.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;isa-formal-task-group-update-rishiyur-nikhil:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;ISA Formal Task Group Update: Rishiyur Nikhil&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A formal spec is a key requirement to be able to definitively answer
questions about compiler correctness and implementation correctness. e.g. will
executing this RISC-V program on this implementation produce correct results?&lt;br /&gt;
For all RISC-V programs?&lt;/li&gt;
&lt;li&gt;Clifford Wolf has demonstrated the value of formal spaces in identifying
bugs in most publicly available RISC-V implementations.&lt;/li&gt;
&lt;li&gt;The formal spec must be clear and understandable to the human reader,
precise and complete, machine readable, executable, and usable with a variety
of formal tools.

&lt;ul&gt;
&lt;li&gt;English-text specs and instruction set simulators can be regarded as
specs, but typically do not meet many of these goals.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Our approach is to use a very minimal subset of Haskell to define a spec
that is directly executable in Haskell. Then provide parsers to connect to
other formal tools and formats.&lt;/li&gt;
&lt;li&gt;See the current prototype
&lt;a href=&#34;https://github.com/mit-plv/riscv-semantics&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Done: RV32I/RV64I, M, priv spec M. Currently ignoring memory model issues.
Soon want to implement privilege spec supervisor mode, then A, C, F, D,
integration with the memory model.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;strong-formal-verification-for-risc-v-adam-chlipala:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Strong formal verification for RISC-V: Adam Chlipala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Simplify: start by proving a shallow property, proving some straight-forward
invariants.&lt;/li&gt;
&lt;li&gt;Simplify: analyze isolated components and build larger components by
composing them.&lt;/li&gt;
&lt;li&gt;Want to avoid starting over for each design. Instead prove a property once
for all parameters.&lt;/li&gt;
&lt;li&gt;Kami is a framework to support implementing, specifying, formally verifying,
and compiling hardware designs. It is based on the Bluespec high-level
hardware design language and the Coq proof assistant.&lt;/li&gt;
&lt;li&gt;The big ideas (from Bluespec):

&lt;ul&gt;
&lt;li&gt;Program modules are objects with mutable private state accessed via
methods.&lt;/li&gt;
&lt;li&gt;Every method call appears to execute atomically. So any step is summarized
by a trace of calls.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Object refinement is inclusion of all possible traces.&lt;/li&gt;
&lt;li&gt;Composing objects hides internal method calls.&lt;/li&gt;
&lt;li&gt;Use standard Coq ASCII syntax for mathematical proofs. These are checked
automatically, just like type checking. Also benefit from streamlined IDE
support for Coq.&lt;/li&gt;
&lt;li&gt;Implement a design, which can be refined to check it against the spec (Coq
tactics are used to prove the refinements). The design is also used to
generate the RTL.&lt;/li&gt;
&lt;li&gt;We are building a translator for the formal RISC-V ISA spec into the
language of Coq/Kami.&lt;/li&gt;
&lt;li&gt;Building an open library of formally verified components. Built a
microcontroller-class RV32I. Working on desktop-class RV64IMA. Also have a
cache-coherent memory system.&lt;/li&gt;
&lt;li&gt;Reuse our proofs when composing our components with your own formally
verified accelerators.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;grvi-phalanz-update-jan-gray:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;GRVI Phalanz Update: Jan Gray&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The industry is looking to FPGAs to help accelerate cloud workloads.&lt;/li&gt;
&lt;li&gt;Software challenge is how to map you multithreaded C++ app to your
accelerator. On the hardware side, you want to avoid endless tapeouts as you
tweak your algorithm.&lt;/li&gt;
&lt;li&gt;GRVI Phalanx Accelerator Kit is a parallel processor overlay for
software-first accelerators. Recompile your application and run on hundreds of
RISC-V cores.&lt;/li&gt;
&lt;li&gt;GRVI: FPGA-efficient RISC-V processing element. No CSRs or exceptions, but
does implement mul and lr/sc.

&lt;ul&gt;
&lt;li&gt;3-stage pipeline with some resources shared by a pair of cores. Fits in
320 LUTs.&lt;/li&gt;
&lt;li&gt;Take 8 of these and connect to form a cluster (8PEs, shared RAM). Takes
approximately 3500 LUTs.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Compose cores using message passing on the FPGA-optimised Hoplite NoC.&lt;/li&gt;
&lt;li&gt;Use a partitioned global address space (PGAS).&lt;/li&gt;
&lt;li&gt;Phalanx: fabric of clusters of PEs, memories, IOs&lt;/li&gt;
&lt;li&gt;FPGAs used in the AWS F1 are huge, over 1.3M LUTs. Last December, fit 1680
RISC-V cores on that FPGA. 250MHz, 420GIPS, 2.5TB/s cluster memory bandwidth,
&amp;hellip;&lt;/li&gt;
&lt;li&gt;Working on a GRVI Phalanx SDK. Bridge the Phalanx and AX4 system interfaces
with message passing bridges.&lt;/li&gt;
&lt;li&gt;8-80 cores on the Pynq.&lt;/li&gt;
&lt;li&gt;Can fit 884 cores on the FPGA on the F1 with 3 DDR controllers, 1240 with 1
DDR controller.&lt;/li&gt;
&lt;li&gt;Currently program using bare metal multithreaded C++ and message. Working on
an OpenCL-based solution. Use the new &amp;lsquo;SDAccell for RTL&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;SDK coming, allowing 8-80-800-10000 core designs. All enabled by the
excellent RISC-V ecosystem.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-tightly-coupled-light-weight-neural-network-processing-unit-with-risc-v-core-lei-zhang:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;A tightly-coupled light-weight neural network processing unit with RISC-V Core: Lei Zhang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Neural networks can be used to replace computation-intensive but
error-resilient code.&lt;/li&gt;
&lt;li&gt;Connected a tightly-coupled neural accelerator to a Rocket core through the
RoCC interface.&lt;/li&gt;
&lt;li&gt;Extended the instruction set. Added NPE instructions for neural accelerator
initialisation and invocation. Also DMA instructions for data initialization
in a buffer. Finally, AGU instructions for data streaming from buffer to
processing elements.&lt;/li&gt;
&lt;li&gt;The Neural Accelerator is a one-dimensional systolic array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lacore-a-risc-v-based-linear-algebra-accelerator-for-soc-designs-samuel-steffi:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Lacore: A RISC-V based linear algebra accelerator for SoC designs: Samuel Steffi&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linear algebra is a foundation of high performance computing.&lt;/li&gt;
&lt;li&gt;Most HPC apps can be reduced to a handful of computation classes:
sparse/dense linear algebra, FFT, structured/unstructured grids. These all
have overlap with linear algebra.&lt;/li&gt;
&lt;li&gt;LACore targets a wide range of applications and tries to overcome hardware
issues of other approaches (GPU, fixed-function accelerators).&lt;/li&gt;
&lt;li&gt;Five main pieces in the LACore additions to the scalar SCPU

&lt;ul&gt;
&lt;li&gt;LAExecUnit: mixed-precision systolic datapath connected to LAMemUnits with
FIFOs. 3 inputs and 1 output, dual precision (32 and 64-bit). Datapath
consists of a vector unit and a reduction unit.&lt;/li&gt;
&lt;li&gt;LAMemUnits: read and write data-streams to the datapath FIFOs and
LACache/Scratchpad. Can read or write scalars, vectors, matrices, and sparse
matrices.&lt;/li&gt;
&lt;li&gt;LAcfg provides configuration to LAMemUnits. These registers hold all info
about data-stream type, precision, location etc.&lt;/li&gt;
&lt;li&gt;64kb scratchpad (3r1w).&lt;/li&gt;
&lt;li&gt;64kb LACache with 4 ports (3r1w) and 16 banks&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Adding 68 new instructions, broadly split into 3 classes: configuration,
data movement, and execution.&lt;/li&gt;
&lt;li&gt;The LACoreAPI allows the accelerator to be programmed.&lt;/li&gt;
&lt;li&gt;Started by implementing in gem5. This was ~25kloc of C++ and Python.&lt;/li&gt;
&lt;li&gt;Implemented the HPC Challenge (HPCC) benchmark suite. Compared versus a
in-order RISC-V core, superscalar x86 core with SSE2, and equivalent Fermi GPU
with 2 streaming multiprocessors. LACore saw a speedup of 3.43x over x86,
10.72x vs baseline RISC-V, and 12.04 vs the GPU baseline.&lt;/li&gt;
&lt;li&gt;Estimated area is only 2.53x the area of a single RISC-V scalar CPU and
0.60x the area of the equivalent GPU.&lt;/li&gt;
&lt;li&gt;Freely available &lt;a href=&#34;https://github.com/scale-lab/la-core&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Currently working a LACore multi-core design and evaluation, as well as an
ASIC implementation and eventual tapeout.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;packet-manipulation-processor-a-risc-v-vliw-core-for-networking-applications-salvatore-pontarelli:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Packet manipulation processor. A RISC-v VLIW core for networking applications: Salvatore Pontarelli&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Network &amp;ldquo;softwareization&amp;rdquo; is seen as the optimal solution to design next
generation network infrastructures, services, and applications.&lt;/li&gt;
&lt;li&gt;Want high speed: 100-200Gbps (as achievable with FPGAs and network
processors) and beyond, 5Tbps as achievable with programmable forwarding
dataplanes.&lt;/li&gt;
&lt;li&gt;Propose an architecture where programmable forwarding dataplanes are
augmented with a PMP (packet manipulation processor)&lt;/li&gt;
&lt;li&gt;Design a small, efficient CPU for packet manipulation. Deploy the PMP at the
output port. Want to process packets at 10/40Gbps.&lt;/li&gt;
&lt;li&gt;Possible programmable actions: inband packet reply, custom tunneling,
NAT/PNAT.&lt;/li&gt;
&lt;li&gt;The PMP has a small instruction memory (typically need less than 8K
instructions). Small data memory (8KB). Flat memory, no cache hierarchy.&lt;/li&gt;
&lt;li&gt;PMP throughput: 10Gbps is 14.88Mpps, 67 clock cycles at 1GHz. A multi-core
CPU is one approach, but has challenges regarding the reordering of packets.
Pursue a VLIW solution instead.&lt;/li&gt;
&lt;li&gt;The PMP is a static 8-issue VLIW RISC-V core with the RV32I instruction set.
Has a 32-bit dataplane (to be upgraded). Written in VHDL. Features branch
prediction, lane forwarding.&lt;/li&gt;
&lt;li&gt;Implemented in a NetFPGA based programmable dataplane.&lt;/li&gt;
&lt;li&gt;Synthesized at 250MHz on FPGA.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;adding-a-binarized-cnn-accelerator-to-risc-v-for-person-detection-guy-lemieux:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Adding a Binarized CNN Accelerator to RISC-V for Person Detection: Guy Lemieux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This talk uses VectorBlox Vector instructions, which are not the same as the
vector instructions proposed in the RISC-V vector working group.&lt;/li&gt;
&lt;li&gt;Prototyped in the Lattice iCE40 UltraPlus FPGA (5280 LUTs, 1Mb SRAM).&lt;/li&gt;
&lt;li&gt;Inspired by BinaryConnect. Built a custom database, performed other
optimisations, and managed 98% accuracy.&lt;/li&gt;
&lt;li&gt;Use Orca (open source, BSD licensed). Written in VHDL, 200MHz fully
pipelined, less than 2000 4LUTs.&lt;/li&gt;
&lt;li&gt;Added streaming vector extensions and binary CNN accelerator.&lt;/li&gt;
&lt;li&gt;The streaming vector instructions (SVE) operate only on stream memory. Add
streaming version of all the base RV32 integer operations, multiply
instructions. Add in some extra instructions such as mov, conditional move,
comparisons, and vector control instructions. Packed SIMD can be supported
naturally with this approach to vectors.&lt;/li&gt;
&lt;li&gt;Would also like to add an extra SVE extension for DMA.&lt;/li&gt;
&lt;li&gt;SVE has a base 32-bit encoding, as well an extended 64-bit encoding.&lt;/li&gt;
&lt;li&gt;Can redirect the data to a domain-specific streaming pipeline.&lt;/li&gt;
&lt;li&gt;4852 4-input LUTs for the whole solution.&lt;/li&gt;
&lt;li&gt;Releasing the VectorBlox instruction set as an open specification, and
joining the RISC-V vector working group to discuss it as a potential
alternative.&lt;/li&gt;
&lt;li&gt;SVE vs the RISC-V vector extension

&lt;ul&gt;
&lt;li&gt;A &amp;ldquo;memory-to-memory&amp;rdquo; architecture, challenging the conventional wisdom of
RISC.&lt;/li&gt;
&lt;li&gt;No named vector registers in the ISA (no register allocation, no compiler
changes needed)&lt;/li&gt;
&lt;li&gt;High performance. Free loop unrolling, no saving/restoring of vector data.&lt;/li&gt;
&lt;li&gt;No storage wasted with streaming memory. Free software scratchpad if
vectors aren&amp;rsquo;t used.&lt;/li&gt;
&lt;li&gt;Easier/simpler hardware. Double-buffered DMA instead of prefetching +
vector register renaming.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc5-improving-support-for-risc-v-in-gem5-alex-roelke:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;RISC5. Improving support for RISC-V in gem5: Alex Roelke&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;gem5 is a popular cycle approximate simulator, which can be very useful in
RISC-V hardware development.&lt;/li&gt;
&lt;li&gt;RISC-V in gem5 supports RV64GC. It uses syscall emulation and doesn&amp;rsquo;t yet
support the privileged ISA.&lt;/li&gt;
&lt;li&gt;Implemented the release consistency memory model for atomics.&lt;/li&gt;
&lt;li&gt;Floating point support was verified against spike and a hardware design.&lt;/li&gt;
&lt;li&gt;The main challenge when implementing the compressed instruction was
interfacing with gem5&amp;rsquo;s existing decode logic.&lt;/li&gt;
&lt;li&gt;In the future, want to support multithreaded workloads in syscall emulation
mode, enable full system mode (privileged ISA), and correct minor differences
(e.g. floating point rounding).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;renode-a-flexible-open-source-simulation-for-risc-v-system-development-michael-gielda:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Renode. A flexible open-source simulation for RISC-V system development: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;AntMicro was founded in 2009 and has been developing Renode since 2010.&lt;/li&gt;
&lt;li&gt;Why did we build Renode? Observed data workflows for embedded development.
Needed a fast simulator for software developers, as close to production as
possible. Must support multi-node simulation, easy reuse of models, and be
extensible.&lt;/li&gt;
&lt;li&gt;It is an instruction set simulator, mostly written in C#. It supports fully
deterministic execution, transparent debugging, integration with familiar
tools (e.g. GDB).&lt;/li&gt;
&lt;li&gt;Renode is open source, has a flexible structure and is constructed out of
modular building blocks.&lt;/li&gt;
&lt;li&gt;The platform description format is human readable, modular, and extendible.&lt;/li&gt;
&lt;li&gt;Worked with Microsemi to support the Mi-V platform, integrate with
SoftConsole IDE, and support Windows as a first-class platform.&lt;/li&gt;
&lt;li&gt;Renode supports a range of handy features, such as fault injection,
record/replay, and more.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;qemu-based-hardware-modelling-of-a-multi-hard-risc-v-soc-daire-mcnamara:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;QEMU-based hardware modelling of a multi-hard RISC-V SoC: Daire McNamara&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Wanted to explore have separate execution contexts on the same SoC that are
free from interference (e.g. one core running an RTOS, while others run a
general purpose OS).&lt;/li&gt;
&lt;li&gt;In the SiFive Unleashed platform, the E51 provides services for other U54
harts.&lt;/li&gt;
&lt;li&gt;E51 services/peripheral drivers are implemented as event-driven state
machines. These are describes via a structure and states are named.&lt;/li&gt;
&lt;li&gt;Needed an emulator to model all of this.&lt;/li&gt;
&lt;li&gt;Modified RISC-V QEMU:

&lt;ul&gt;
&lt;li&gt;Updated privileged spec support.&lt;/li&gt;
&lt;li&gt;Hart synchronisation (IPIs)&lt;/li&gt;
&lt;li&gt;Modelling physical memory protection&lt;/li&gt;
&lt;li&gt;PLIC, CLINT, local interrupts&lt;/li&gt;
&lt;li&gt;Support for managing contexts of multiple harts&lt;/li&gt;
&lt;li&gt;Modelling L1/L2 cache configuration register writes/reads&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;U54-MC QEMU hasn&amp;rsquo;t yer been upstreamed to the main RISC-V QEMU github repo
yet.&lt;/li&gt;
&lt;li&gt;Can boot Linux to console and interact, but it&amp;rsquo;s a little slow (takes about
15 minutes).&lt;/li&gt;
&lt;li&gt;Future plans: improve speed, add vectorisation for local interrupts, device
tree support, QOM, remote control of real hardware. Finally, clean up and
upstream.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;firesim-cycle-accurate-rack-scale-system-simulation-using-fpgas-in-the-public-cloud-sagar-karandikar:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;FireSim. Cycle-Accurate Rack-Scale System Simulation using FPGAs in the Public Cloud: Sagar Karandikar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why simulate datacenters? Next-gen datacenters won&amp;rsquo;t be built only from
commodity components, and custom hardware is changing faster than ever.&lt;/li&gt;
&lt;li&gt;Our simulator needs to model hardware at scale (CPUs down to
microarchitecture, fast networks and switches, novel accelerators), run real
software, and be usable.&lt;/li&gt;
&lt;li&gt;One way to test would be to build the hardware, get the chips back, then
network together into a datacenter. This has obvious disadvantages.&lt;/li&gt;
&lt;li&gt;Alternatively, use a software simulator. Easy to prototype new hardware this
way, but also easy to model something that you can&amp;rsquo;t build. Additionally, it
can be very slow to run, requiring the use of small microbenchmarks or
sampling.&lt;/li&gt;
&lt;li&gt;Or, build a hardware-accelerated simulator (see DIABLO). You need to
hand-write RTL models, which in many ways is harder than &amp;ldquo;tapeout-ready&amp;rdquo; RTL.&lt;/li&gt;
&lt;li&gt;How do we improve? Harness useful hardware trends such as the open RISC-V
SoC, open silicon designs, high productivity hardware design languages
(Chisel), FPGAs in the cloud.&lt;/li&gt;
&lt;li&gt;FireSim target design: server blades, each with quad-core RISC-V Rocket at
3.2GHz, 16KiB I+D cache, 256KiB L2, 16Gb DRAM, 200Gbps Ethernet NIC, optional
accelerators. The network has parameterisable bandwidth/link latency and a
configurable topology.&lt;/li&gt;
&lt;li&gt;Transform the RTL to simulate on the FPGA. For the network simulation, use
CPUs and the host network (one thread per port).&lt;/li&gt;
&lt;li&gt;FAME-1 transforming RTL: given RTL, want to automatically transform it into
decoupled cycle-accurate simulator RTL that we can run on the FPGA.&lt;/li&gt;
&lt;li&gt;Can pack four quad-core server simulations per FPGA, meaning 32 server
simulations per f1.16xlarge (128 simulated cores). Use a 32-port 200Gbps
per-port top of rack switch model. The simulation runs at 5MHz (~400 million
instructions/second). $13.20/hr on-demand, ~$2.60/hr on the spot market.&lt;/li&gt;
&lt;li&gt;Can scale to simulating a 1024 node RISC-V datacenter. Ran across 32
f1.16xlarge instances. In aggregate, runs at 3.4MHz (13 billions insts/s
across the simulated datacenter).&lt;/li&gt;
&lt;li&gt;Can also achieve &amp;ldquo;functional&amp;rdquo; network simulation. e.g. allowing all of
SPECInt06-ref to run on Rocket Chip at 150MHz (completing in less than one
day).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Seventh RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-one</link>
      <pubDate>Tue, 28 Nov 2017 15:16:45 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2017/10/7th-risc-v-workshop-agenda/&#34;&gt;seventh RISC-V
workshop&lt;/a&gt; is going
on today and tomorrow at Western Digital in Milpitas. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;p&gt;Follow &lt;a href=&#34;http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-two&#34;&gt;here&lt;/a&gt; for the
day two live blog.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Introduction: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Workshop is sold out, 498 attendees registered representing 138 companies
and 35 universities.&lt;/li&gt;
&lt;li&gt;There will be 47 sessions squeezed into 12 and 24 minute increments, plus 26
poster / demo sessions.&lt;/li&gt;
&lt;li&gt;The 8th RISC-V workshop will be held on May 7th-10th at the Barcelona
Supercomputing Center and Universitat Politecnica de Catalunya.&lt;/li&gt;
&lt;li&gt;Rick gives a refresher on the structure of the RISC-V Foundation.&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation now has only 100 members (including individual
members).&lt;/li&gt;
&lt;li&gt;We&amp;rsquo;re on a &lt;em&gt;tight&lt;/em&gt; schedule today. No applause and no questions!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-state-of-the-union-krste-asanovic:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V state of the union: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Krste gives a rapid overview of the RISC-V ISA.&lt;/li&gt;
&lt;li&gt;RISC-V aims to be simple, clean-slate, modular, and stable.&lt;/li&gt;
&lt;li&gt;RISC-V started in May 2010. v1.0 of the ISA came in 2011, first Rocket
tapeout in 2012, first Linux port in 2013, v2.0 (frozen) IMAFD spec in 2014.
First commercial softcores and first commercial SoC in 2017.&lt;/li&gt;
&lt;li&gt;Large companies are adopting RISC-V for deeply embedded controllers in their
SoCs (&amp;ldquo;minion cores&amp;rdquo;), replacing home-grown and commercial cores.

&lt;ul&gt;
&lt;li&gt;[Editor&amp;rsquo;s note: pleasing to see the &amp;ldquo;minion core&amp;rdquo; name take off around the
wider RISC-V community!].&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Small and proprietary-ISA soft-core IP companies are switching to the RISC-V
standard to access a larger market. &amp;ldquo;If you&amp;rsquo;re a softcore IP provider, you
should have a RISC-V product in development&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;RISC-V has seen government adoption, e.g. India adopted it as a national
ISA. A recent security-focused DARPA project standardised on RISC-V. Israel
Innovation Authority are creating the GenPro platform around RISC-V.&lt;/li&gt;
&lt;li&gt;Many startups are choosing RISC-V for new products. &amp;ldquo;We haven&amp;rsquo;t had to tell
startups about RISC-V; they find out about it very quickly when shopping for
processor IP&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Commercial ecosystem providers: starting to see mainstream commercial
support. &amp;ldquo;Demand is driving supply in the commercial ecosystem&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;RISC-V in academic research: becoming the standard ISA for academic
research. There will be talks at the workshop about the Celerity 500 RISC-V
core SoC in 16nm FinFET, and FireSim which models 1024 quad-core RISC-V
servers in the cloud.

&lt;ul&gt;
&lt;li&gt;The CARRV RISC-V workshop at MICRO was even better attended than the
machine learning workshop.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Expect in a few years time that the vast majority of undergraduates will be
taught RISC-V at University.&lt;/li&gt;
&lt;li&gt;Racepoint Global have been hired for Foundation marketing.&lt;/li&gt;
&lt;li&gt;RISC-V Technical Roadmap for 2017:

&lt;ul&gt;
&lt;li&gt;Primary goal was to formally standardise the base ISA, resolve issues with
the memory model, debug, and stabilize the privileged architecture.&lt;/li&gt;
&lt;li&gt;Good progress has been made, but the spec hasn&amp;rsquo;t yet been ratified. One of
the issues is differentiating the base spec versus clarifications for
different &amp;ldquo;profiles&amp;rdquo;. There is no plan to change any instruction
specification versus 2.0.&lt;/li&gt;
&lt;li&gt;The Unix platform is stable as of the privileged 1.10 spec (i.e. no
backwards incompatible changes from now on).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ISA specifications and profiles

&lt;ul&gt;
&lt;li&gt;The original ISA specs mixed instruction specifications with platform
mandates. Now work is ongoing to separate instruction set specifications
from platform profiles.&lt;/li&gt;
&lt;li&gt;Instruction set specifications should be maximally reusable, while the
profiles should be as constrained as possible to simplify software
compatibility.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Single-letter names will run out some day, so a proposal has been made to
allow finer-grained naming of instruction sets to describe profiles. Use Zxxxx
to name standard instruction extensions (while Xyyyyy is used for non-standard
instruction extensions). See the isa-dev list for more information.&lt;/li&gt;
&lt;li&gt;Profiles for software compatibility. A software ABI/SBI defines a profile.
A software ABI/SBI defines a profile. Also need profiles M-mode-only
microcontrollers, and MU-mode microcontrollers, and for booting MSU platforms.
Aim for have first ready in Q12018.&lt;/li&gt;
&lt;li&gt;Memory model: the original was too weak for C11 and underspecified, but a
team of experts have come together over the past year to resolve the issues.
RVWMO is the base memory model and is weak, while RVTSO is an optional
extension providing a strong TSO memory model.&lt;/li&gt;
&lt;li&gt;Calling convention and ABI has been stabilized and documented.&lt;/li&gt;
&lt;li&gt;GCC and binutils have been upstreamed and released in GCC. LLVM upstream is
in progress.&lt;/li&gt;
&lt;li&gt;A number of other compilers and languages are now available. e.g. CompCert,
Go, Rust, OCaml, Jikes JVM, OpenJDK, &amp;hellip;&lt;/li&gt;
&lt;li&gt;The Linux port has been accepted upstream for the 4.15 release.
Additionally, the hypervisor spec has been released (designed to support
recursive virtualisation using an enhanced S mode).&lt;/li&gt;
&lt;li&gt;Run-halt debug going well, is being targeted by commercial vendors.&lt;/li&gt;
&lt;li&gt;2017 summary: All planned major technical decisions settled, some more work
on the ratification process is needed.&lt;/li&gt;
&lt;li&gt;Technical roadmap goals for 2018:

&lt;ul&gt;
&lt;li&gt;Complete ratification of base ISA and first profiles&lt;/li&gt;
&lt;li&gt;Base vector extensions proposed and ratified&lt;/li&gt;
&lt;li&gt;Hypervisor implemented, spec ratified&lt;/li&gt;
&lt;li&gt;Formal spec completed and released&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector: see the talk from Roger. Aim to be the Best Vector ISA Ever &amp;trade;.&lt;/li&gt;
&lt;li&gt;Security: really two separable efforts in the foundation: trusted execution
environments and cryptographic instruction extensions. Also a huge amount of
other work in the academic community.&lt;/li&gt;
&lt;li&gt;Interrupts: currently have fast local interrupts and global platform-level
interrupts. Also have requests for high end systems who want per-hart
message-signal interrupts (MSI) and from low-end embedded that want
pre-emptive vectored prioritized interrupts.&lt;/li&gt;
&lt;li&gt;Improving embedded compression: the C extension was designed for general
purpose computing with Unix binaries. People are seeing non-competitive RISC-V
code size on pure embedded workloads, like due to lack of byte/halfword memory
access? Considering an alternative C extension for RV32E systems.&lt;/li&gt;
&lt;li&gt;A new task group has been up for the &amp;lsquo;J&amp;rsquo; extension, exploring support for
dynamically translated languages. Looking at issues like integer overflow,
garbage collection, and instruction cache management.&lt;/li&gt;
&lt;li&gt;Summary

&lt;ul&gt;
&lt;li&gt;Very rapid development and adoption &amp;ldquo;by the time you decide to do a
project, support will be there&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Question: does the foundation have any formal ways of addressing IP
challenges? Answer: have been documenting prior art for the base ISA
instructions. Would be good to continue to expand this to cover reference
hardware implementations.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-hypervisor-extension-andrew-waterman:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V Hypervisor Extension: Andrew Waterman&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Presenting work with extensive contributions from Paolo Bonzini and John
Hauser&lt;/li&gt;
&lt;li&gt;Goal is to virtualize S-mode to support running guest OSes under Type-1,
Type-2 and hybrid hypervisors. Also want to be high performance and to support
recursive virtualisation.&lt;/li&gt;
&lt;li&gt;The hypervisor extension adds new privileged modes. S-mode becomes HS-mode,
and we also add the Virtualised Supervisor (VS) and Virtualized User (VU)
modes.&lt;/li&gt;
&lt;li&gt;What needs to be virtualized? Supervisor architecture state (CSRs), memory,
I/O and interrupts.&lt;/li&gt;
&lt;li&gt;Additional copies of most supervisor CSrs are provisioned as background
supervisor CSRs, e.g. bsscratch, bsepc. In HS-mode, foreground CSRs contain
S-mode state and background CSRs contain inactive VS-mode state. These are
swapped in VS-mode.&lt;/li&gt;
&lt;li&gt;Use two-level address translation to virtualize memory. Original virtual
addresses are translated to guest physical addresses by the VS-level page
table, and then guest physical addresses are translated to machine physical
addresses by the HS-level page table.

&lt;ul&gt;
&lt;li&gt;Page table entry formats and page table layouts are the same as S-mode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Software and timer interrupts are easy to virtualise, as they&amp;rsquo;re already
exposed via the SBI. The two-level paging scheme can be used to trap MMIO
accesses.

&lt;ul&gt;
&lt;li&gt;Could avoid extra traps into the hypervisor with a virtualisation-aware
PLIC. This is considered a platform issues, outside of the scope of the
hypervisor ISA.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need an I/O MMU to initiated DMAs without trap into the hypervisor - also a
platform issue.&lt;/li&gt;
&lt;li&gt;The hypervisor extension is designed to be efficiently emulatable on M/S/U
systems with traps into M-mode.&lt;/li&gt;
&lt;li&gt;Specification v.01 is &lt;a href=&#34;https://github.com/riscv/riscv-isa-manual&#34;&gt;available on
GitHub&lt;/a&gt;. Hoping to implement in
Spike in Q1 2018.&lt;/li&gt;
&lt;li&gt;Want to see a silicon implementation prior to ratification.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-memory-consistency-model-status-update-dan-lustig:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V memory consistency model status update: Dan Lustig&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The goal was to define the RISC-V memory consistency model (&amp;ldquo;specifies the
values that can be returned by loads&amp;rdquo;). Support a wide range of hardware
implementations, as well as Linux, C/C++ and lots of other critical software.&lt;/li&gt;
&lt;li&gt;The fundamental debate was about strong models (such as x86-TSO) vs weak
models (ARM, IBM Power). Strong models have stricter ordering rules, resulting
in something that&amp;rsquo;s simpler for programmers and for architects. Weak models
have more relaxed ordering rules, better performance/power/area and more
microarchitectural freedom.&lt;/li&gt;
&lt;li&gt;In order to find a compromise, defined RVTSO (strong) and RVWMO (weak).

&lt;ul&gt;
&lt;li&gt;Both are multi-copy atomic. This means cores are allowed to peek at stores
they have issues as long as they haven&amp;rsquo;t been observed by anyone else and is
much simpler to reason about than the Power and ARMv7 memory models.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The base RISC-V memory model is RVWMO (software must assume this if it wants
to be portable). It&amp;rsquo;s important to note that a hardware implementation meeting
the RVWMO specification could be more conservative (stronger). Additional have
the Ztso extension for RVTSO, which software might target.&lt;/li&gt;
&lt;li&gt;RVWMO and RVTSO differ in the degree of memory access reordering they permit
at the point of global visibility. In RVTSO, only store-to-load reordering can
be observed. In RVWMO, most memory accesses can be reordered freely unless
synchronized via .sq, .rl and/or fences.&lt;/li&gt;
&lt;li&gt;Dan has some handy diagrams that explain the RVWMO and RVTSO rules in a
nutshell, which you should be able to study once the slides become available.&lt;/li&gt;
&lt;li&gt;Software written for RVWMO will run on all RISC-V hardware (RVWMO and Ztso).
RVTSO-only software can be be written, but will only run on hardware
implementing Ztso. A flag in the ELF header will be used to ensure this.&lt;/li&gt;
&lt;li&gt;If you don&amp;rsquo;t want to think about memory models, just use the standard OSes
and toolchains. If you care about PPA or flexibility, use RVWMO. If you have
lots of legacy x86 code, use hardware implementing Ztso so that any software
will work. If you believe TSO is the future, use hardware with Ztso and emit
code with the TSO-only magic number.&lt;/li&gt;
&lt;li&gt;Fragmentation due to the presence of two memory models is an obvious risk.
Try to discourage software from targeting both, and encourage targeting RVWMO
wherever possible (redundant fences simple become no-ops).&lt;/li&gt;
&lt;li&gt;There have been a number of other ISA changes. ld.rl and sd.aq are
deprecated. ld.aqrl and sd.aqrl mean RCsc. Also clarified other subtleties.
May have future extensions to the fence instruction, and .aq/.rl variants for
byte and halfword-size loads/stores.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-enabling-a-new-era-of-open-data-centric-computing-architectures-martin-fink:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V - Enabling a new era of open data-centric computing architectures: Martin Fink&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Most people think of Western Digital as a storage company, but actually
they&amp;rsquo;re a &lt;em&gt;data&lt;/em&gt; company.&lt;/li&gt;
&lt;li&gt;Big data is well known, but increasingly there are applications that require
&amp;ldquo;fast data&amp;rdquo; (immediate access to information).&lt;/li&gt;
&lt;li&gt;Big data applications have historically focused on general purpose compute.
But we need to be able to move beyond general purpose compute to meet new
application requirements.&lt;/li&gt;
&lt;li&gt;In a general purpose compute architecture, everything is centered around the
CPU rather than the data.&lt;/li&gt;
&lt;li&gt;Workload diversity demands diverse technologies and architectures, both for
&amp;ldquo;big data&amp;rdquo; and &amp;ldquo;fast data&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;There are a wide range of data-centric applications at the edge.&lt;/li&gt;
&lt;li&gt;RISC-V meets the needs of big data (move compute to data) and fast data
(memory centric compute). It enables purpose-built environments for big data
and fast data applications.&lt;/li&gt;
&lt;li&gt;Western Digital ships in excess of 1 billion cores per year, and expect to
double that. They are making a commitment to transition all of those 1 billion
cores towards RISC-V, across their whole product portfolio.&lt;/li&gt;
&lt;li&gt;Want to process the data where it lives, which RISC-V will help to enable.&lt;/li&gt;
&lt;li&gt;Represents a new style of development. In some cases, WD may develop their
own cores, in others may buy them, in others may partner with another company
to co-develop them.&lt;/li&gt;
&lt;li&gt;Western Digital will work to accelerate the RISC-V ecosystem:

&lt;ul&gt;
&lt;li&gt;Support the development of open source IP building blocks for the
community&lt;/li&gt;
&lt;li&gt;Actively partner and invest in the ecosystem&lt;/li&gt;
&lt;li&gt;Accelerate development of purpose-built processors for a broad range of
Big Data and Fast Data environments&lt;/li&gt;
&lt;li&gt;Multi-year transition of Western Digital devices, platforms and systems to
RISC-V purpose built architectures&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;First device from WD with a RISC-V core is likely to not ship until late
2019 to early 2020.&lt;/li&gt;
&lt;li&gt;Summary

&lt;ul&gt;
&lt;li&gt;Big Data and Fast Data need purpose-built environments&lt;/li&gt;
&lt;li&gt;Openness and ecosystem enable best-in-class innovation. The motivation is
enabling innovation, &lt;em&gt;not&lt;/em&gt; reducing cost.&lt;/li&gt;
&lt;li&gt;Western Digital brings the momentum of over 1B cores per year&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;industrial-strength-high-performance-risc-v-processors-for-energy-efficient-computing-dave-ditzel:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Industrial-strength high-performance RISC-V processors for energy-efficient computing: Dave Ditzel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coming out of &amp;ldquo;stealth mode&amp;rdquo; in this talk.&lt;/li&gt;
&lt;li&gt;Chris Celio is joining Esperanto, but will continue to maintain and support
BOOM. Esperanto will also be implementing even higher performance out-of-order
processors.&lt;/li&gt;
&lt;li&gt;Esperanto have been pursuing an implementing of the draft Vector ISA in
order to understand design trade-offs.&lt;/li&gt;
&lt;li&gt;RISC-V is off to a great start, but many in industry view RISC-V as a
curiosity or toy, only for low end. Repeatedly see questions about high-end
designs (in Verilog!), graphics, machine learning, or HPC applications.&lt;/li&gt;
&lt;li&gt;See Esperanto as complementing existing core vendors, &amp;ldquo;expanding RISC-V&amp;rsquo;s
piece of the pie&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Experanto is designing a high-performance RISC-V core comparable to the best
IP alternatives. It is designing an energy-efficient RISC-V core for high
TeraFLOP computing needs. The goal is to make RISC-V more compelling than the
other high-end alternatives.&lt;/li&gt;
&lt;li&gt;Will produce IP with human readable, synthesizable Verilog.&lt;/li&gt;
&lt;li&gt;Esperanto is building the highest TeraFLOPS per Watt machine learning
computing system, and it will be based on the RISC-V ISA&lt;/li&gt;
&lt;li&gt;ET-Maxion will be the highest single thread performance 64-bit RISC-V
processor. Starting from BOOM v2, but expect substantial changes. Optimized
for 7nm CMOS. This will be used in Esperanto&amp;rsquo;s products and made available as
a licensable core.&lt;/li&gt;
&lt;li&gt;Second core is the ET-Minion. This is intended to do all the heavy floating
point work, with very high floating point throughput and energy efficiency.
This will be a 64-bit RISC-V core with vector extensions, an in-order
pipeline, and extra instruction extensions for machine learning. Also have
multiple hardware threads of execution. Like the ET-Maxion, this will be used
in Esperanto products and available as a licensable core.&lt;/li&gt;
&lt;li&gt;Putting these together in a product: Esperanto&amp;rsquo;s AI supercomputer on a chip.
16 64-bit ET-Maxion RISC-V cores with private L1 and L2 caches, 4096 64-bit
ET-Minion RISC-V cores each with their own vector floating point unit,
hardware accelerators, Network on Chip to allow processors to reside in the
same address space, multiple levels of cache, etc.&lt;/li&gt;
&lt;li&gt;Other companies are proposing special purpose hardware for machine learning
using proprietary instruction sets. Esperanto want to base all processing on
RISC-V, adding instruction extensions and hardware accelerators where
necessary.&lt;/li&gt;
&lt;li&gt;Also looked at using RISC-V for graphics. Wrote a shader compiler that can
generate RISC-V compilers, and the code to distribute the workload across
thousands of cores.&lt;/li&gt;
&lt;li&gt;Argue that proprietary, custom instruction sets are a bad choice. Instead,
make general purpose RISC-V processors with domain specific extensions when
needed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;andes-extended-features-dr-chuan-hua-chang:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Andes Extended Features: Dr Chuan-Hua Chang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Andes Technology is a Taiwan-based CPU IP company with over 2 billion
Andes-Embedded SoCs shipped in diverse applications.&lt;/li&gt;
&lt;li&gt;Have extended the RISC-V architecture in the V5m with:

&lt;ul&gt;
&lt;li&gt;Vectored interrupts and priority-based preemptive interrupts for the PLIC&lt;/li&gt;
&lt;li&gt;StackSafe features&lt;/li&gt;
&lt;li&gt;Exception redirection to the debuggers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The V5m ISA includes

&lt;ul&gt;
&lt;li&gt;Andes Perfomance extension&lt;/li&gt;
&lt;li&gt;Optional Andes DSP extension&lt;/li&gt;
&lt;li&gt;Optional Andes Custom extension&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For the vectored PLIC, vector table entry 0 contains exceptions and local
interrupts except &amp;ldquo;external interrupt&amp;rdquo;. Vector table entry 1 and above
contains external interrupts from the PLIC. The PLIC interrupt ID is
transmitted directly from PLIC to a hart.&lt;/li&gt;
&lt;li&gt;The extended PLIC saves over 30 instructions for dispatch and software
preemption overhead.&lt;/li&gt;
&lt;li&gt;StackSafe monitors the SP register value to detect stack pointer overflow
and underflow, and for recording the maximum observed stack size.&lt;/li&gt;
&lt;li&gt;Andes ISA extensions add

&lt;ul&gt;
&lt;li&gt;GP-implied load/store instructions with a larger immediate range.&lt;/li&gt;
&lt;li&gt;Compare an operand with a small constant and branch&lt;/li&gt;
&lt;li&gt;Instructions for zero/sign-extensions&lt;/li&gt;
&lt;li&gt;CoDense: code size compression instructions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The Andes DSP ISA extension features over 130 instructions, using only GPRs.
Introduces a range of SIMD instructions, zero-overhead loops, and 64-bit
signed/unsigned addition and subtractions, and signed/unsigned multiplication
and addition.

&lt;ul&gt;
&lt;li&gt;See 50% cycle reduction for the Helix MP3 decoder, and 80.1% cycle
reduction for the G.729 codec.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Andes Custom Extension (ACE) provides a framework to facilitate custom
instruction design and implementation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;customisation-of-a-risc-v-processor-to-achieve-dsp-performance-gain-marcela-zachariasova:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Customisation of a RISC-V processor to achieve DSP performance gain: Marcela Zachariasova&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Codasip studio is a processor development environment which takes a high
level description of a processor and automatically generates software tool,
RTL, and verification environments.&lt;/li&gt;
&lt;li&gt;Take one of Codasip&amp;rsquo;s Berkelium RISC-V cores as the starting point.&lt;/li&gt;
&lt;li&gt;Configure the core by enabling/disabling ISA extensions as desired. You can
also define new instructions, driven by profiling information.&lt;/li&gt;
&lt;li&gt;Case study: audio processing solution for IoT (developed with Microsemi).&lt;/li&gt;
&lt;li&gt;Ultimately, saw a 13.62x speedup for a 2.43x area overhead vs RV32IM.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;freedom-u500-linux-capable-1-5gh-quad-core-rv64gc-soc-jack-kang:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Freedom U500, Linux-capable, 1.5GH quad-core RV64GC SoC: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Freedom Unleashed 500: 250M+ transistors, TSMC 28nm, high-performance
integrated RISC-V SoC, U54MC RISC-V CPU Core Complex&lt;/li&gt;
&lt;li&gt;1.5GHz+ SiFive E51/U53 CPU. 1xE51 (16KB L1I$, 8KB DTIM), 4 x U54. 32KB L1I$,
32KB L1D$.&lt;/li&gt;
&lt;li&gt;All five cores in a coherent system with 2MB L2$.&lt;/li&gt;
&lt;li&gt;Development board available in Q12018.&lt;/li&gt;
&lt;li&gt;Feature GbE, DDR3/4, and ChipLink (a serialized chip-to-chip TileLink
interconnect).&lt;/li&gt;
&lt;li&gt;The E51 core is a 64-bit, 1.5GHz CPU &amp;ldquo;minion core&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Coherent, 2MB 16-way L2 subsystem.&lt;/li&gt;
&lt;li&gt;Single U54 core-only area 0.224mm2, single U53 core complex area 0.538mm2
(including 32KB/32KB L1 cache). 1.7 DMIPS/MH, 2.75 CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;HiFive Unleashed will have the SiFive Freedom Unleashed 500 SoC connected to
a Microsemi PolarFire FPGA, Provide USB and HDMI via the FPGA, as well as
PCIe. Available Q1&amp;rsquo;2018.&lt;/li&gt;
&lt;li&gt;HiFive Unleashed Early Access Program: give early access to FPGA-based
prototypes (now) and development boards (soon). To get access, email
info@sifive.com.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;revolutionizing-risc-v-based-application-design-possibilities-with-globalfoundries-gregg-bartlett:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Revolutionizing RISC-V based application design possibilities with GlobalFoundries: Gregg Bartlett&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GlobalFoundries is the only foundry that is a RISC-V Foundation member. See
that the RISC-V approach is a good match for GlobalFoundries.&lt;/li&gt;
&lt;li&gt;For the last year, have been engaged in applications where RISC-V processors
are showing up. DNN accelerators, cluster computing, automotive/embedded SoCs,
X86/GPU co-processors.&lt;/li&gt;
&lt;li&gt;Argue foundry technology allows differentiated customer solutions. e.g.
22FDX and 12FDX.&lt;/li&gt;
&lt;li&gt;22FDX is targeted to serve segments such as mobility, IoT, RF, and
automotive.&lt;/li&gt;
&lt;li&gt;FDXcellerator program features multiple RISC-V cores, as well as LPDDR4,
MIPI etc.&lt;/li&gt;
&lt;li&gt;Partnered with SiFive (E31+E51), Reduced Energy Microsystems, Andes, ETH
Zurich / University of Bologna (PULP), Berkeley Labs, IIT Chennai.&lt;/li&gt;
&lt;li&gt;For the SiFive partnership, no cost to customers for E31/E51 cores until
production starts.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-llvm-towards-a-production-ready-llvm-based-toolchain-alex-bradbury:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V LLVM. Towards a production-ready LLVM-based toolchain: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I was the presenter, so no notes right now.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-risc-v-java-update-martin-maas:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;A RISC-V Java update: Martin Maas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Jikes RVM now runs full JDK6 applications, including the Decapo benchmark
suite. Passes the Jikes RVM core test suite. About 15000 lines of code.&lt;/li&gt;
&lt;li&gt;Managed languages have been under-represented in computer architecture
research for quite some time.&lt;/li&gt;
&lt;li&gt;Challenges: long running on many cores, concurrent tasks, fine-grained
interactions. Difficult fit for many common simulation approaches, e.g. Qemu
or Gem5.&lt;/li&gt;
&lt;li&gt;Instead, we can run managed workloads on real RISC-V hardware in FPGA-based
simulation to enable modifying the entire stack.&lt;/li&gt;
&lt;li&gt;By modifying the hardware, we can do fine-grained tracing without perturbing
the software being tested.&lt;/li&gt;
&lt;li&gt;Can explore the interaction with the memory system, e.g. DRAM row misses
encountered during garbage collection.&lt;/li&gt;
&lt;li&gt;This will allow a wide range of research that was difficult without this
infrastructure.&lt;/li&gt;
&lt;li&gt;Have the Jikes Research VM (baseline JIT, no optimising JIT). Can run
OpenJDK Hotspot JVM with the Zero (interpreter) backend, but no
high-performance JIT compiler port yet. Help needed!&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation has launched the J extension working group today, to
better support managed-language support to RISC-V.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;microprobe-an-open-source-microbenchmark-generator-ported-to-the-risc-v-isa-schuyler-eldridge:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;MicroProbe. An open source microbenchmark generator ported to the RISC-V ISA: Schuyler Eldridge&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Not yet open source, but in the process of releasing it.&lt;/li&gt;
&lt;li&gt;Why make microbenchmarks? Might want to study worst case power consumption,
look for performance bugs, determine if the design is reliable, &amp;hellip; But
writing microbenchmarks is a labour-intensive process.&lt;/li&gt;
&lt;li&gt;MicroProbe has the user write microbenchmark generation policies. The
framework then produces benchmarks according to those policies.&lt;/li&gt;
&lt;li&gt;The target definition (ISA, microarchitecture, environment) is written using
YAML. Code generation and generation policies are written using Python.&lt;/li&gt;
&lt;li&gt;MicroProbe uses riscv-meta from Michael Clark.&lt;/li&gt;
&lt;li&gt;The user describes a microbenchmark as transforms over an intermediate
representation (IR) for describing benchmarks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lauterbach-debug-support-for-risc-v-bob-kupyn:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Lauterbach debug support for RISC-V: Bob Kupyn&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lauterbach is solely focused on hardware and software debug tools. All
design, development and manufacture is done in Munich.&lt;/li&gt;
&lt;li&gt;Claim the widest range of supported microprocessors in the market.&lt;/li&gt;
&lt;li&gt;More than 100k installed Lauterbach debuggers, estimate 40% of the market.&lt;/li&gt;
&lt;li&gt;Have a RISC-V JTAG debugger. Currently just run-control, awaiting a stable
trace debug spec.&lt;/li&gt;
&lt;li&gt;Trace32 debugger supports all the features you&amp;rsquo;d expect. The RISC-V port
supports RV32 and RV64. In the future, want to add trace support and
Linux/Target OS awareness.&lt;/li&gt;
&lt;li&gt;In the initial release, support SiFive Coreplex E31 and E51.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;j-link-debug-probe-now-available-for-risc-v-paul-curtis:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;J-link debug probe now available for RISC-V: Paul Curtis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;J-Link aims to be the &amp;ldquo;ultimate debug probe&amp;rdquo;. Supporting ARM, Mips, RX,
8051, and now RISC-V.&lt;/li&gt;
&lt;li&gt;J-Link is open in the sense you can incorporate it into your product using
the J-Link SDK.&lt;/li&gt;
&lt;li&gt;J-Link is &amp;ldquo;intelligent&amp;rdquo;, eliminating round-trip-time over USB or IP using
kernels in the debug adapter.&lt;/li&gt;
&lt;li&gt;Over 600k units sold.&lt;/li&gt;
&lt;li&gt;Also have Embedded Studio, other products.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;porting-the-threadx-rtos-to-risc-v-john-carbone:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Porting the ThreadX RTOS to RISC-V: John Carbone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ThreadX in production since 1997.&lt;/li&gt;
&lt;li&gt;Small footprint, priority-based, fully preemptive RTOS with a single linear
address space.&lt;/li&gt;
&lt;li&gt;Has advanced features like preemption-threshold scheduling, real-time event
trace, memory-protected modules.&lt;/li&gt;
&lt;li&gt;Ported with co-operation from Mirosemi, ran on the Smartfusion2 Creative
Development Board.&lt;/li&gt;
&lt;li&gt;Anticipate commercial availability for RISC-V before the end of 2017.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;xbgas-a-bridge-proposal-for-rv128-and-hpc-john-leidel:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;xBGAS. A bridge proposal for RV128 and HPC: John Leidel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Extended Base Global Address Space (xBGAS)&lt;/li&gt;
&lt;li&gt;Want to provide extended addressing capabilities without ruining the base
ABI.&lt;/li&gt;
&lt;li&gt;Extended addressing must not specifically rely upon any one virtual memory&lt;/li&gt;
&lt;li&gt;xBGAS is not a direct replacement for RV128.&lt;/li&gt;
&lt;li&gt;See a variety of potential application domains.&lt;/li&gt;
&lt;li&gt;HPC-PGAS: traditional message passing has a tremendous amount of overhead.
There are a range of low-latency PGAS runtimes, but little hardware/uarch
support.&lt;/li&gt;
&lt;li&gt;Add extended (eN) register that map to base general registers. These are
manually utilized via extended load/store/move instructions.&lt;/li&gt;
&lt;li&gt;You only get access to the extended address space when using the new
extended addressing instructions.&lt;/li&gt;
&lt;li&gt;ISA extensions: base integer load/store, raw integer load/store, address
management (explicitly read/write the extended registers).&lt;/li&gt;
&lt;li&gt;No support for things like atomics currently. (Question for the community:
how to define extensions to extensions?)&lt;/li&gt;
&lt;li&gt;A number of outstanding issues with the ABI and calling convention. How to
link base RISC-V objects with objects containing extended addressing? Howe do
we address the caller/callee saved state with extended registers? What about
debugging and debugging metadata.&lt;/li&gt;
&lt;li&gt;The software part of this is being led by the Data Intensive Scalable
Computing Lab at Texas Tech. Have a prototype implementation in LLVM.&lt;/li&gt;
&lt;li&gt;Hardware part of the effort taking place at Tactical Computing Labs, LBNL
and MIT. Looking at pipelined and accelerator-based implementations.&lt;/li&gt;
&lt;li&gt;The current spec is &lt;a href=&#34;https://github.com/tactcomplabs/xbgas-archspec&#34;&gt;available
here&lt;/a&gt;. Comments and
collaborators are encouraged!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;extending-the-16-gpr-standard-beyond-rv32e-mitch-hayenga:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Extending the 16 GPR standard beyond RV32E: Mitch Hayenga&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Motivation: Register file area/power/latency is critical to any processor.
Large register files help with static code scheduling, but wide issue
out-of-order processors have the potential to hide register spill latency and
issue bandwidth.&lt;/li&gt;
&lt;li&gt;There are a number of commercially available cores that only offer 16
double-precision floating point registers.&lt;/li&gt;
&lt;li&gt;Want to see the 16GPR option being orthogonal just like any other ISA
variant (RV32E currently can&amp;rsquo;t be combined with the F and D extensions).&lt;/li&gt;
&lt;li&gt;Reduced the available registers to x0-x15 and f0-f15. Modified GCC and glibc
and used gem5 with the Coremark/Dhrystone/Whetstone/Spec2006 benchmarks.&lt;/li&gt;
&lt;li&gt;For the simple benchmarks, saw a 6-8% increase in static code size. Smaller
increase in dynamic instructions (and Whetstone saw a reduction). Saw in-order
execution time impacted, but much smaller impact for the out-of-order designs.&lt;/li&gt;
&lt;li&gt;For SPECInt, saw (very) slightly improved code density and execution time.&lt;br /&gt;
In perlbench this was primarily due to reduced function call overhead.&lt;/li&gt;
&lt;li&gt;The impact was more negative for SPECFP.&lt;/li&gt;
&lt;li&gt;Architectural overheads limit the viable design space of multithreaded
out-of-order CPUs.&lt;/li&gt;
&lt;li&gt;New potential designs:

&lt;ul&gt;
&lt;li&gt;Dual-threaded, small window out-of-order CPUs (~20 instruction windows).
This is impractical with the current RISC-V register file size requirements&lt;/li&gt;
&lt;li&gt;Large, high-IPC, many threaded CPU designs.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-pyrope-to-create-transformable-risc-v-architectures-haven-skinner:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Using Pyrope to create transformable RISC-V architectures: Haven Skinner&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hardware design is difficult. You need multiple codebases (cycle accurate,
high level simulation, verification reference model). Also need to adjust
pipeline stages and verify the hardware.&lt;/li&gt;
&lt;li&gt;A new HDL (Pyrope) can help!&lt;/li&gt;
&lt;li&gt;Fluid pipelines are the &amp;ldquo;hammer&amp;rdquo; used to address design complexity. Fluid
pipeline transformations change the number of stages as part of the compile
flow.&lt;/li&gt;
&lt;li&gt;A fluid pipeline has valid/stop signals, and pipeline stages should tolerate
random delays.&lt;/li&gt;
&lt;li&gt;Collapsing stages was useful in order to build an emulator out of a RISC-V
fluid core. Can also change the number of pipeline stages automatically, and
perform formal verification.&lt;/li&gt;
&lt;li&gt;For a Verilog implementation, saw 2MIPS when compiling with Verilator. When
collapsing fluid pipelines to produce a fast emulator, saw 6MIPS. Spike
achieves around 12 MIPS.&lt;/li&gt;
&lt;li&gt;Compared synthesis results of the fluid pipelines vs a range of open source
RISC-V cores.&lt;/li&gt;
&lt;li&gt;For &amp;ldquo;fluid verification&amp;rdquo;, can collapse the stages in a RISC-V core, then
verify against a trivial single stage RISC-V core. Used yosys to do this.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;performance-isolation-for-multicore-within-labeled-risc-v-zihao-yu:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Performance isolation for multicore within labeled RISC-V: Zihao Yu&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;In multi-core architectures, core share resources such as L3, memory, and
I/O. This can cause uncertainties and QoS violations.&lt;/li&gt;
&lt;li&gt;Take inspiration from labeled networks and try to apply to computer
architecture. Describe the Labeled von Neumann Architecture (LvNA).&lt;/li&gt;
&lt;li&gt;Each request has a label, each label is correlated with a
process/thread/variable, labels are propagated across the whole machine, and
software-defined control logic is used to provide different service for
different labeled groups.&lt;/li&gt;
&lt;li&gt;Proposed PARD (ASPLOS 2015). Programmable Architecture for
Resourcing-on-Demand.

&lt;ul&gt;
&lt;li&gt;Add a label register, allocate a label for each VM, attach a label to each
request, and add label-based programmable control logic.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LvNA + RISC-V = Labeled RISC-V&lt;/li&gt;
&lt;li&gt;Saw less than 3% overhead in terms of code, less than 5% resource overhead,
and no performance overheads for critical apps.&lt;/li&gt;
&lt;li&gt;Plan to tape out with TSMC 40nm next year.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-practical-implementation-of-a-platform-level-interrupt-controller-plic-richard-herveille:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;A Practical Implementation of a Platform Level Interrupt Controller (PLIC): Richard Herveille&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PLIC design goals: easy integration with external bus interfaces, be fully
compliant, and very flexible. Should work from small microcontrollers all the
way up to large server applications.&lt;/li&gt;
&lt;li&gt;The deign flexibility may result in management complexity. Potentially
hundreds or thousands of registers in a memory mapped management interface. So
try to define a management interface that minimises the memory map.&lt;/li&gt;
&lt;li&gt;Create the memory map dynamically based on parameters given to the IP core.&lt;br /&gt;
The register arrangement and documentation is automated.&lt;/li&gt;
&lt;li&gt;See the &lt;a href=&#34;https://roalogic.com&#34;&gt;Roa Logic website&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;open-source-rtos-ports-on-risc-v-nitin-deshpande:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Open source RTOS ports on RISC-V: Nitin Deshpande&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ported FreeRTOS, MyNewt, and Huawei LitOS.&lt;/li&gt;
&lt;li&gt;FreeRTOS: 32-bit version running on a RISC-V soft processor, 64-bit
currently runs on Spike.&lt;/li&gt;
&lt;li&gt;MyNewt: RISC-V support was already available, added the BSP and MCU/HAL
support.&lt;/li&gt;
&lt;li&gt;LiteOs: ported the kernel, BSP, and HAL. Already merged into upstream LiteOS
GitHub.&lt;/li&gt;
&lt;li&gt;Had a positive experience with RISC-V.&lt;/li&gt;
&lt;li&gt;Mi-V is an ecosystem that aims to accelerate the adoption of RISC-V.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-poster-preview:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V poster preview&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This is too rapid fire to summarise, sorry!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GSoC 2017 student report: core lockstep for minion cores</title>
      <link>http://www.lowrisc.org/blog/2017/10/gsoc-2017-student-report-core-lockstep-for-minion-cores</link>
      <pubDate>Thu, 05 Oct 2017 19:45:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/10/gsoc-2017-student-report-core-lockstep-for-minion-cores</guid>
      <description>&lt;p&gt;This year, as part of &lt;a href=&#34;https://developers.google.com/open-source/gsoc/&#34;&gt;Google Summer of
Code&lt;/a&gt; we had the pleasure of
working with Nikitas Chronas. Alongside his degree studies, Nikitas had become
involved with the &lt;a href=&#34;https://libre.space/&#34;&gt;Libre Space Foundation&lt;/a&gt; and developed
a strong interest in the possibility of open source hardware in
&lt;a href=&#34;https://en.wikipedia.org/wiki/CubeSat&#34;&gt;CubeSats&lt;/a&gt;. Fault tolerance of some
sort is important for harsh environments, and Nikitas worked to add fault
tolerance through the implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Lockstep_(computing)&#34;&gt;core
lockstep&lt;/a&gt; for the
PULPino-based minion
core subsystem. This was a really successful project which ended up
making contributions in areas beyond the core lockstep focus:
documentation, code quality, support for the Arty FPGA development board, and
even prototyping a code generation mechanism. See the &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2017/core-lockstep/&#34;&gt;detailed write-up&lt;/a&gt;
for all the details, and below for the all-important blinky lights demo.&lt;/p&gt;

&lt;iframe src=&#34;https://giphy.com/embed/26vIg6cZFMWvi6AbS&#34; width=&#34;480&#34; height=&#34;401&#34; frameBorder=&#34;0&#34; class=&#34;giphy-embed&#34; allowFullScreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Moving RISC-V LLVM forwards</title>
      <link>http://www.lowrisc.org/blog/2017/09/moving-risc-v-llvm-forwards</link>
      <pubDate>Wed, 27 Sep 2017 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/moving-risc-v-llvm-forwards</guid>
      <description>

&lt;p&gt;A high quality, upstream RISC-V backend for LLVM is perhaps the most
frequently requested missing piece of the RISC-V software ecosystem. This
blog post provides an update on the rapid progress we&amp;rsquo;ve been making towards
that goal, outlines next steps and upcoming events, and tries to better
explain the approach that we&amp;rsquo;re taking.
As always, you
can track status &lt;a href=&#34;http://www.lowrisc.org/llvm/status/&#34;&gt;here&lt;/a&gt; and find the code
&lt;a href=&#34;https://github.com/lowRISC/riscv-llvm&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;status:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Status&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been able to make substantial progress since the &lt;a href=&#34;http://lists.llvm.org/pipermail/llvm-dev/2017-August/116709.html&#34;&gt;last
update&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;rv32:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;RV32&lt;/h3&gt;

&lt;p&gt;100% of the GCC torture suite passes for RV32I at -O0, -O1, -O2, -O3, and -Os
(after masking gcc-only tests). MC-layer (assembler) support for RV32IMAFD has
now been implemented, as well as code generation for RV32IM.&lt;/p&gt;

&lt;h3 id=&#34;rv64:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;RV64&lt;/h3&gt;

&lt;p&gt;This is the biggest change versus my last update. LLVM recently gained support
for parameterising backends by register size, which allows code duplication to
be massively reduced for architectures like RISC-V. As planned, I&amp;rsquo;ve gone
ahead and implemented RV64I MC-layer and code generation support making use of
this feature. I&amp;rsquo;m happy to report that 100% of the GCC torture suite passes
for RV64I at O1, O2, O3 and Os (and there&amp;rsquo;s a single compilation failure at
O0). I&amp;rsquo;m very grateful for Krzysztof Parzyszek&amp;rsquo;s (QUIC) work on variable-sized
register classes, which has made it possible to parameterise the backend on
XLEN in this way. That LLVM feature was actually motivated by requirements of
the Hexagon architecture - I think this is a great example of how we can all
benefit by contributing upstream to projects, even across different ISAs.&lt;/p&gt;

&lt;h3 id=&#34;other-activities:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Other activities&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Community members Luís Marques and David Craven have been experimenting with
D and Rust support respectively.&lt;/li&gt;
&lt;li&gt;Andes Technology have started working to contribute to this effort, and are
putting together patches for compressed instruction set support. This is a
really positive move and I hope others will follow their lead.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-stats:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Development stats&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &amp;lsquo;reference&amp;rsquo; &lt;a href=&#34;https://github.com/lowRISC/riscv-llvm&#34;&gt;patch queue&lt;/a&gt; consists
of 48 patches, modifying 128 files and inserting over 11500 lines to the LLVM
and Clang codebases. Close to 50% of these lines are new tests.&lt;/li&gt;
&lt;li&gt;Other activities:

&lt;ul&gt;
&lt;li&gt;8 committed patches to LLVM in areas other than lib/Target/RISCV
(cleanups, support code, documentation improvements, bug fixes) with 5 more
making their way through the review process.&lt;/li&gt;
&lt;li&gt;2 GCC/binutils bugs reported&lt;/li&gt;
&lt;li&gt;RISC-V &lt;a href=&#34;https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md&#34;&gt;psABI
doc&lt;/a&gt;:
Authored 7 merged commits, 13 issues filed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;d like to thank &lt;a href=&#34;https://github.com/lowRISC/riscv-llvm#credits&#34;&gt;everyone&lt;/a&gt;
who has contributed code review, feedback, or suggestions so far, as well as
our industrial sponsor.&lt;/p&gt;

&lt;h2 id=&#34;approach-and-philosophy:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Approach and philosophy&lt;/h2&gt;

&lt;p&gt;As enthusiastic supporters of RISC-V, I think we all want to see a huge range
of RISC-V core implementations, making different trade-offs or targeting
different classes of applications. But we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want to see that variety in
the RISC-V ecosystem result in dozens of different vendor-specific compiler
toolchains and a fractured software ecosystem. Unfortunately most work on LLVM
for RISC-V has been invested in private/proprietary code bases or short-term
prototypes. The work described in this post has been performed out in the open
from the start, with a strong focus on code quality, testing, and on moving
development upstream as quickly as possible - i.e. a solution for the long term.&lt;/p&gt;

&lt;p&gt;My implementation approach has been to first work towards a cleanly designed
and well tested RV32I baseline compiler. Once the fundamentals are solid, it
is &lt;em&gt;significantly&lt;/em&gt; easier to add in new features, optimisations, or indeed
customisations for different RISC-V variants. This careful approach has
enabled the rapid progress of the past few weeks. I would summarise this
approach as:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ensuring (to the extent possible) that correct code is always generated for
a simple RV32I baseline&lt;/li&gt;
&lt;li&gt;Expand that baseline to support more RISC-V ISA variants (RV{32,64}IMA and
later FD)&lt;/li&gt;
&lt;li&gt;Push forwards on optimisations (generated code quality) and compiler
feature support. Part of this work is moving to larger scale test programs and
benchmarks in order to maintain confidence about the correctness of generated
code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This project is currently in the process of moving from point 2) to point 3)
on the list above. As it stands, you will benefit from LLVM&amp;rsquo;s many middle-end
optimisations, but the final code generation stage has seen little work
focused on the performance of generated code. With a high quality base now in
place, adding these optimisations can be done relatively easily.&lt;/p&gt;

&lt;p&gt;If you want to see first-class support for RISC-V in LLVM, now is the time to
get involved and help make it happen.&lt;/p&gt;

&lt;h2 id=&#34;roadmap-and-upcoming-events:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Roadmap and upcoming events&lt;/h2&gt;

&lt;p&gt;My aim is to have Clang and LLVM developed to serve as a competitive
alternative to GCC on RISC-V by the end of the calendar year. If the RISC-V
community works together, this is an achievable goal.&lt;/p&gt;

&lt;p&gt;My near-term goals are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Expand testing for RV64. There are rather few RV64 unit tests right now
because parameterising the backend by XLEN mostly &amp;ldquo;just worked&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Go through the implementation again (particularly recently added code) to
look for further cleanup or refactoring opportunities, then propose to merge
it upstream.&lt;/li&gt;
&lt;li&gt;Once I&amp;rsquo;m happy with the implementation approach for the most recently added
features, move the 5.0-based
&lt;a href=&#34;http://github.com/lowrisc/riscv-llvm-integration&#34;&gt;riscv-llvm-integration&lt;/a&gt;
tree forwards.&lt;/li&gt;
&lt;li&gt;Review patches from contributors such as Andes and help to support language
port efforts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Focus areas after that include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clang toolchain driver, MAFD codegen and ABI support&lt;/li&gt;
&lt;li&gt;Benchmarking vs RISC-V GCC and generated code quality improvements&lt;/li&gt;
&lt;li&gt;Documentation, expanded test cases, and improved compiler testing tooling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve mapped out a number of TODO items
&lt;a href=&#34;https://github.com/lowRISC/riscv-llvm/issues&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m pleased to report that my proposal for a RISC-V &amp;ldquo;birds of a feather&amp;rdquo;
session at the &lt;a href=&#34;http://llvm.org/devmtg/2017-10/#bof4&#34;&gt;upcoming LLVM Dev
Meeting&lt;/a&gt; (Oct 18th) was accepted. You
should definitely attend this event if you are an LLVM developer working on an
out-of-tree RISC-V backends or are looking to get involved (representatives
from several companies in that position are already confirmed as attending).
We&amp;rsquo;re also looking to run a longer working/hacking session the day before, at
a San Jose location. More details on both events will be circulated shortly.&lt;/p&gt;

&lt;h2 id=&#34;faq:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;do-you-care-about-performance-of-generated-code-and-code-size:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Do you care about performance of generated code and code size?&lt;/h3&gt;

&lt;p&gt;Like any compiler developer, of course. Starting with a solid and well tested
base is the best way of achieving those aims. We&amp;rsquo;re now in a position where we
can push forwards on these fronts, which will will soon become a primary focus
of this development effort.&lt;/p&gt;

&lt;h3 id=&#34;i-have-a-risc-v-llvm-fork-which-works-for-me-why-should-i-care-about-an-upstream-backend:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;I have a RISC-V LLVM fork which works for me, why should I care about an upstream backend?&lt;/h3&gt;

&lt;p&gt;This is ultimately a question about long-term maintenance and sharing the
support burden with others in the RISC-V ecosystem. By working together and
pooling our development efforts, we can unlock the benefits of the open source
approach. Contributing to this effort is almost definitely the right long-term
choice for your project. If you want to discuss how to contribute, please drop
me an email or come along to the upcoming birds of a feather session.&lt;/p&gt;

&lt;h3 id=&#34;what-is-the-difference-between-this-and-other-risc-v-llvm-efforts:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;What is the difference between this and other RISC-V LLVM efforts?&lt;/h3&gt;

&lt;p&gt;This effort is focused on high code quality, long term maintainability, and in
getting development merged in to upstream LLVM. Andes have recently released a
private development tree to the public. That tree was was based on an early
version of the lowRISC patchset, but diverged significantly in terms of
implementation approach. Andes are now working to submit patches to this
effort.&lt;/p&gt;

&lt;h3 id=&#34;who-are-you:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Who are you?&lt;/h3&gt;

&lt;p&gt;I (Alex Bradbury) am a co-founder and director of lowRISC CIC, where this
development work has been taking place. I have been developing LLVM backends
for the past seven years, and am now upstream code owner for the RISC-V
backend. If you&amp;rsquo;re interested in LLVM, you are hopefully already familiar with
my &lt;a href=&#34;http://llvmweekly.org/&#34;&gt;LLVM Weekly&lt;/a&gt; newsletter.&lt;/p&gt;

&lt;h3 id=&#34;why-is-lowrisc-interested-in-llvm:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Why is lowRISC interested in LLVM?&lt;/h3&gt;

&lt;p&gt;lowRISC is a not-for-profit created to push forward open source hardware by
developing a secure, open, and flexible SoC design. Enabling custom hardware
and derivative designs is about much more than shipping RTL with an open
source license - hardware is of little use without the software infrastructure
in place to support it. A high quality and easy to modify LLVM backend is
important for potential lowRISC adopters, but also benefits our own hardware
development efforts. Specifically, we will be building the software component
of our tagged memory mechanisms on top of LLVM. If our mission sounds
interesting to you, there&amp;rsquo;s good news - &lt;a href=&#34;http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality/&#34;&gt;we&amp;rsquo;re
hiring&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;who-do-i-contact-to-discuss-further-sponsoring-this-effort:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Who do I contact to discuss further sponsoring this effort?&lt;/h3&gt;

&lt;p&gt;If your company would like to see lowRISC&amp;rsquo;s work on RISC-V LLVM be sustained
or expanded through 2018, then contributing development time and/or
sponsorship is the best way to do this. Please contact asb@lowrisc.org to
discuss further.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC tagged memory OS enablement</title>
      <link>http://www.lowrisc.org/blog/2017/09/lowrisc-tagged-memory-os-enablement</link>
      <pubDate>Tue, 19 Sep 2017 14:45:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/lowrisc-tagged-memory-os-enablement</guid>
      <description>&lt;p&gt;This summer, we were fortunate enough to have Katherine Lim join the lowRISC
team at the University of Cambridge Computer Laboratory as an intern.
Katherine&amp;rsquo;s focus was on operating system and software enabled for lowRISC&amp;rsquo;s
tagged memory, building upon our
&lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;most recent milestone release&lt;/a&gt;.
As Katherine&amp;rsquo;s &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-os-enablement-internship-2017/&#34;&gt;detailed write-up&lt;/a&gt; demonstrates,
it&amp;rsquo;s been a very productive summer.&lt;/p&gt;

&lt;p&gt;The goal of this internship was to take the lowRISC hardware release, and
demonstrate kernel support and software support for the hardware tagged memory
primitives. This includes support for context-switch of the &lt;code&gt;tagctrl&lt;/code&gt; register
used to configure tag rules, maintaining tags in pages upon copy-on-write,
delivering tag exceptions to user space, loading tags from ELF binaries, and
more. It culminated in a demonstration that pulls these various pieces of work
together, showing how tagged memory can be used to mark valid branch targets.
Read the &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-os-enablement-internship-2017/&#34;&gt;report&lt;/a&gt; for full
details.&lt;/p&gt;

&lt;p&gt;We believe there is a rich design space in hardware support for tagged memory
and tag-based software policies. This operating system enablement work is an
important part of exploring that space, and in making it easier for other
groups to do the same.&lt;/p&gt;

&lt;p&gt;If working on problems like this sounds interesting to you, there&amp;rsquo;s good news
- &lt;a href=&#34;http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality&#34;&gt;&lt;strong&gt;we&amp;rsquo;re hiring&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury and Katherine Lim&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>We&#39;re hiring! Work on making open source hardware a reality</title>
      <link>http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality</link>
      <pubDate>Mon, 18 Sep 2017 08:15:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality</guid>
      <description>&lt;p&gt;We are looking for a talented hardware engineer to join the lowRISC team and
help make our vision for an open source, secure, and flexible SoC a reality.
&lt;a href=&#34;https://lowrisc.workable.com/j/DBAC61322F&#34;&gt;Apply now&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;lowRISC C.I.C. is a not-for-profit company that aims to demonstrate, promote
and support the use of open-source hardware. The lowRISC project was
established in 2014 with the aim of bringing the benefits of open-source to
the hardware world. It is working to do this by producing a high quality,
secure, open, and flexible System-on-Chip (SoC) platform. lowRISC C.I.C. also
provides hardware and software services to support the growing RISC-V
ecosystem. Our expertise includes the LLVM Compiler, hardware security
extensions and RISC-V tools, hardware and processor design.&lt;/p&gt;

&lt;p&gt;The successful candidate will be interested in computer architecture and
hardware design. The primary focus of the role will be the development of the
lowRISC SoC platform, which will involve work to evaluate and extend our
current design including our general-purpose tagged-memory system. lowRISC is
an ambitious project with a small core team, so you will be heavily involved
in the project&amp;rsquo;s development direction. This role will involve frequent work
with external contributors and collaborators. While much of the work will be
at the hardware level the post will offer experience of the full
hardware/software stack, higher-level simulation tools and architectural
design issues.&lt;/p&gt;

&lt;p&gt;Some practical experience of hardware design with a HDL such as
Verilog/SystemVerilog is essential, as is a good knowledge of the HW/SW stack.
Ideally, candidates will also have experience or demonstrated interest in some
of: SoC design, large-scale open source development, hardware or software
security, technical documentation, board support package development and
driver development. Industrial experience and higher degree levels are valued,
but we would be happy to consider an enthusiastic recent graduate with a
strong academic record.&lt;/p&gt;

&lt;p&gt;Informal enquires should be made to Alex Bradbury &lt;a href=&#34;mailto:asb@lowrisc.org&#34;&gt;asb@lowrisc.org&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building upstream RISC-V GCC&#43;binutils&#43;newlib: the quick and dirty way</title>
      <link>http://www.lowrisc.org/blog/2017/09/building-upstream-risc-v-gccbinutilsnewlib-the-quick-and-dirty-way</link>
      <pubDate>Tue, 05 Sep 2017 14:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/building-upstream-risc-v-gccbinutilsnewlib-the-quick-and-dirty-way</guid>
      <description>&lt;p&gt;There are a number of available options for building a RISC-V GCC toolchain.
You might use the build system from the
&lt;a href=&#34;https://github.com/riscv/riscv-tools&#34;&gt;riscv/riscv-tools repository&lt;/a&gt;, or
investigate toolchain generators such as
&lt;a href=&#34;http://crosstool-ng.github.io/&#34;&gt;crosstool-ng&lt;/a&gt;. However in the case of
riscv-tools, it&amp;rsquo;s not always clear how this corresponds to the code in the
relevant upstream projects. When investigating a potential bug, you often just
want to build the latest upstream code with as little fuss as possible. For
distribution purposes you&amp;rsquo;d probably want to perform a proper multi-stage
build, but for a quick test you might find the following recipe useful:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone --depth=1 git://gcc.gnu.org/git/gcc.git gcc
git clone --depth=1 git://sourceware.org/git/binutils-gdb.git
git clone --depth=1 git://sourceware.org/git/newlib-cygwin.git
mkdir combined
cd combined
ln -s ../newlib-cygwin/* .
ln --force -s ../binutils-gdb/* .
ln --force -s ../gcc/* .
mkdir build
cd build
../configure --target=riscv32-unknown-elf --enable-languages=c \
--disable-shared --disable-threads --disable-multilib --disable-gdb \
--disable-libssp --with-newlib \
--with-arch=rv32ima --with-abi=ilp32 --prefix=$(pwd)/built
make -j
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce a newlib toolchain targeting RV32IMA in the &lt;code&gt;built/&lt;/code&gt;
subdirectory. When files are duplicated in the newlib, binutils and gcc
repositories, the gcc version takes precedence.&lt;/p&gt;

&lt;p&gt;Major credit to everyone who worked on getting these toolchain
ports upstream (Kito Cheng, Palmer Dabbelt, and others).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC 0-4 milestone release</title>
      <link>http://www.lowrisc.org/blog/2017/06/lowrisc-0-4-milestone-release</link>
      <pubDate>Fri, 09 Jun 2017 12:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/06/lowrisc-0-4-milestone-release</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;lowRISC 0.4 milestone release&lt;/a&gt;
is now available. The various changes are best described in our &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;accompanying
documentation&lt;/a&gt;, but in summary this
release:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Moves forward our support for tagged memory by re-integrating the tag cache,
reducing overhead with a &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/tag_cache/&#34;&gt;hierarchical scheme&lt;/a&gt;.
This will significantly reduce caches misses caused by tagged memory accesses
where tags are distributed sparsely.&lt;/li&gt;
&lt;li&gt;Integrates support for specifying and configuring &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/tag_core/&#34;&gt;tag propagation and
exception behaviour&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;http://www.pulp-platform.org/&#34;&gt;PULPino&lt;/a&gt; based &amp;ldquo;minion core&amp;rdquo; has been
integrated, and is used to provide peripherals such as the SD card
interface, keyboard, and VGA tex display (when using the Nexys4 DDR FPGA
development board).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please report any issues &lt;a href=&#34;https://github.com/lowRISC/lowrisc-chip&#34;&gt;on our GitHub
repository&lt;/a&gt;, or discuss on our
&lt;a href=&#34;http://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;mailing list&lt;/a&gt;. As always, thank you to everyone who has contributed in any way - whether it&amp;rsquo;s advice and feedback, bug reports, code, or ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apply now for GSoC 2017</title>
      <link>http://www.lowrisc.org/blog/2017/03/apply-now-for-gsoc-2017</link>
      <pubDate>Mon, 27 Mar 2017 09:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/03/apply-now-for-gsoc-2017</guid>
      <description>&lt;p&gt;We are very grateful for being selected again to take part as a mentoring
organisation in the &lt;a href=&#34;https://summerofcode.withgoogle.com/&#34;&gt;Google Summer of
Code&lt;/a&gt;, now for the third year running.
If you are a student who would like to be paid to work on open source during
the summer, then take a look at &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2017-ideas/&#34;&gt;the lowRISC ideas
list&lt;/a&gt; and
&lt;a href=&#34;https://summerofcode.withgoogle.com/organizations/6271463900315648/&#34;&gt;apply&lt;/a&gt;.
The deadline for applications is 4pm UTC on April 3rd. We&amp;rsquo;re always very interested in
ideas suggested by students, and encourage you to share them &lt;a href=&#34;https://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;on our
discussion
list&lt;/a&gt;
for feedback before making a proposal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2017 NetFPGA Design Challenge</title>
      <link>http://www.lowrisc.org/blog/2017/02/2017-netfpga-design-challenge</link>
      <pubDate>Wed, 01 Feb 2017 14:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/02/2017-netfpga-design-challenge</guid>
      <description>&lt;p&gt;As most of you know, the majority of full-time development on lowRISC takes
place at the University of Cambridge Computer Laboratory. However, we&amp;rsquo;re far
from the only open source hardware activity at the University. Our colleagues
on the NetFPGA project have an open source design challenge that many readers
of this blog might be interested in. See the &lt;a href=&#34;http://www.cl.cam.ac.uk/research/srg/netfpga/challenge2017/&#34;&gt;design challenge
website&lt;/a&gt;, or read
below for more details:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;We are pleased to announce the 2017 NetFPGA Design Challenge!

NetFPGA platforms are used by the networked systems community for close to 
a decade. The platforms enable researchers and instructors to build 
high-speed, hardware-accelerated networking systems. The platforms can be used 
by researchers to prototype advanced services for next-generation networked 
systems. By using Field Programmable Gate Arrays (FPGAs), NetFPGA enables new 
types of packet routing circuits to be implemented and detailed measurements 
of network traffic to be obtained.

The NetFPGA 2017 contest is a design challenge. The design teams are to 
produce a working implementation employing any HW and SW design methodology 
and targeting the NetFPGA SUME platform. The deadline for submissions is April 
13th, 2017. The winners will be announced at the NetFPGA Developers Summit 
(Thursday 20th - Friday, 21st April, 2017 Cambridge, UK).

Challenge: Lowest Latency Switch

Low latency devices are being increasingly used across a large number of 
applications. Low latency solutions are few, and are rarely open source. The 
goal of this challenge is to provide a usable, high performance, open source 
alternative to use by universities and organizations who need the flexibility 
of open source.  The systems will be evaluated using OSNT, an Open Source 
Network Tester. Test benches will be available online, for users to experiment 
and independently evaluate their design. The competition is open to students 
of all levels (undergraduate and postgraduate), as well as to non students. 
There is no need to own a NetFPGA SUME platform to take part in the 
competition although, clearly, development and testing will be made easier if 
you have access to this platform.  

Team Prizes:
First place: £500
Best students project: £500

The winning projects and runner ups will be invited to present their work 
at the NetFPGA Developers Summit 2017.  All challenge participants are keenly 
encouraged to attend the NetFPGA Developers Summit and are entitled to a 
reduced registration rate.

The design challenge prizes are generously 
supported by IMC http://www.imc.nl/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC Q&#43;A</title>
      <link>http://www.lowrisc.org/blog/2016/12/lowrisc-qa</link>
      <pubDate>Fri, 09 Dec 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/12/lowrisc-qa</guid>
      <description>&lt;p&gt;Yesterday, lowRISC triggered a lot of discussion when someone submitted it to
Hacker News. The &lt;a href=&#34;https://news.ycombinator.com/item?id=13129076&#34;&gt;comment
thread&lt;/a&gt; became something of an
impromptu Q+A about our project direction and status. I thought it was worth
linking to it here and highlighting the discussion for a wider audience. If
you have any additional questions, then feel free to comment on this blog post
or else, as always, drop by our &lt;a href=&#34;http://www.lowrisc.org/community/&#34;&gt;mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fifth RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</link>
      <pubDate>Wed, 30 Nov 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;Today is the second day of the &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt;. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;opensoc-system-architect-farzad-fatollahi-fard:529e3037a37627249629f6513082618e&#34;&gt;OpenSoC System Architect: Farzad Fatollahi-Fard&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Current architectures are wasteful. Only a small fraction of chip area goes
to computation.&lt;/li&gt;
&lt;li&gt;For both GoblinCore and OpenHPC, ended up doing a lot of similar work to
achieve only a point design. Why not make a generator to avoid repeating the
same steps?&lt;/li&gt;
&lt;li&gt;OpenSoC System Architect is a combination of multiple tools to form a
well-defined development flow for complex RISC-V SoCs&lt;/li&gt;
&lt;li&gt;Supports standard RISC-V modules and custom extensions&lt;/li&gt;
&lt;li&gt;It outputs pre-verified Chisel for the SoC, synthesisable Verilog, and an
LLVM compiler for the SoC&lt;/li&gt;
&lt;li&gt;OpenSoC Fabric is an open-source, flexible, parameterised NoC generator. It
integrates with a wide variety of existing processors, as well as IO devices.&lt;/li&gt;
&lt;li&gt;Created a &amp;lsquo;CoreGen&amp;rsquo; IR. It allows automatic generation of HDL
representations of the SoC and build LLVM compiler backend implementations of
the SoC and any extensions.&lt;/li&gt;
&lt;li&gt;The IR is stored on disk in well-formed XML&lt;/li&gt;
&lt;li&gt;What&amp;rsquo;s next? Better support for Chisel3, more integration with existing
RISC-V tools and environment, frontend support to import existing
Chisel/Verilog/SystemVerilog. Also want CoreGen as a standalone IR&lt;/li&gt;
&lt;li&gt;See the website at &lt;a href=&#34;http://www.opensoc.community/&#34;&gt;http://www.opensoc.community/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;v-vector-extension-proposal-krste-asanovic:529e3037a37627249629f6513082618e&#34;&gt;V Vector Extension Proposal: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The vector extension intends to scale to all reasonable design points
(low-cost microcontroller or high-performance supercomputer). Support both
implicit auto-vectorisation and explicit SPMD&lt;/li&gt;
&lt;li&gt;Fit into the 32-bit encoding space, but be a base for future vector
extensions (e.g. crypto algorithms)&lt;/li&gt;
&lt;li&gt;The goal is to ratify a proposal 12 months from now, at the 7th workshop&lt;/li&gt;
&lt;li&gt;Cray-style vectors. &amp;ldquo;The right way&amp;rdquo; to exploit SIMD parallelism (as opposed
to the wrong way: GPUs or packed SIMD)&lt;/li&gt;
&lt;li&gt;V has an implementation-dependent vector length, meaning the same code runs
across different hardware without recompiling&lt;/li&gt;
&lt;li&gt;Each vector data register is configured with a width and type, or disabled.
There are also a configurable number of predicate registers. The maximum
vector length is a function of configuration, physical register storage, and
microarchitecture&lt;/li&gt;
&lt;li&gt;There are a number of mandatory supported types. e.g. an RV32IF system must
support X8, X16, X32, F16, F32. This means that scalar and vector half
precision floating point is a requirement if you are supporting floating
point.&lt;/li&gt;
&lt;li&gt;Each vector data register has a 4-bit field in a CSR (or multiple CSRs)
indicating its width, and another for its type.&lt;/li&gt;
&lt;li&gt;A vcfgd CSR alias is defined to allow faster writes of common vector data
configurations.&lt;/li&gt;
&lt;li&gt;Most user code would use the setvl instruction (which is actually setting a
CSR).&lt;/li&gt;
&lt;li&gt;A 16-bit+32-bit vector addition is pleasingly straight forward to specify in
assembly&lt;/li&gt;
&lt;li&gt;The architecture guarantees a minimum vector length of four regardless of
configuration. This means 1KB SRAM is required as a minimum&lt;/li&gt;
&lt;li&gt;A polymorphic instruction encoding is used. A single signed integer ADD
opcode works on different size inputs and outputs, depending on the
configuration of its inputs.&lt;/li&gt;
&lt;li&gt;There is support for vector atomics (e.g. vector fetch-and-add).&lt;/li&gt;
&lt;li&gt;For vector function calls (e.g. in auto-vectorised code) you want to make
vector calls to a function library with separate vector calling convention.
The caller has to allocate registers for the callee to use. It sets the
maximum width, allowing the callee to change the vctype as needed.&lt;/li&gt;
&lt;li&gt;For OpenCL/CUDA/SPMD, the configuration must be set at kernel launch to the
maximum width used anywhere in the call tree. It needs a general vector
function call capability with standard callee/caller save protocol&lt;/li&gt;
&lt;li&gt;Krste argues autovectorisation is much preferable to OpenCL or CUDA.&lt;/li&gt;
&lt;li&gt;Question: are you interested in smaller types (e.g. 4-bit). Answer: yes,
also interested in non-power-of-two types&lt;/li&gt;
&lt;li&gt;Question about the calling convention: the vector configuration state is
assumed to be caller-saved (including the vector register file), meaning the
scalar ABI is unmodified&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;towards-thousand-core-risc-v-shared-memory-systems-quan-nguyen:529e3037a37627249629f6513082618e&#34;&gt;Towards Thousand-Core RISC-V Shared Memory Systems: Quan Nguyen&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tardis is a new cache coherency protocol with greater scalability than
traditional directory coherence protocols.&lt;/li&gt;
&lt;li&gt;Tardis enforces consistency through timestamps, using logical leases&lt;/li&gt;
&lt;li&gt;It only tracks the exclusive owner of any particular cache line, requiring
only O(log N) storage. No broadcast invalidations, and timestamps aren&amp;rsquo;t tied
to the core count. There is no need for synchronised real-time clocks&lt;/li&gt;
&lt;li&gt;They are building a thousand-core prototype. Fit as many cores as possible
on a ZC706 FPGA, the connect in a 3D mesh to demonstrate at scale.&lt;/li&gt;
&lt;li&gt;Want to adapt Tardis for release consistency (rather than sequential
consistency), and Quan introduces how they have started to do this by
introducing new timestamps&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scrx-a-family-of-state-of-the-art-risc-v-synthesizable-cores-alexander-redkin:529e3037a37627249629f6513082618e&#34;&gt;SCRx: a family of state-of-the art RISC-V synthesizable cores: Alexander Redkin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Syntacore develops and licenses energy-efficient programmable cores
implementing the RISC-V ISA&lt;/li&gt;
&lt;li&gt;SCRx is the family of RISC-V implementations, now available for evaluation.
Each core can be extended and customised&lt;/li&gt;
&lt;li&gt;The smallest core, SCR1 is less than 20kgates in a basic untethered
configuration.&lt;/li&gt;
&lt;li&gt;SCR3 is a high-performance MCU core with up to 1.7DMIPS/MHz,
3.16CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;SCR4 is an MCU core with a high-performance FPU.&lt;/li&gt;
&lt;li&gt;SCR5 is an efficient mid-range embedded core. Full MMU with Linux support.
1GHz+ at 28nm, and 1.5+DMIPS/MHz per core.&lt;/li&gt;
&lt;li&gt;In the near term, want to support the latest privileged spec, adding trace
debug&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-hardware-software-co-design-with-risc-v-and-llvm-alex-bradbury:529e3037a37627249629f6513082618e&#34;&gt;Enabling hardware/software co-design with RISC-V and LLVM: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ll try and write something up for the blog later, but for now see my
slides
&lt;a href=&#34;https://speakerdeck.com/asb/software-co-design-with-risc-v-and-llvm&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vm-threads-an-alternative-model-for-virtual-machines-on-risc-vm-ron-minnich:529e3037a37627249629f6513082618e&#34;&gt;VM threads: an alternative model for virtual machines on RISC-VM: Ron Minnich&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Akaros is a research kernel originally from UC Berkeley.&lt;/li&gt;
&lt;li&gt;One core idea is the &amp;lsquo;multi core process&amp;rsquo;. This can be thought of as a set
of cores assigned an entity to a program.&lt;/li&gt;
&lt;li&gt;How do VMs fit into the Akaros model. A VM could be kind of a process.&lt;/li&gt;
&lt;li&gt;Look back at how we start a process. With the introduction of fork(), it
became easy and clean. But its introduction was controversial.&lt;/li&gt;
&lt;li&gt;Virtualisation on Linux/BSD/Unix requires a device (e.g. /dev/kvm). This
typically requires daemons who are used to interact with the device. In
Akaros, they did not want to recreate this.&lt;/li&gt;
&lt;li&gt;Can we just run a virtual machine like we do a thread? Introduce
&lt;code&gt;vthread_create&lt;/code&gt;. In Akaros, they have extended the thread model to include
virtual machine threads.&lt;/li&gt;
&lt;li&gt;Virtual machine threads (vthreads) can run Linux 4.8 (with 12 lines of
patches) and any code that shares the host ring 3 address space.&lt;/li&gt;
&lt;li&gt;Ring 3 and Ring V share and address space. Ring V is limited to 2^46 bytes,
while ring 3 is in a 2^47 byte address space.&lt;/li&gt;
&lt;li&gt;VM threads are integrated tightly into the kernel.&lt;/li&gt;
&lt;li&gt;On x86, Akaros pairs page table roots and page table pages. Page table pages
are 2x4k pages, with the process PTP in the lower 4K and the VM PTP in the
upper 4K. This makes it trivial to convert the two.&lt;/li&gt;
&lt;li&gt;It is significantly easier to write virtual machine managers in Akaros than
with the Linux model&lt;/li&gt;
&lt;li&gt;Akaros VMS are unlike any other VMs - threads can easily switch from being a
VM to being a host thread&lt;/li&gt;
&lt;li&gt;Kernels also look like threads, and spinning up a core looks like CPU
hotplug, accomplished by spinning up a vthread with IP at the 64-bit entry
point.&lt;/li&gt;
&lt;li&gt;There are a variety of implications and questions for RISC-V. How will
RISC-V handle nested paging? Can we avoid massive shadow state. How about
injecting interrupts without a vmexit?&lt;/li&gt;
&lt;li&gt;RISC-V is a chance to enable software innovation. We shouldn&amp;rsquo;t get locked
into &amp;ldquo;but we&amp;rsquo;ve always done it this way&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-low-power-smartphone-like-graphical-uis-for-risc-v-socs-michael-gielda:529e3037a37627249629f6513082618e&#34;&gt;Enabling low-power, smartphone-like graphical UIs for RISC-V SoCs: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Industrial/embedded UIs mostly look bad, but also have terribly user
experience&lt;/li&gt;
&lt;li&gt;For better UIs you mostly have to jump to Android or Linux - there&amp;rsquo;s a lack
of a middle ground&lt;/li&gt;
&lt;li&gt;For a previous project, produced a mobile-like GUI experience targeting an
MCU (STM32F4).&lt;/li&gt;
&lt;li&gt;With the right approach and tools, embedded GUIs can be beautiful too&lt;/li&gt;
&lt;li&gt;Their library was written in C++, with support for layers+formats. It has
its own font engine for kerning, anti-aliasing etc.&lt;/li&gt;
&lt;li&gt;The GUI is specified in XML and has its own minimal CSS&lt;/li&gt;
&lt;li&gt;Initially developed for eCos RTOS, and has an initial port for FreeRTOS. Can
also run on Linux.&lt;/li&gt;
&lt;li&gt;To prototype on a Zynq, implemented &amp;lsquo;micro blender&amp;rsquo; for blending, filling,
scaling etc. This was written in Chisel.&lt;/li&gt;
&lt;li&gt;Software-driven IP (silicon) is possible (and advisable!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-fast-instruction-set-simulator-for-risc-v-maxim-maslov:529e3037a37627249629f6513082618e&#34;&gt;A Fast Instruction Set Simulator for RISC-V: Maxim Maslov&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Esperanto is a stealth mode startup designing chips with RISC-V&lt;/li&gt;
&lt;li&gt;Wanted a fast RISC-V ISA simulator capable of running large applications
with minimal slowdown&lt;/li&gt;
&lt;li&gt;[Sorry folks, I had to duck out for a quick discussion - see the
&lt;a href=&#34;https://riscv.org/wp-content/uploads/2016/11/Wed1330-Fast-ISA-Simulator-for-RISC-V-Maslov-Esperanto.pdf&#34;&gt;slides&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-on-rv64g-benjamin-barenblat-and-michael-pratt:529e3037a37627249629f6513082618e&#34;&gt;Go on RV64G: Benjamin Barenblat and Michael Pratt&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why RISC-V? Better architecture, lower power, faster processing, easier
accelerator development. RISC-V is not going away&lt;/li&gt;
&lt;li&gt;The Go toolchain is complex. It has its own compiler, assembler (and
assembly language), and linker&lt;/li&gt;
&lt;li&gt;Getting close, but the runtime doesn&amp;rsquo;t quite compile. Hope to get it working
in the next few months.&lt;/li&gt;
&lt;li&gt;In the mean time, relatively simple go programs will compile and run&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s been mostly good. One pain-point has been that other Go ports don&amp;rsquo;t
target architectures with good conditional branches so had to emulate a flag
register. Another gripe is that loading 64-bit constants is a pain.&lt;/li&gt;
&lt;li&gt;Within a couple of months you should be able to compile real Go programs and
have them run on RISC-V&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-java-virtual-machine-for-risc-v-porting-the-jikes-rvm-martin-maas:529e3037a37627249629f6513082618e&#34;&gt;A Java Virtual Machine for RISC-V: Porting the Jikes RVM: Martin Maas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why do a JVM port? Both to run interesting applications, and for research
(e.g. hardware support for GCed languages)&lt;/li&gt;
&lt;li&gt;Porting OpenJDK/Hotspot for high performance, and the Jikes research VM for
academic work. This talk will focus on Jikes&lt;/li&gt;
&lt;li&gt;Jikes is itself written in Java&lt;/li&gt;
&lt;li&gt;JVMs have a large number of dependencies, so use the riscv-poky Linux
distribution generator to build a cross-compiled SDK and Linux image.&lt;/li&gt;
&lt;li&gt;While developing, add assertions everywhere to fail as early as possible&lt;/li&gt;
&lt;li&gt;Allowed the JIT to selectively emit instructions that dump trace output&lt;/li&gt;
&lt;li&gt;Booting JikesRVM is no easy task (there a &lt;em&gt;lot&lt;/em&gt; to do in order to get to
hello world)&lt;/li&gt;
&lt;li&gt;The non-optimising JIT compiler is mostly feature-complete. Passes &lt;sup&gt;65&lt;/sup&gt;&amp;frasl;&lt;sub&gt;68&lt;/sub&gt;
core tests. Targets RV64G&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;yopuzzle-an-open-v-development-platform-the-next-generation-elkim-roa:529e3037a37627249629f6513082618e&#34;&gt;YoPuzzle - an Open-V development platform the next generation: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lsquo;Open source&amp;rsquo; hardware. Raspberry Pi have sold 10 million boards, Arduino
sold 4.5 million boards (estimated). Some predictions indicate the market will
be worth over $1B within the next four years. These are based on commercial,
closed-source silicon&lt;/li&gt;
&lt;li&gt;OnChip UIS have developed an open 32-bit RISC-V based microcontroller. To
test the initial silicon, used chip-on-board&lt;/li&gt;
&lt;li&gt;RV32IM with a 3-stage pipeline. On TSMC 130nm GP. Die area 2.1mm x 2.1mm.&lt;/li&gt;
&lt;li&gt;The Microprocessor core is 0.12mm2, max freq 200MHz, core voltage 1.2V, core
dynamic power at 100MHz is 167uW/MHz (all peripheral clocks disabled)&lt;/li&gt;
&lt;li&gt;Arduino is mostly aimed at children in secondary schools. But what about
1-10 year olds?&lt;/li&gt;
&lt;li&gt;The Open-V microcontroller is up on crowdsupply, trying to raise funds to
produce 70k chips. Aim to do the second tapeout in Q1 2017, and produce puzzle
boards in Q2 2018.&lt;/li&gt;
&lt;li&gt;Elkim showed a neat live demo of the OnChip prototype along with a
browser-based programming environment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-risc-v-community-needs-peripheral-cores-elkim-roa:529e3037a37627249629f6513082618e&#34;&gt;The RISC-V community needs peripheral cores: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s good to have an open ISA, but what about the peripherals? e.g. PHYs,
bus IP, clocking circuitry, GPIO&lt;/li&gt;
&lt;li&gt;Open hardware would translate into quality (Linux) drivers&lt;/li&gt;
&lt;li&gt;There is no standard for GPIO. Want to have standard features (e.g.
switching speed, current drive) with a standard interface.&lt;/li&gt;
&lt;li&gt;The OnChip peripherals use AMBA buses&lt;/li&gt;
&lt;li&gt;Have a synthesizable CDR and PLL&lt;/li&gt;
&lt;li&gt;Are working on USB 3.1 gen 2, including the analog frontend.&lt;/li&gt;
&lt;li&gt;Have also been working on &amp;lsquo;chipscope&amp;rsquo; and offset correction&lt;/li&gt;
&lt;li&gt;Also working on LPDDR3. PCS is done, working on UVM IP&lt;/li&gt;
&lt;li&gt;Have a fully synthesised true-random noise generator, and working on NVRAM
on CMOS&lt;/li&gt;
&lt;li&gt;Suggestion: have a common listing of recommended IP (e.g. SPI, I2C, USB PHY
etc).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sub-microsecond-adaptive-voltage-scaling-in-a-28nm-risc-v-socs-ben-keller:529e3037a37627249629f6513082618e&#34;&gt;Sub-microsecond Adaptive Voltage Scaling in a 28nm RISC-V SoCs: Ben Keller&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Energy efficiency is critical in mobile applications&lt;/li&gt;
&lt;li&gt;Faster adaptive voltage scaling (AVS) saves more energy, especially for
bursty workloads&lt;/li&gt;
&lt;li&gt;State of the art SoCs cannot achieve fine-grained AVS because they use
off-chip regulators&lt;/li&gt;
&lt;li&gt;Integrate switch-cap regulators entirely on-die.&lt;/li&gt;
&lt;li&gt;Need adaptive clock generation&lt;/li&gt;
&lt;li&gt;The tape-out (~2 years ago) featured a version of Rocket. 16K I$, 32K D$, no
L2. It also feature a version of Hwacha&lt;/li&gt;
&lt;li&gt;Use a Z-scale core for the power management unit&lt;/li&gt;
&lt;li&gt;Taped out in 28nm FD-SOI. Die area 3.03mm2, with the core area 1.07mm2. 568K
standard cells&lt;/li&gt;
&lt;li&gt;Achieved 41.8 DP GFLOPS/W&lt;/li&gt;
&lt;li&gt;Body bias can be tuned to optimise efficiency for different workloads&lt;/li&gt;
&lt;li&gt;Integrated voltage regulation provided 82-89% system efficiency with
adaptive clocking&lt;/li&gt;
&lt;li&gt;Sub-microsecond adaptive voltage scaling provided up to 40% energy savings
with negligible performance loss&lt;/li&gt;
&lt;li&gt;Will now talk about the Berkeley interpretation of &amp;lsquo;agile&amp;rsquo; hardware
development. See &amp;ldquo;An Agile Approach to Building RISC-V Microprocessors&amp;rdquo;, MICRO
2016.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;Tape-ins&amp;rsquo; before &amp;lsquo;tape-outs&amp;rsquo;. Sprint to an initial design that is
feature-incomplete but functional, put it through the tools etc and shake out
the issues with the VLSI flow. Then iteratively add features.&lt;/li&gt;
&lt;li&gt;There have been 13 Berkeley RISC-V tapeouts in the last 5 years&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reprogrammable-redundancy-for-cache-vmin-reduction-in-a-28nm-risc-v-processor-brian-zimmer:529e3037a37627249629f6513082618e&#34;&gt;Reprogrammable Redundancy for Cache Vmin Reduction in a 28nm RISC-V Processor: Brian Zimmer&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Voltage scaling is effective in reducing energy consumption, and SRAM limits
the minimum operating voltage&lt;/li&gt;
&lt;li&gt;Instead of preventing errors, tolerate errors. A significant reduction in
the minimum voltage is possibly by tolerating 1000s of errors per MB of SRAM&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s been lots of work on the circuit-level for preventing errors, and at
the architectural level for tolerating errors&lt;/li&gt;
&lt;li&gt;Goal for the chip is to prove that SRAM Vmin can be effectively lowered by
tolerating a reasonable number of failing bitcells&lt;/li&gt;
&lt;li&gt;Built on Rocket and modified caches to add reprogrammable redundancy, ECC,
and BIST&lt;/li&gt;
&lt;li&gt;Implemented three techniques: dynamic column redundancy (avoid single-bit
errors in data SRAM), line disable (avoid &lt;code&gt;&amp;gt;=&lt;/code&gt; 2 bit errors in data SRAM), and
bit bypass (avoid all errors in tag SRAM)&lt;/li&gt;
&lt;li&gt;The system architecture involves three voltage domains. One for the uncore,
one for the core, and another for the L2 cache&lt;/li&gt;
&lt;li&gt;Reprogrammable redundancy is fairly straight-forward to add to the L1, but
ECC is more difficult. The ECC decoding is pipelined. If an error is detected,
the operation is recycled&lt;/li&gt;
&lt;li&gt;There is a 2% area overhead for the L2.&lt;/li&gt;
&lt;li&gt;Fabricated prototype is TSMC 28nm HPM.&lt;/li&gt;
&lt;li&gt;The proposed techniques achieve 25% average Vmin reduction (and 49% power
reduction) in the L2 for a 2% area overhead&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fifth RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-one</link>
      <pubDate>Tue, 29 Nov 2016 15:10:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt; is going
on today and tomorrow at the Google&amp;rsquo;s Quad Campus in Mountain View. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor-and-dom-rizzo:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Introduction: Rick O&amp;rsquo;Connor and Dom Rizzo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This workshop is yet again bigger than the last. 350+ attendees, 107 companies, 29 universities.&lt;/li&gt;
&lt;li&gt;The next workshop will be May 9th-10 in Shanghai, China.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-at-uc-san-diego-michael-taylor:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V at UC San Diego: Michael Taylor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Startup software stacks today look a light like an iceberg. A small amount
of &amp;lsquo;value-add&amp;rsquo; at the top, and a huge stack of open source underneath.&lt;/li&gt;
&lt;li&gt;How do we build the equivalent for hardware, the fully open source ASIC
stack?&lt;/li&gt;
&lt;li&gt;Need core IP, IO pads, standard cells, PLLs, high speed I/O, tools, BGA
packages, PCB design, firmware etc&lt;/li&gt;
&lt;li&gt;basejump aims to provide a &amp;lsquo;base class&amp;rsquo; for cheap hardware development. It
includes a standard library of components, an open source package design, and
an open source motherboard&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bsg_ip_cores&lt;/code&gt; aims to be like C++ STL, but for SystemVerilog&lt;/li&gt;
&lt;li&gt;BSG Ten is a recent design featuring 10 RISC-V cores that will be taping out
before the end of the year on a TSMC shuttle run.&lt;/li&gt;
&lt;li&gt;Aim for 100% of the design will be open, including design files for the
chip, PCB, BGA package, firmware.&lt;/li&gt;
&lt;li&gt;BSG Ten has its own 5-stage RV32IM pipeline&lt;/li&gt;
&lt;li&gt;Also working on &amp;lsquo;Certus&amp;rsquo;, a 16nm TSMC design featuring Rocket cores, a
neural network accelerator, and the BSG I/O infrastructure.&lt;/li&gt;
&lt;li&gt;Suggestion: RoCC interface should be wired to the toplevel of the Rocket
hierarchy&lt;/li&gt;
&lt;li&gt;Suggestion: The RISC-V community should have at least yearly stable
end-to-end releases of full RISC-V stacks (Linux to Verilog)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;updates-on-pulpino-florian-zaruba:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Updates on PULPino: Florian Zaruba&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Imperio is the first ASIC implementation of PULPino, done in UMC 65nm.&lt;br /&gt;
Speed: 500MHz.&lt;/li&gt;
&lt;li&gt;Area is 700kGE for the SoC and 40kGE for the core (1kGE = 1.44um2).&lt;/li&gt;
&lt;li&gt;What is PULP? Parallel Ultra Low Power (platform).&lt;/li&gt;
&lt;li&gt;PULPino is a much simplified version of PULP, featuring just 1 core, reduced
interconnect and simplified cache design.&lt;/li&gt;
&lt;li&gt;Have hardware loops, post-incrementing loads and stores and SIMD instruction
extensions.&lt;/li&gt;
&lt;li&gt;Over 20 companies and research institutes are using PULPino&lt;/li&gt;
&lt;li&gt;PULPinov2 is targeted for Q12017. This features support for Verilator
simulation, IP-XACT description, new peripherals (uDMA), new streamlined event
unit, SDK, updated compiler, and improved documentation and tutorials&lt;/li&gt;
&lt;li&gt;In the future, want to work on a secure PULPino capable of running SeL4&lt;/li&gt;
&lt;li&gt;Working on a 10kGE or less RISC-V core. Evaluating 1 and 3-stage pipeline
designs.&lt;/li&gt;
&lt;li&gt;Want to explore heterogeneous configurations, featuring FPU and
accelerators.&lt;/li&gt;
&lt;li&gt;Find out more at the &lt;a href=&#34;http://www.pulp-platform.org&#34;&gt;PULP website&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sifive-fe310-and-low-cost-hifive1-development-board-jack-kang:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;SiFive FE310 and low-cost HiFive1 development board: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SiFive is a fabless semiconductor company. Their business model is to build
custom SoC designs for their customers. Customers give specs and/or IP and
SiFive deliver packaged, tested chips.&lt;/li&gt;
&lt;li&gt;Although a commercial company who may offer commercial licenses, they are
committed to updating the open source rocket-chip implementation.&lt;/li&gt;
&lt;li&gt;RISC-V chips are here: the Freedom E310. This features an RV32IMAC core.&lt;br /&gt;
320MHz+ on TSMC180G. 1.61DMIPS/MHz, 16K L1 I$, 16K data scratchpad, multiple
power domains (supports low power standby). Comes in a 6x6 48-pin QFN&lt;/li&gt;
&lt;li&gt;Claim to be 9x more power efficient than Intel Quark and 2x more power
efficient than the ARM Cortex M0+.&lt;/li&gt;
&lt;li&gt;The HiFive 1 is an Arduino compatible board for this chip. The board design
and SDK is/will be open source. It&amp;rsquo;s now up on
&lt;a href=&#34;https://www.crowdsupply.com/sifive/hifive1&#34;&gt;CrowdSupply&lt;/a&gt;. $59 will get you
one board.&lt;/li&gt;
&lt;li&gt;The RTL for their implementations presented at the last RISC-V workshop are
now open source and &lt;a href=&#34;https://github.com/sifive/freedom&#34;&gt;up at GitHub&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Question: how much (ballpark) might it cost to get 100 prototype chips? For
Freedom Everywhere (microcontroller), looking at less than $100k depending on
the level of customisation needed.&lt;/li&gt;
&lt;li&gt;Question: what is the plan for getting the SiFive chips to be competitive
with the Cortex-M4 and other designs from ARM? Answer: this will come in time
with custom instructions, custom accelerators etc. The ability to customise
will result in better performance/watt than any off the shelf solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rapid-silicon-prototyping-and-production-for-risc-v-socs-neil-hand:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Rapid silicon prototyping and production for RISC-V SoCs: Neil Hand&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Need to support rapid evolution of IoT designs.&lt;/li&gt;
&lt;li&gt;IoT class designs can be achieved in tens of k$.&lt;/li&gt;
&lt;li&gt;All standards based, but not open source&lt;/li&gt;
&lt;li&gt;A standard cell ASIC is typically 52-78 weeks, compared to 10 weeks for a
Baysand Metal configurable standard cell.&lt;/li&gt;
&lt;li&gt;Codasip have 3-stage and 5-stage implementations RISC-V implementations. The
slide compares gate count and frequency vs Rocket and ZScale (watch out for
the slides to be posted, I didn&amp;rsquo;t get a chance to jot down the numbers)&lt;/li&gt;
&lt;li&gt;Have a story for easy extensibility, adding new instructions and having a
new SDK etc generated.&lt;/li&gt;
&lt;li&gt;UltraSoC provides debug&lt;/li&gt;
&lt;li&gt;LLVM is the glue that holds the solution together. They generate an LLVM
compiler based on their processor model and any customer-defined extensions.&lt;/li&gt;
&lt;li&gt;A test chip will be taping out very soon. Also exploring general
availability for a dev-board&lt;/li&gt;
&lt;li&gt;They are developing their own alternative to QEMU for their customers with a
non-copyleft license.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;extending-risc-v-for-application-specific-requirements-steve-cox:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Extending RISC-V for application-specific requirements: Steve Cox&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sometimes a pre-defined ISA is insufficient. May require an
application-optimised ISA. e.g. the Google TPU&lt;/li&gt;
&lt;li&gt;ASIP designer is a tool for automating ASIP design. The process can start
with a pre-existing example model, e..g RISC-V&lt;/li&gt;
&lt;li&gt;ASIP designer has been used in more than 250 unique SoC products&lt;/li&gt;
&lt;li&gt;The speaker gives an example of a header compression accelerator. Start with
a simple 3-stage RV32IM core. This is 24.5k gates on TSMC 28HPM at 500MHz and
32GPRs.&lt;/li&gt;
&lt;li&gt;First, consider instruction level parallelism. e.g. switching to a 2-slot
VLIW. This reduced cycle could by 21% and increased gate count by 31%.&lt;/li&gt;
&lt;li&gt;Next, try adding application-specific instructions. This reduced the code
size by 56%, cycle count by 67%, and added 9% to the gate count (compared to
the original baseline).&lt;/li&gt;
&lt;li&gt;Next, try adding a compare immediate and branch instruction. This reduces
code size by 8% and cycle count by 18% vs the previous result.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-memory-model-for-risc-v-muralidaran-vijayaraghavan:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;A memory model for RISC-V: Muralidaran Vijayaraghavan&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why not SC/TSO? Simple implementations have low performance.&lt;/li&gt;
&lt;li&gt;Why not the POWER/ARM models? Expose too many microarchitectural details and
their axiomatic models are too complex&lt;/li&gt;
&lt;li&gt;Why not RMO? The dependency requirements are too strict&lt;/li&gt;
&lt;li&gt;Want a simple specification with the inclusion of sufficient fences to force
sequential consistency behaviour when necessary&lt;/li&gt;
&lt;li&gt;Which is why they&amp;rsquo;ve introduced WMM: which has a simple operational
specification like SC, TSO.&lt;/li&gt;
&lt;li&gt;WMM introduces the conceptual device of an invalidation buffer. This holds
stale values that may be read by a future load.&lt;/li&gt;
&lt;li&gt;WMM has reconcile fences (clears the invalidation buffer) and commit fences
(flushes the store buffer).&lt;/li&gt;
&lt;li&gt;All instructions are committed in order, so stores cannot overtake loads.
This prevents &amp;lsquo;out of thin air&amp;rsquo; generation of values&lt;/li&gt;
&lt;li&gt;A write -back coherent cache hierarchy is typically global store atomic. SMT
cores with L1 write-through caches aren&amp;rsquo;t, so don&amp;rsquo;t do it.&lt;/li&gt;
&lt;li&gt;Mapping C++11 atomic operations to WMM is straight forward&lt;/li&gt;
&lt;li&gt;Question: what is the difference to the programmer vs TSO? Answer: you would
have to put a reconcile fence whenever you require load/load ordering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-memory-consistency-model-for-risc-v-caroline-trippel:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;A Memory Consistency Model for RISC-V: Caroline Trippel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Princeton have been working on memory consistency model verification. This
resulted in PipeCheck and CCICheck. Then implemented ArMOR, which worked to
more precisely define memory models. COATCheck looks at how e.g. instructions
that are executed as a result of page table walks interact with the memory
model. Finally, TriCheck helps to verify the lowering of e.g. C++11 atomic
constructs to the ISA level, as well as checking the ISA memory model and
hardware memory model.&lt;/li&gt;
&lt;li&gt;Have identified and characterised flaws in the current RISC-V memory model
specification (ASPLOS&amp;rsquo;17).&lt;/li&gt;
&lt;li&gt;Two broad categories of memory model relaxation. Preserved program order
(defines program orderings that hardware must preserve by default) and store
atomicity (defines the order in which stores become visible to cores).&lt;/li&gt;
&lt;li&gt;Propose tighter preserved program order and non-multi-copy store atomicity.&lt;/li&gt;
&lt;li&gt;Why allow non-multiple-copy atomic stores? Commercial ISAs e.g. ARM, Power
allow this, and RISC-V is intended to be integrated with other vendor ISAs on
a shared memory system.&lt;/li&gt;
&lt;li&gt;Want preserved program order to require same address read-read ordering&lt;/li&gt;
&lt;li&gt;Want PPO to maintain order between dependent instructions&lt;/li&gt;
&lt;li&gt;TriCheck compares high level language outcomes to ISA-level outcomes for a
spectrum of legal ISA microarchitectures&lt;/li&gt;
&lt;li&gt;The currently document RISC-V memory model lacks cumulative fences, which
are needed for C/C++ acquire/release synchronisation&lt;/li&gt;
&lt;li&gt;They have formulated an english language diff of the current spec with
proposed changes, but are also working on a formal model.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trust-transparency-and-simplicity-eric-grosse:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Trust, transparency and simplicity: Eric Grosse&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Know your adversary. Many of them might sometimes be your partner as well as
your adversary (e.g. state actors). Notably, seems to be fairly little in the
way of advanced corporate espionage from other companies.&lt;/li&gt;
&lt;li&gt;Fix 1: secure communications. SSL, PGP etc&lt;/li&gt;
&lt;li&gt;Fix 2: authentication. e.g. two-step authentication, hardware security
devices&lt;/li&gt;
&lt;li&gt;Fix 3: stay up to date with patches&lt;/li&gt;
&lt;li&gt;The disclosure process in the hardware community is dramatically different
than software. e.g. rowhammer was known to some hardware vendors well before
the public disclosure.&lt;/li&gt;
&lt;li&gt;Long standing practitioners&amp;rsquo; wisdom: &amp;ldquo;Complexity is the enemy of security&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Modern systems aren&amp;rsquo;t just incredibly complex, they&amp;rsquo;re also largely
undocumented.&lt;/li&gt;
&lt;li&gt;A paranoid&amp;rsquo;s choice of CPU? x86 with Qubes-OS on a NUC kit. Or Coreboot,
u-root on Asus KGPE-D16 motherboard&lt;/li&gt;
&lt;li&gt;For RISC-V, you have the critical advantage of openness - be sure to keep
it. Please resist adding features lightly, or else consider removing others in
compensation. Also consider a CHERI security extension, or tagged memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-foundation-update-rick-o-connor:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Foundation update: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Rick gives another overview of the RISC-V Foundation, and reiterates that
RISC-V is not an open source processor core but an open ISA specification. The
Foundation will encourage both open source and proprietary implementations&lt;/li&gt;
&lt;li&gt;Every year at least two RISC-V Foundation board seats will be up for
election.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s likely the end of year workshop each year will be in Silicon Valley,
and the Spring/Summer workshop will move locations around the year&lt;/li&gt;
&lt;li&gt;The board of directors was formed in Q2 2016, and the technical and
marketing committees were formed in Q3 2016.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-marketing-committee-update-arun-thomas:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Marketing Committee update: Arun Thomas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The marketing committee mission: grow RISC-V mindshare and grow the RISC-V
community&lt;/li&gt;
&lt;li&gt;Activities include organising RISC-V workshops and tutorials, and RISC-V
participation at industry events&lt;/li&gt;
&lt;li&gt;Want to help create RISC-V educational materials for industry practitioners,
researchers, and university students&lt;/li&gt;
&lt;li&gt;The marketing committee has several task groups: RISC-V workshops, outreach,
RISC-V content (creating riscv.org content and educational and marketing
materials), and member content (promoting content from RISC-V Foundation
members)&lt;/li&gt;
&lt;li&gt;David Patterson announces both of his textbooks will have RISC-V editions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-technical-committee-update-yunsup-lee:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Technical Committee update: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Immediate goals:

&lt;ul&gt;
&lt;li&gt;Maintain a roadmap of the RISC-V ISA&lt;/li&gt;
&lt;li&gt;Provide and maintain a golden simulator for the RISC-V ISA&lt;/li&gt;
&lt;li&gt;Provide and maintain a set of verification/validation tests to ensure
conformance&lt;/li&gt;
&lt;li&gt;To upstream software development tools (compiler, debugger etc)&lt;/li&gt;
&lt;li&gt;To maintain and update a list of hardware implementations of the
architecture&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Longer term goals

&lt;ul&gt;
&lt;li&gt;Establish processes to define and standardise future ISA extensions&lt;/li&gt;
&lt;li&gt;Provide guidelines for platform integration&lt;/li&gt;
&lt;li&gt;Set up program committees for future RISC-V workshops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Task groups: opcode space management, privileged ISA specification, formal
specification, debug specification, security, vector extensions, software
toolchain&lt;/li&gt;
&lt;li&gt;By Feb, debug spec will be ratified by the foundation, calling convention
fixed and documented, ELF format fixed and documented, priv-1.10.0&lt;/li&gt;
&lt;li&gt;By November, ratify vector extension&lt;/li&gt;
&lt;li&gt;Formal specification task group: Formal models written in L3, BSV and in Coq&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;free-chips-project-yunsup-lee:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Free Chips Project: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A plan to launch a not-for-profit for hosting open-source RISC-V
implementations, tools, and code&lt;/li&gt;
&lt;li&gt;SiFive loves open source, believes it is essential to their mission.&lt;/li&gt;
&lt;li&gt;The rocket-chip generator has had almost 4000 commits. 40% of all commits so
far come from SiFive&lt;/li&gt;
&lt;li&gt;SiFive contributions to the rocket-chip repository are made under the Apache
v2 license.&lt;/li&gt;
&lt;li&gt;SiFive added RV32I+M/A/F support, compressed support, blocking data cache,
and data SRAM options&lt;/li&gt;
&lt;li&gt;SiFive will publish a TileLink specification&lt;/li&gt;
&lt;li&gt;SiFive recently implemented a library &amp;lsquo;Diplomacy&amp;rsquo; for parameter negotiation.
Also added multi-clock support, clock crossings, and asynchronous reset flops&lt;/li&gt;
&lt;li&gt;The SiFive blocks repository contains low-speed peripherals like SPI, UART,
PWM, GPIO, PMU. These are written in Chisel with TileLink interfaces. It also
includes wrappers for high-speed Xilinx FPGA peripherals&lt;/li&gt;
&lt;li&gt;The SiFive Freedom repository has submodules for rocket-chip and
sifive-blocks and top-level SoC integration glue code&lt;/li&gt;
&lt;li&gt;The Free Chips project has a mission to be a home for open-source codebases
to enable faster, better, cheaper chips. It will sustain and evolve
open-source software tools and HDL code for SoC design. It will ensure free
and open contributions are available to all of the SoC design community. It
will manage publicly accessible, online repositories of source code,
documentation and issues&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;128-bit-addressing-in-risc-v-and-security-steve-wallach:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;128-bit addressing in RISC-V and security: Steve Wallach&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Aim for programming generality. Might have to recompile, but don&amp;rsquo;t want to
have to restructure your software.&lt;/li&gt;
&lt;li&gt;Computer virtual addresses span to local disk only, while other identifiers
such as MACs, URLs, IPv6 are globally unique. What if one unified name
structure could be developed?&lt;/li&gt;
&lt;li&gt;RV128I strawman. 64-bits are used for an object ID, and the other 64 bits
used for a byte offset.&lt;/li&gt;
&lt;li&gt;The object ID is a software or hardware structure considered to be worthy of
a distinct name&lt;/li&gt;
&lt;li&gt;Protection and memory management are independent&lt;/li&gt;
&lt;li&gt;The machine that is simplest to program wins. User cycles are more important
than CPU cycles&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-challenges-of-securing-and-authenticating-embedded-devices-derek-atkins:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;The challenges of securing and authenticating embedded devices: Derek Atkins&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why not just use symmetric encryption e.g. AES to secure your devices? It&amp;rsquo;s
hard to deploy and it doesn&amp;rsquo;t scale (either have one key for many devices or a
database of a huge number of keys)&lt;/li&gt;
&lt;li&gt;Why do people think public key won&amp;rsquo;t work? They think it&amp;rsquo;s too big, too
slow, or too power hungry.&lt;/li&gt;
&lt;li&gt;Many of these beliefs are true, e.g. ECC execution time on Cortex-M ARM
cores is 233-1089ms. Implementations range in 8-30KB of ROM and require
800-3000B of RAM. Hardware implementations are faster, but take a lot of
gates. RSA and Diffie-Hellman are larger and take longer&lt;/li&gt;
&lt;li&gt;Fundamentally these overheads are there because a large number of 4086 bit
numbers are multiplied&lt;/li&gt;
&lt;li&gt;Group theoretic cryptography (GTC) offers a potential answer. Complexity
scales linearly with security instead of quadratically like RSA, ECC etc&lt;/li&gt;
&lt;li&gt;GTC can work with just 6-8 bit math&lt;/li&gt;
&lt;li&gt;The Ironwood Key Agreement Protocol enables two endpoints to generated a
shared secret over an open channel. The Walnut digital signature algorithm
allows one device to generate a document that is verified by another.&lt;/li&gt;
&lt;li&gt;When comparing WalnutDSA on a Rocket core, it compared very favourable to
microECC. 4.9ms run-time vs 2110ms (458ms with multiply/divide).&lt;/li&gt;
&lt;li&gt;WaltnutDSA written in RISC-V assembly achieved a 3.0ms run time&lt;/li&gt;
&lt;li&gt;The C implementation currently runs faster on the ARM Cortex-M3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-with-sanctum-enclaves-ilia-lebedev:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V with Sanctum Enclaves: Ilia Lebedev&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Today privilege implies trust (e.g. a hypervisor is privileged and so must
be trusted). Sanctum decouples hardware protection from trust&lt;/li&gt;
&lt;li&gt;Sanctum uses hardware-assisted isolation, offering strong privacy and
integrity with low overhead&lt;/li&gt;
&lt;li&gt;In remote software attestation, a trusted remote piece of hardware might
measure (hash) and sign the software that is running. The remote user can then
decides where to trust the certificate or not. Claim that prior work included
too much software in their attestation&lt;/li&gt;
&lt;li&gt;Intel recently introduced SGX, which allowed a process to be placed in an
enclave. It aims to protect privacy and integrity of an enclave against a
privileged software adversary. It also protects against some physical attacks,
or instance by encrypting DRAM contents&lt;/li&gt;
&lt;li&gt;There have been a number of side channel attacks demonstrated against SGX.&lt;br /&gt;
e.g. dirty bits on page tables, or cache timing attacks&lt;/li&gt;
&lt;li&gt;Sanctum aims to protect against indirect tacks (such as cache timing
attacks) as well as the direct attacks covered by SGX. It does not protect
against physical access or fault injection&lt;/li&gt;
&lt;li&gt;With Sanctum, the device manufacturer acts as a certificate authority&lt;/li&gt;
&lt;li&gt;Sanctum has a small software TCB, a ~5KLoC machine-mode security monitor&lt;/li&gt;
&lt;li&gt;The reference Sanctum implementation was built on the Rocket RISC-V
implementation&lt;/li&gt;
&lt;li&gt;Enclaves execute on private cores. i.e. it will never share L1 caches,
register, branch target buffer, TLB&lt;/li&gt;
&lt;li&gt;Sanctum also isolates physical memory. DRAM regions are defined, which are
non-overlapping regions of memory assigned to certain enclaves&lt;/li&gt;
&lt;li&gt;To isolate enclaves in the last level cache, allocate exclusively at a
region granularity (see the slides and/or the Sanctum paper for a description
of exactly how this works)&lt;/li&gt;
&lt;li&gt;To provide hardware-assisted isolation, always maintain the invariant that
entries in the TLB are safe and necessary invariants were checked while
performing the page walk&lt;/li&gt;
&lt;li&gt;Very small hardware overhead (50 gates for LLC address rotation, 600 gates
for DMA whitelist). Roughly 2% area increase in total. Roughly 6% performance
overhead in measurements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;joined-up-debugging-and-analysis-in-the-risc-v-world-gajinder-panesar:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Joined up debugging and analysis in the RISC-V world: Gajinder Panesar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Need a vendor-neutral debug infrastructure, enabling access to different
proprietary debug schemes used today by various cores&lt;/li&gt;
&lt;li&gt;Need monitors into interconnects, interfaces, and custom logic which are
run-time configurable with support for cross-triggering&lt;/li&gt;
&lt;li&gt;UltraSoC provides silicon IP and tools for on-chip debug&lt;/li&gt;
&lt;li&gt;As an example, consider a software-defined radio chip. Might want to track
CPU cycles spent on compute vs cache stalls. Or you might track utilised DDR
bandwidth over time.&lt;/li&gt;
&lt;li&gt;UltraSoC monitors are non-intrusive by default&lt;/li&gt;
&lt;li&gt;Has a portfolio of 30 modules. e.g. bus monitors, communications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

